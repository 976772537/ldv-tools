#! /usr/bin/perl -w


use English;
use Env qw(LDV_DEBUG LDV_ETV_DEBUG);
use FindBin;
use Getopt::Long qw(GetOptions);
Getopt::Long::Configure qw(posix_default no_ignore_case);
use strict;

# Add some local Perl packages.
use lib("$FindBin::RealBin/../shared/perl");

# Add some nonstandard local Perl packages.
use ETV::Library;
use LDV::Utils qw(vsay print_debug_warning print_debug_normal print_debug_info
  print_debug_debug print_debug_trace print_debug_all get_debug_level);


################################################################################
# Subroutine prototypes.
################################################################################

# Process command-line options. To see detailed description of these options
# run script with --help option.
# args: no.
# retn: hash corresponding to options.
sub get_opt();

# For a given node obtain a list of files required for error trace
# visualization.
# args: node of error trace hash, requirements hash.
# retn: list of requirements.
sub get_reqs($$);

# Print help message on the screen and exit.
# args: no.
# retn: nothing.
sub help();

# Process a file containing all source code files related with an error trace
# specified.
# args: corresponding file handler.
# retn: hash with information on files, lines, comments, etc.
sub process_srcs($);

# Make visualization of a error trace specified.
# args: node of error trace hash, information on source code files.
# retn: reference to array containing error trace visualized.
sub visualize_et($$);


################################################################################
# Main section.
################################################################################

# Obtain the debug level.
get_debug_level('etv', $LDV_DEBUG, $LDV_ETV_DEBUG);

print_debug_debug("Process command-line options");
my $opts = get_opt();

print_debug_debug("Parse an error trace specified");
my $et = ETV::Library::parse_et($opts->{'fh in'});

if (!$et)
{
  print_debug_warning("Error trace wasn't parsed");
  exit(1);
}

# There are two modes of error trace visualizer work: collect requirements or
# visualize error trace.
if ($opts->{'fh reqs out'})
{
  # Hash for requirements (to atomatically remove duplicates).
  my %reqs;

  print_debug_debug("Obtain requirements for a specified error trace");
  get_reqs($et, \%reqs);

  $OUTPUT_FIELD_SEPARATOR = "\n";
  print({$opts->{'fh reqs out'}} keys(%reqs));
}
else
{
  my $srcs_info;

  if ($opts->{'fh srcs'})
  {
    print_debug_debug("Process source code files related with a given error trace");
    $srcs_info = process_srcs($opts->{'fh srcs'});
  }

  print_debug_debug("Visualize an error trace specified");
  my $etv = visualize_et($et, $srcs_info);

  $OUTPUT_FIELD_SEPARATOR = "\n";
  print({$opts->{'fh out'}} @{$etv});
}

print_debug_debug("Close file handlers");
close($opts->{'fh in'})
  or die("Can't close file handler for '" . $opts->{'fh in'} . "': $ERRNO\n");
if ($opts->{'fh reqs out'})
{
  close($opts->{'fh reqs out'})
    or die("Can't close file handler for '" . $opts->{'reqs out'} . "':"
      . " $ERRNO\n");
}
else
{
  close($opts->{'fh out'})
    or die("Can't close file handler for '" . $opts->{'out'} . "':"
      . " $ERRNO\n");
  if ($opts->{'fh srcs'})
  {
    close($opts->{'fh srcs'})
      or die("Can't close file handler for '" . $opts->{'srcs'} . "':"
        . " $ERRNO\n");
  }
}

print_debug_normal("Make all successfully");


################################################################################
# Subroutines.
################################################################################

sub get_opt()
{
  if (scalar(@ARGV) == 0)
  {
    warn("No options were specified through the command-line. Please see help"
      . " to understand how to use this tool");
    help();
  }
  print_debug_trace("Options '@ARGV' were passed through the command-line");

  my ($help, $in, $out, $reqs_out, $srcs);
  my ($fh_in, $fh_out, $fh_reqs_out, $fh_srcs);

  unless (GetOptions(
    'help|h' => \$help,
    'report|c=s' => \$in,
    'report-out|o=s' => \$out,
    'reqs-out=s' => \$reqs_out,
    'src-files=s' => \$srcs))
  {
    warn("Incorrect options may completely change the meaning! Please see help"
      . " to understand how to use this tool");
    help();
  }

  help() if ($help);

  unless ($in)
  {
    warn("You should specify command-line option --report (-c)");
    help();
  }

  open($fh_in, '<', "$in")
    or die("Can't open file '$in' specified through --report-in (-c) for read:"
      . " $ERRNO");
  print_debug_debug("Error trace to be processed is '$in'");

  unless ($out or $reqs_out)
  {
    warn("You should specify command line option either --report-out (-o) or"
      . " --reqs-out");
    help();
  }

  if ($out)
  {
    open($fh_out, '>', "$out")
      or die("Can't open file '$out' specified through --report-out (-o) for"
        . " write: $ERRNO");
    print_debug_debug("A proccessed error trace wilb be put to '$out'");

    if ($srcs)
    {
      open($fh_srcs, '<', "$srcs")
        or die("Can't open file '$srcs' specified through --src-files for"
          . " read: $ERRNO");
      print_debug_debug("Related to the given error trace source code is"
        . " '$srcs'");
    }
  }
  else
  {
    open($fh_reqs_out, '>', "$reqs_out")
      or die("Can't open file '$reqs_out' specified through --reqs-out for"
        . " write: $ERRNO");
    print_debug_debug("Paths to files required by the given error trace will be"
      . " put to '$reqs_out'");
  }

  print_debug_debug("Command-line options were processed successfully");

  return {'in' => $in
    , 'fh in' => $fh_in
    , 'out' => $out
    , 'fh out' => $fh_out
    , 'reqs out' => $reqs_out
    , 'fh reqs out' => $fh_reqs_out
    , 'srcs' => $srcs
    , 'fh srcs' => $fh_srcs};
}

sub get_reqs($$)
{
  my $node_ref = shift;
  my $reqs = shift;

  my %node = %{$node_ref};

  # Keep a requirement of a node itself.
  # Don't take into account entities that haven't line specified.
  ${$reqs}{$node{'file'}} = 1 if ($node{'file'} and $node{'line'});

  # Walk throught node childrens.
  foreach my $child (@{$node{'children'}})
  {
    get_reqs($child, $reqs);
  }
}

sub help()
{
    print(STDERR << "EOM");

NAME
  $PROGRAM_NAME: visualizes error traces presented in the common format.

SYNOPSIS
  $PROGRAM_NAME [option...]

OPTIONS

  -h, --help
    Print this help and exit with 1.

  -c, --report <path>
    <path> to a file with an error trace to be processed.

  -o, --report-out <path>
    <path> to a file where an error trace visualized will be put.

  --reqs-out <path>
    <path> to a file where a list of files required for error trace
    visualization will be put.

  --src-files <path>
    <path> to a file containing a program source code referenced by a
    given error trace. It's optional. Without this option there won't
    be source code visualization. The file should contain a content of
    files with source code as is separated with:
    -------path/to/file/with/source/code-------


ENVIRONMENT VARIABLES

  LDV_DEBUG
    It's an optional environment variable that specifies a debug
    level. It uses the standard designatures to distinguish different
    debug information printings. Each next level includes all previous
    levels and its own messages.

  LDV_ETV_DEBUG
    Like LDV_DEBUG but it has more priority. It specifies a debug
    level just for this tool.

EOM

  exit(1);
}

sub process_srcs($)
{
  my $fh_srcs = shift;

  # A current location in a source code file processed.
  my $file_name;
  my $line_numb;

  # Create hashes for:
  # 1. Relations between file names, lines and their content as is.
  # 2. Model comments.
  # 3. Model function definitions.
  # 4. Driver environment generator comments.
  my %srcs;
  my %model_comments;
  my %model_func_defs;
  my %deg_comments;
  while (<$fh_srcs>)
  {
    my $line = $_;
    chomp($line);

    # Each source code file should have such the header:
    # -------path/to/file/with/source/code-------
    if ($line =~ /^-------(.*)-------/)
    {
      $file_name = $1;
      print_debug_trace("File '$file_name' is related with a error trace"
        . " visualized");
      $line_numb = 1;
      next;
    }

    print_debug_warning("Source code files related with a error trace processed"
      . " have incorrect format. No file name is specified by means of"
      . " '-------path/to/file/with/source/code-------'")
      unless ($file_name);

    # Read model comments.

    foreach my $model_comment_type (('LDV_COMMENT_ASSERT'
      , 'LDV_COMMENT_CHANGE_STATE'
      , 'LDV_COMMENT_MODEL_FUNCTION_DEFINITION'
      , 'LDV_COMMENT_MODEL_FUNCTION_CALL'
      , 'LDV_COMMENT_MODEL_STATE'
      , 'LDV_COMMENT_OTHER'
      , 'LDV_COMMENT_RETURN'))
    {
      if ($line =~ /^\s*\/\*\s*$model_comment_type\s*/)
      {
        if ($POSTMATCH !~ /\*\/\s*$/)
        {
          print_debug_warning("Model comment '$line' has incorrect format");
          next;
        }

        my $comment = $PREMATCH;
        print_debug_trace("Catch model comment '$comment' corresponding to '$model_comment_type'");

        my %comment_attrs;

        # Read comment attributes. They should be in the format:
        # (attr1 = 'attr1 value', attr2 = 'attr2 value', ...)
        # Note that there may be ')' inside ''.
        if ($comment =~ /\((.*')\s*(?=\))\)\s*/)
        {
          my $attr_all = $1;
          $comment = $POSTMATCH;

          my @attrs = split(/,/, $attr_all);
          # Read attribute name and value for each attribute.
          foreach my $attr (@attrs)
          {
            # Attributes must have the correct format.
            if ($attr =~ /^([^\s]+)\s*=\s*'([^']*)'\s*$/)
            {
              $comment_attrs{$1} = $2;
              print_debug_trace("Read model comment attibute '$1=$2'");
            }
            else
            {
              print_debug_warning("Model comment attribute '$attr' has incorrect format");
            }
          }
        }

        $model_comments{$file_name}{$line_numb}
          = {'type' => $model_comment_type, 'comment' => $comment, 'attrs' => \%comment_attrs};

        # Remember placement of model function definitions.
        if ($model_comment_type eq 'LDV_COMMENT_MODEL_FUNCTION_DEFINITION')
        {
          # All model functions definitions must have a name attribute.
          if ($comment_attrs{'name'})
          {
            $model_func_defs{$comment_attrs{'name'}} = {'src' => $file_name, 'line' => $line_numb};
          }
          else
          {
            print_debug_warning("Model function definition hasn't 'name' attribute");
          }
        }
      }
    }

    # Read driver environment generator comments.
    foreach my $deg_comment_type (('LDV_COMMENT_BEGIN_MAIN'
      , 'LDV_COMMENT_END_MAIN'
      , 'LDV_COMMENT_FUNCTION_CALL'
      , 'LDV_COMMENT_VAR_INIT'))
    {
      if ($line =~ /^\s*\/\*\s*$deg_comment_type\s*([^\*\/]*)\*\/\s*$/)
      {
        $deg_comments{$file_name}{$line_numb}
          = {'type' => $deg_comment_type, 'comment' => $1};
        print_debug_trace("Catch DEG comment '$1' corresponding to '$deg_comment_type'");
      }
    }

    push(@{$srcs{$file_name}}, "$line");
    $line_numb++;
  }

  return {'srcs' => \%srcs
    , 'model comments' => \%model_comments
    , 'model function definitions' => \%model_func_defs
    , 'deg comments' => \%deg_comments};
}

sub visualize_et($$)
{
  my $node_ref = shift;
  my $srcs_info_ref = shift;

  my %node = %{$node_ref};
  my %srcs_info = %{$srcs_info_ref};

  return [$node{'type'}];
}
