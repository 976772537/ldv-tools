################################################################################
# Copyright (C) 2012
# Institute for System Programming, Russian Academy of Sciences (ISPRAS).
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

# full regular expression for cbmc error trace
# /^State (\d+) file ([^"]*) line (\d+) function ([^"]*) thread (\d+)\n----------------------------------------------------\n([^"]*)=([^"]*) ([^"]*)$/


use Env qw(LDV_DEBUG LDV_CPACHECKER_ET_CONV_DEBUG);

# Get from a string given a node location (file and line) and a node value.
# args: a node string, flag says whether a source reference should be updated.
# retn: file, line, value.
sub get_loc_and_val($$);

# We'd like to relate a given CPAchecker error trace with original source code,
# not with the CIL one. So first of all build a map between sources.
# Read a CIL source file from the beginning of the error trace.
my %src_map;
my $header = shift(@et_array);
if (defined($header))
{
  if ($header =~ /^-------(.*)-------$/)
  {
    print_debug_trace("Process '$1' CIL source file");

    my $src_cur = '';
    my $src_line_cur = 0;
    my $cil_line_cur = 1;
    while (scalar(@et_array))
    {
      my $str = shift(@et_array);

      chomp($str);
      last if ($str eq "--------------");

      if ($str =~ /^#line (\d+) "([^"]+)"$/)
      {
        $src_line_cur = $1;
        $src_cur = $2;
      }
      elsif ($str =~ /^#line (\d+)$/)
      {
        $src_line_cur = $1;
      }
      else
      {
        $src_map{$cil_line_cur} = {
            'file' => $src_cur
          , 'line' => $src_line_cur};
        $src_line_cur++;
      }

      $cil_line_cur++;
    }
  }
  else
  {
    print_debug_warning("A CIL source file isn't specified for a CPAchecker"
      . " error trace processed. A first line is '$header'");
    # Return the first line of an error trace processed back.
    unshift(@et_array, $header);
  }
}

# Read the whole error trace specified.
my @et_raw = @et_array;

# Add such the header to distinguish error traces in the common format.
push(@et_conv_array, "Error trace common format v0.1\n");

# Print a path to source code file just one time if it isn't changed.
my $src_prev = '';
# To extract initialization section.
my $isinit = 0;

# Convert a raw error trace into the common format line by line.
while (@et_raw)
{
  my $str = shift(@et_raw);
  chomp($str);
  next if ($str =~ /^\s*$/);

  #my ($src, $line, $val) = get_loc_and_val($str, 1);

  # Do not treat empty nodes.
  #next if ($val =~ /^\s*$/);

  my $src = '';
  my $line = '';
  my $type = "BLOCK";
  my $kind = '';
  my $skip_reason = '';
  my $text = '';

  if ($str =~ /^State (\d+) file ([^"]*) line (\d+) function ([^"]*) thread (\d+)$/)
  {
    $src = $2;
    $line = $3;
    shift(@et_raw);
    my $new_str = shift(@et_raw);
    if ($new_str =~ /^([^"]*) ([^"]*)$/)
    {
      $text = $1;
    }
    push(@et_conv_array, join(' ', ($line, $src, $type, $kind, $skip_reason, ":", $text)));
  }
  
}
print ">>> ";
print join(' ', @et_conv_array);
{
# Supress warnings like 'Subroutine get_loc_and_val redefined' in the manner
# recommended at http://perldoc.perl.org/perldiag.html.
no warnings 'redefine';

sub get_loc_and_val($$)
{
  my $str = shift;
  my $issrc_prev_update = shift;

  # At the beginning a node value equals to a node string.
  my $val = $str;

  # Try to get a corresponding line number.
  my $line = '';
  if ($val =~ /^State (\d+) file ([^"]*) line (\d+)/)
  {
    $val = $POSTMATCH;
    $line = $3 if (defined($1));
  }

  # Elimanate "brackets" from the rest part of a string.
  if ($val =~ /^\s*N\d+\s*-\s*{\s*(.*)\s*}\s*-\s*>\s*N\d+$/)
  {
    $val = $1;
  }
  else
  {
    print_debug_warning("A cbmc error trace specified has unsupported"
     . " format in string '$str'");
    # So don't process this string further.
    return ('', $line, '');
  }

  # Do not get a source code reference for empty nodes.
  return ('', $line, $val) if ($val =~ /^\s*$/);

  # Try to get a corresponding source code location.
  my $src = '';
  if ($src_map{$line})
  {
    # Use a corresponding path just in case when it exists and differs from the
    # previous one.
    my $file = $src_map{$line}{'file'};
    if ($file ne $src_prev)
    {
      $src = '"' . $file . '"';
      $src_prev = $file if ($issrc_prev_update);
    }

    # Also fix up a line number.
    $line = $src_map{$line}{'line'};
  }
  # Do not treat zero line.
  elsif ($line)
  {
    print_debug_trace("Can't find a corresponding source code for line"
      . " '$line'");
  }

  return ($src, $line, $val);
}

}
