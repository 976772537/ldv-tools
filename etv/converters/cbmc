################################################################################
# Copyright (C) 2013
# Institute for System Programming, Russian Academy of Sciences (ISPRAS).
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

use Env qw(LDV_DEBUG);

# Standart CBMC error trace format:
# State <number> file <path_to_file> line <number> function <name> thread <number>
# ----------------------------------------------------
# <assignment> (<returned_value>)
# or:
# State <number> file <path_to_file> line <number> thread <number>
# ----------------------------------------------------
# <assignment> (<returned_value>)
# Format for function with error label:
# Violated property:
# file <path_to_file> line <number> function <name>
# Read the whole error trace specified.

my @et_raw = @et_array;

# Add such the header to distinguish error traces in the common format.
push(@et_conv_array, "Error trace common format v0.1\n");

# Previous function.
my $prev_function = '';

# Convert a raw error trace into the common format line by line.
while (@et_raw)
{
	my $str = shift(@et_raw);
	chomp($str);
	next if ($str =~ /^\s*$/);

	my $src = '';
	my $line = '';
	my $type = "BLOCK";
	my $kind = '';
	my $skip_reason = '';
	my $text = '';
  
	# Standart error trace format.
	if ($str =~ /^State (\d+) file ([^"]*) line (\d+) function ([^"]*) thread (\d+)$/)
	{
		$src = '"' . $2 . '"';
		$line = $3;

		# First call after INIT section.
		if ($prev_function eq "INIT")
		{
			$prev_function = $4;
			# Return from INIT function. 
			push(@et_conv_array, join(' ', ($line, $src, "RETURN")));
			# Call new function.
			push(@et_conv_array, join(' ', ($line, $src, "CALL", ":", $4)));
		}

		# First function call (no INIT section).
		if ($prev_function eq '')
		{
			$prev_function = $4;
			# Call new function.
			push(@et_conv_array, join(' ', ($line, $src, "CALL", ":", $4)));
		}
		# Call of the different function.
		if ($prev_function ne $4)
		{
			$prev_function = $4;
			# Call new function.
			push(@et_conv_array, join(' ', ($line, $src, "CALL", ":", $4)));
		}

		# Getting an assignment.

		shift(@et_raw);
		my $new_str = shift(@et_raw);
		if ($new_str =~ /^(.+) \(([^"]*)\)$/)
		{
			$text = $1;
		}

		# Adding assignment.
		push(@et_conv_array, join(' ', ($line, $src, $type, $kind, $skip_reason, ":", $text)));
	}
	else # Standart format without function.
	{
		if ($str =~ /^State (\d+) file ([^"]*) line (\d+) thread (\d+)$/)
		{
			$src = '"' . $2 . '"';
			$line = $3;
			shift(@et_raw);
			my $new_str = shift(@et_raw);

			# For long parameters.
			while (!($new_str =~ /^(.+) \((.+)\)$/))
			{
				$new_str .= shift(@et_raw);
			}
			if ($new_str =~ /^(.+) \((.+)\)$/)
			{
				$text = $1;
			}
			if ($prev_function eq '')
			{
				$prev_function = "INIT";
				# Starting INIT function.
				push(@et_conv_array, join(' ', ($line, $src, "CALL", "INIT", ":", "INIT")));
			}

			# Adding assignment.
			push(@et_conv_array, join(' ', ($line, $src, $type, ":", $text)));
		}
	}

	# Function with error label:
	if ($str =~ /^Violated property:/)
	{
		$str = shift(@et_raw);
		if ($str =~ /file ([^"]*) line (\d+) function ([^"]*)/)
		{
			$src = '"' . $1 . '"';
			$line = $2;
			$prev_function = $3;
			# Call for function with error label.
			push(@et_conv_array, join(' ', ($line, $src, "CALL", ":", $3)));
		}
	}

}

