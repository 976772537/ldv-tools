#!/usr/bin/perl

################################################################################
# Copyright (C) 2013
# Institute for System Programming, Russian Academy of Sciences (ISPRAS).
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

# RCV Frontend for CBMC tool.

use strict;
use DSCV::RCV::Coverage;
use File::Basename qw(dirname);

# @mains - entry points to the program (currently, the array contains only one)

# $hints_tag - an XML tag from the rule database with some hints to the
#  verifiers on what functionality is required for an efficient verification of
#  the instrumented property (such as "alias analysis should be on"). Currently
#  contains no useful information. See the documentation to kernel rules on the
#  description of the options when they appear. The tag may be accessed with
#  XML::Twig::Elt functions.

# $tmpdir - writable temporary directory, unique for this verification task.
#  You may not have a write access outside of it.

# The wrapper has access to a number of tools and options the LDV backend
# provides, they will be described later, as they're used.

# To distinguish when the wrapper works in logs, set up a unique name for the
# verifier.
set_tool_name("CBMC");

# path to cbmc should be specified in PATH.
my $cbmc = "cbmc";

# The options that control input and output files are automatically prepared by
# LDV internals. You should just specify the rest here.
set_cil_options(
    "--printCilAsIs",
    "--decil",
    # "--noLowerConstants",
    "--noInsertImplicitCasts",
    "--useLogicalOperators",
    "--ignore-merge-conflicts",
    "--no-convert-direct-calls",  # Don't transform simple function calls to calls-by-pointers
    "--no-convert-field-offsets", # Don't transform s->f to pointer arithmetic
    "--no-split-structs",         # Don't transform structure fields into variables or arrays
    "--rmUnusedInlines"
);

# Now, as CIL script and options are prepared, let's invoke the preprocessing.
my @files = preprocess_all_files('cpp','cil-merge');

# If you need more preprocessing, just invoke your own preprocessor here.  As
# we've specified 'cil-merge', the @files array now contains one file.

# If an error has occured during preprocessing, the script will terminate, and
# the further commands won't be executed.  LDV tools will handle and report the
# preprocessing error, if any.

# Since we now got the files (one file, to be exact), we may start to form a
# command line for CBMC.
my @cbmc_options = ($cbmc,@files);


# Check the number of entry points 
die "You can only specify one main for CBMC!" if (scalar @mains != 1);

# Set the option for the entry point
my $main = $mains[0];
push @cbmc_options, "--function",$main;

# Check the number of error locations
die "You can only specify one error label for CBMC!" if (scalar @errlocs != 1);
my $errloc = $errlocs[0];
push @cbmc_options, "--error-label",$errloc;

# unwind options
push @cbmc_options, "--unwind", "2";
push @cbmc_options, "--no-unwinding-assertions";

# External settings
push @cbmc_options,(split /\s+/,$ENV{'cbmc_options'});

my $outputpath = "$tmpdir";
# In CBMC, the trace is stored in the separate file in the output path,
# and we know its name.
my $orig_trace_fname = "$outputpath/error_trace.txt";

# We will need to adjust the trace for seamless integration with LDV, so we'll
# copy the trace here.
my $adjusted_trace_fname = "$tmpdir/error_trace_m.txt";


# HANDLING THE OUTPUT
# As mentioned above, the access to the tool output is provided as a registry of several state machines.

# A state machine is a perl subroutine reference, maintaining its internal state
# via closure mechanism.  It takes a line printed by the tool as an input,
# changes its internal state, and returns either an undef, or a hash reference
# to several KEY=>VALUE pairs.

# For all machines in the registry, the hashes are merged into one, and you may
# access it after the run has accomplished.

# State machines are generated by subroutines that you may find at the end of the file.

# Create verdict calculator.
add_automaton(cbmc_verdict());

# Check if CBMC has detected any syntax errors, and filled the SYNTAX
# bucket.
add_automaton(cbmc_syntax());

# Dump the last 50 lines from stderr output of the tool into the 'TAIL' bucket.
# tail_automaton is a library function; you may find the sources in
# shared/perl/modules/DSCV/RCV/Library.pm

# Note the 'stderr' after the automaton.  It means that it is only applied to
# the standard error stream.  You may specify 'stdout' here as well or instead.
# Here, we're more interested in any exceptions the verifier produces
add_automaton(tail_automaton(50),'stderr');

# Now the limits are set and automatons are added.  We may run the tool
# (specified by the command line we have already prepared).  As an output, we'll
# get:
#   * the result of the run ('OK', 'SIGNAL', or 'LIMITS'), OK meaning that the
#     tool was not interrupted, but, possibly, returned a nonzero code
#   * the return code itself
#   * the merged hash of the automata added.
#   * the file where gzip-ped debug trace resides
my ($result, $errcode, $automata_results, $debug_trace) = run(@cbmc_options);


# NOTE that you should re-add automata with a fresh state if you plan to perform more runs.


# The result of the run is
#   * verdict (safe, unsafe, or unknown);
#   * error trace file;
#   * description with arbitrary text information.  It's a good idea to include
#     some scientific statistics here.
#   * more files you might want to collect from all verification tasks.


# Now calculate the description and verdict.  Verdict was calculated by our
# automaton (if it succeeded).  However, if CBMC has been terminated
# abnormally, the relevant bucket contains an undefined value; assume an unknown
# verdict
my $verdict = $automata_results->{VERDICT} || 'unknown';

# Let's prepare the description string step-by-step
my $description = '';

# If something has prevented CBMC from getting a verdict, we might want to
# know if there was an exception.  Therefore, we'll add the exception to
# description.
if ($verdict eq 'unknown') {
	my @errbuf = @{$automata_results->{'TAIL'}};
	# Add error buffers on unknown.  But first, filter some useless things out of them
	# cbmc's trace is divided into blocks by empty lines.  Some blocks are not interesting to us, and we want the mremoved.
	local $_;
	my $cbmcerrmsg = '';
	my $removing = '';	#if we're removingall stuf until the next empty line
	for my $ln (@errbuf){
		$removing=1 if $ln=~/Dead code detected/;
		$removing=1 if $ln=~/Ignoring inline assembler/;
		if ($ln =~ /^$/){
			$removing = '';
		}else{
			$cbmcerrmsg.=$ln."\n" unless $removing;
		}
	}
	$description .= $cbmcerrmsg."\n";
}

# To convert CBMC error traces to the common format and visualize them
# together with related source code add a header and corresponding CIL source
# files.
local $_;
if ($verdict eq 'unsafe') {
	open(ORIG_TRACE_FILE, '<', $orig_trace_fname) or die "Can't open file with cbmc trace: \"$orig_trace_fname\", $!";
	open(TRACE_FILE, '>', $adjusted_trace_fname) or die "Can't open file with adjsuted cbmc trace: \"$adjusted_trace_fname\", $!";
	for (@files) {
		open(SRC_FILE, '<', $_) or die "Can't open the source file: \"$_\", $!";
		print TRACE_FILE "CBMC error trace v4.5\n";
		print TRACE_FILE "-------$_-------\n";
		while(<SRC_FILE>) {
			print TRACE_FILE  $_
		}
		print TRACE_FILE "\n--------------\n";
		close(SRC_FILE);
	}
	while (<ORIG_TRACE_FILE>) {
		print TRACE_FILE $_;
	}
	close TRACE_FILE;
	close ORIG_TRACE_FILE;
}


# Return results.  The "verdict", "description", and "error_trace" are
# obligatory.  You may add more hash entries, the values should contain files,
# and the keys will distinguish these files by meaning.  The files you've
# specified this way will be stored in the package with results and associated
# with the respective launches that generated them.
result(
	verdict => $verdict,
	description => $description,
	error_trace => $adjusted_trace_fname,
 	coverage => "",
);


# CBMC wrapper ends
# DO NOT INVOKE "exit" FROM HERE!!!

#===================
#  AUTOMATA
#===================

sub cbmc_verdict
{
	return sub {
		my $l=shift or return undef;
		$l=~/VERIFICATION SUCCESSFUL/ and return {VERDICT=>'safe'};
		$l=~/VERIFICATION FAILED/ and return {VERDICT=>'unsafe'};
		return undef;
	};
}

sub cbmc_syntax
{
	my $found_syntax_error = '';
	my $parse_errormsg = '';
	return sub{
		my $l=shift;
		$l =~ /syntax error/ and do { $found_syntax_error = 1;};
		return undef unless $found_syntax_error;
		# Ok, we're inside the syntax error;
		if (defined $l) {
			$parse_errormsg .= "$l";
		} else {
			# Last line of a trace, return what we've accumulated
			return {'SYNTAX' => "CBMC couldn't parse file:\n$parse_errormsg\n", 'VERDICT'=>'unknown'};
		}
		return undef;
	};
}

