#!/usr/bin/perl

# RCV Frontend for CPAchecker tool.

set_tool_name("CPAchecker");

# Available options:
# NO_CIL
# CPACHECKER (defaults to cpa.sh)
# CPACHECKER_CONFIG
# CPACHECKER_OPTIONS

# Prepare initial variables
my $shared_dir = "$ENV{'DSCV_HOME'}/dscv" or die;
my $cpachecker = $ENV{'CPACHECKER'} || "cpa.sh";
my $configs_dir = "$installed_frontends_dir/etc/";

my $cpachecker_config = $ENV{'CPACHECKER_CONFIG'};


# CPAchecker itself does set a memory limit (as of today, the default is 1200 Mbs of Java heap size.)  However, if it just doesn't work, we don't want our machine to get stuck, so we set up a limit of ~2.2 Gb by default.... well, just in case.  The "cases" we observed (char/ipmi/ipmi_watchdog.ko) demonstrate that this is a good estimate of 1.0 Gb of the actual resident memory taken.
set_limits(
	memlimit => 2_200_000,
	# Signal that CPAchecker should be killed with SIGKILL, instead of TERM-wait-KILL sequence.  This is a bug in LDV tools, to be fixed.
	kill_at_once => 1,
);

# CPAchecker requires the files to be processed by CIL before.  We ship CIL by default with the toolset, and this functionality is already adjusted.  You only need to specify it.
my @files = preprocess_all_files('cpp','cil','cil-merge');

my @cpachecker_options = ($cpachecker,@files);

# MANAGE CONFIGURATION FILES ADJUSTMENTS
# The way LDV instruments properties requires the config files to be adjusted.

# If no config file is specified, create a temporary one
my $cpa_cfg_original = $cpachecker_config || "$configs_dir/cpa.cfg.pattern";
my $cpa_cfg_new = "$tmpdir/cpa.cfg";
# Create a temporary config file.  Config is based on our local config, or on user-defined one
my $CPA_CFG; open $CPA_CFG, ">", $cpa_cfg_new or die;
my $LDV_errloc_autom = "$tmpdir/errloc_automaton.txt";

vsay 40, "copy config from $configs_dir/cpa.cfg.pattern\n";
open ORIG_CFG, $cpa_cfg_original or die "$!";
my @orig_lines = <ORIG_CFG>;
close ORIG_CFG;

my $spec_state = 0;
my $rifel_state = 0;
foreach my $oline (@orig_lines) {
	if($oline =~ /\bspecification\s*=\s*.*/) {
		$spec_state = 1;
		$oline = "#The following line was automatically replaced by LDV tools!  We need this automaton!\nspecification = $LDV_errloc_autom\n";
	}
	if($oline =~ /\bcfa.removeIrrelevantForErrorLocations\s*=\s*.*/) {
		$rifel_state = 1;
		$oline = "#The following line was automatically replaced by LDV tools!\ncfa.removeIrrelevantForErrorLocations = false\n";
	}
	vsay 'TRACE', "$oline";
	print $CPA_CFG $oline;
}
# If settings aren't specified in the config, just print them
if ($spec_state == 0) {
	# Automaton specification is not in the config file.  Add our own.
	print $CPA_CFG "\n#The following line was automatically added by LDV tools!  We need this automaton!\nspecification = $LDV_errloc_autom\n";
}
if($rifel_state == 0) {
	print $CPA_CFG "#The following line was automatically replaced by LDV tools!\ncfa.removeIrrelevantForErrorLocations = false\n";
}
close $CPA_CFG;

# For now, we only support one location
(scalar @errlocs > 1) and die;
my $errloc = $errlocs[0];

# Copy Automaton and replace label name with the one we need

open ERRLOC, "$configs_dir/errloc_automaton.txt" or die"$!";
my @errloc_lines = <ERRLOC>;
close ERRLOC;

my $ERRLOC_AUT;  open $ERRLOC_AUT, ">", $LDV_errloc_autom or die;
my $state = 0;
foreach my $oeline (@errloc_lines) {
	if($oeline =~ /(.*)CPALABEL(.*)/) {
		$state = 1;
		$oeline = "$1\[$errloc\]$2";
	}
	vsay 'TRACE', "$oeline";
	print $ERRLOC_AUT $oeline;
}
close $LDV_errloc_autom;

# Add config option to cpachecker call line
push @cpachecker_options,
	"-config","$cpa_cfg_new"
;

# Set the option for the entry point
my $main = $mains[0];
# Add mains
push @cpachecker_options, "-entryfunction",$main if $main;

#write ErrorPath.txt and other files to outputpath
my $outputpath = "$tmpdir/cpa-tmp";
push @cpachecker_options, "-outputpath",$outputpath;

# Additional options
push @cpachecker_options,(split /\s+/,$ENV{'CPACHECKER_OPTIONS'});

add_time_watch(
	'JAVA' => '.*java.*'
);

# In CPAchecker, the trace is stored in the separate file in the output path.
my $orig_trace_fname = "$outputpath/ErrorPath.txt";

# We will need to adjust the trace for seamless integration with LDV, so we'll copy the trace here
my $adjusted_trace_fname = "$tmpdir/error_trace.txt";

# Create verdict calculator
add_automaton(cpachecker_verdict());
# Detect JAVA's native OOM errors
add_automaton(java_oom());
# Check
add_automaton(cpachecker_syntax());
# Dump the last 50 lines from stderr output of the tool into the 'TAIL' bucket
add_automaton(tail_automaton(50),'stderr');

my ($result, $errcode, $automata_results, $debug_trace) = run(@cpachecker_options);

my $verdict = $automata_results->{VERDICT} || 'unknown';

my $description = '';

if ($verdict eq 'unknown') {
	my @errbuf = @{$automata_results->{'TAIL'}};
	# Add error buffers on unknown.  But first, filter some useless things out of them
	# CPAchecker's trace is divided into blocks by empty lines.  Some blocks are not interesting to us, and we want the mremoved.
	local $_;
	my $cpaerrmsg = '';
	my $removing = '';	#if we're removingall stuf until the next empty line
	for my $ln (@errbuf){
		$removing=1 if $ln=~/Dead code detected/;
		$removing=1 if $ln=~/Ignoring inline assembler/;
		if ($ln =~ /^$/){
			$removing = '';
		}else{
			$cpaerrmsg.=$ln unless $removing;
		}
	}
	$description .= $cpaerrmsg."\n";
}

# Add "Src " declarations to the trace.  LDV tool that adjusts the error trace for CPAchecker will use them.
local $_;
if ($verdict eq 'unsafe') {
	open(ORIG_TRACE_FILE, '<', $orig_trace_fname) or die "Can't open file with cpachecker trace: \"$orig_trace_fname\", $!";
	open(TRACE_FILE, '>', $adjusted_trace_fname) or die "Can't open file with adjsuted cpachecker trace: \"$adjusted_trace_fname\", $!";
	print TRACE_FILE "Src $_: " for @files;
	while (<ORIG_TRACE_FILE>) {
		print TRACE_FILE $_;
	}
	close TRACE_FILE;
	close ORIG_TRACE_FILE;
}

# Return results
result(
	verdict => $verdict,
	description => $description,
	error_trace => $adjusted_trace_fname,
);


# CPAchecker wrapper ends

#===================
#  AUTOMATA
#===================

sub java_oom
{
	return sub{
		my $l=shift or return undef;
		# NOTE that this overrides the LIMITS bucket, which is used internally
		$l=~/^Exception.*OutOfMemory/i and return {'LIMITS'=>'Memory Limit Exceeded'};
		return undef;
	};
}

sub cpachecker_verdict
{
	return sub{
		my $l=shift or return undef;
		# Old versions of CPAchecker print somthing like this...
		$l =~ /Error location\(s\) reached\? NO/ and return {'VERDICT' => 'safe'};
		$l =~ /Error location\(s\) reached\? YES/ and return {'VERDICT' => 'unsafe'};
		# Newer versions choose more generic terms
		$l =~ /Given specification violated\? NO/ and return {'VERDICT' => 'safe'};
		$l =~ /Given specification violated\? YES/ and return {'VERDICT' => 'unsafe'};

		$l =~ /No error locations reachable from .*, analysis not necessary/ and return {'VERDICT' => "safe"};
		return undef;
	};
}

sub cpachecker_syntax
{
	my $found_syntax_error = '';
	my $parse_errormsg = '';
	return sub{
		my $l=shift;
		$l =~ /Syntax error in line / and do { $found_syntax_error = 1;};
		return undef unless $found_syntax_error;
		# Ok, we're inside the syntax error;
		if (defined $l){
			$parse_errormsg .= "$l";
		}else{
			# Last line of a trace, return what we've accumulated
			return {'SYNTAX' => "CPAchecker couldn't parse file:\n$parse_errormsg\n", 'VERDICT'=>'unknown'};
		}
		return undef;
	};
}

