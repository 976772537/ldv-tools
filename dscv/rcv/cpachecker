#!/usr/bin/perl

# RCV Frontend for CPAchecker tool.

# Available options:
# NO_CIL
# CPACHECKER (defaults to cpa.sh)
# CPACHECKER_CONFIG
# CPACHECKER_OPTIONS

#======================================================================
# PROCESS OPTIONS AND SET UP INITIAL VARIABLES
#======================================================================
use FindBin;

BEGIN {
	$ENV{'LDV_HOME'} ||= "$FindBin::Bin/../../";
	# Add the lib directory to the @INC to be able to include local modules.
	push @INC,"$ENV{'DSCV_HOME'}/shared/perl";
}

use strict;
use Pod::Usage;
use Getopt::Long;

# Project modules
use LDV::Utils;
use DSCV::RCV::Utils;
use DSCV::Sanity;
use Utils;

# File modules
use File::Basename;
use File::Path qw(mkpath);

my $config={
	cmdfile=>'',
	rawcmdfile=>'',
	watcher_key=>[],
};

my %optionSpecs = ();
$config->{verbosity} = $ENV{'DSCV_DEBUG'} || $ENV{'LDV_DEBUG'} || 10;
LDV::Utils::set_verbosity($config->{verbosity});
LDV::Utils::push_instrument('rcv-cpachecker');

$optionSpecs{'cmdfile=s'} = \$config->{cmdfile};
$optionSpecs{'workdir=s'} = \$config->{workdir};
$optionSpecs{'sanity-dir=s'} = \$config->{sandir};
$optionSpecs{'rawcmdfile=s'} = \$config->{rawcmdfile};
my $watcher_keystr = '';
$optionSpecs{'watcher-key=s'} = \$watcher_keystr;

GetOptions(%optionSpecs) or die("Unrecognized options!");

$config->{watcher_key} = [split /,/,$watcher_keystr];

my $mode = undef;
$config->{cmdfile} and $mode = 'cmd';
$config->{rawcmdfile} and $mode = 'raw';

defined $mode or die "You should specify either --cmdfile or --rawcmdfile option!";

# Prepare initial variables
my $shared_dir = "$ENV{'DSCV_HOME'}/dscv" or die;
my $cpachecker = $ENV{'CPACHECKER'} || "cpa.sh";
my $configs_dir = "$shared_dir/rcv/etc/";
my $workdir = $config->{workdir};

my $cpachecker_config = $ENV{'CPACHECKER_CONFIG'};

my $cil_dir = "$shared_dir/cil";

# Resource limits processing
my $timelimit = $ENV{'RCV_TIMELIMIT'} || (15*60); # We always force time limit.  You shouldn't be able to run checker without one
my $memlimit = $ENV{'RCV_MEMLIMIT'} || undef;	# Do not set memory limit, let cpachecker itself handle this
vsay 40,"Time limit is set to: $timelimit; memory limit is set to $memlimit.\n";

# Check if we launch CIL before the verifier
my $cilly = 1;
if ($ENV{'NO_CIL'}){
	vsay(10,"CIL skipped because NO_CIL environment variable is set\n");
	$cilly='';
}

#Check if cpachecker is available
#cpachecker_quick_check();

#======================================================================
# PREPARE CMDFILE TRAVERSERS AND RUN THEM
#======================================================================
use XML::Twig;

my $sanity = undef;

if ($mode eq 'cmd'){
	# Launch of RCV frontend, process CMDfile and spawn some raw verifier tasks

	-f $config->{cmdfile} or die "RCV's command file $config->{cmdfile} is not found";
#-x $cpachecker or die "RCV's toplevel executable $cpachecker is not an executable file";
	-d $workdir or die "--workdir=$config->{workdir} is not a directory!";
	-d $configs_dir or die "CPAchecker configs directory $configs_dir is not a directory";
	!$cpachecker_config || -f $cpachecker_config or die "CPAchecker configuration '$cpachecker_config' is specified but not readable!";

	# Prepare sanity checks
	$sanity = DSCV::Sanity->new($config->{sandir});

	# Base Dir of system being checked
	my $base_dir = undef;
	my $unbasedir = undef;

	# Now all subroutines are initialized.  Let's start processing the cmdfile.
	my $check_input_file = XML::Twig->new(
		twig_handlers => {
			basedir=>DSCV::RCV::Utils::get_base_dir_maker(\$base_dir,\$unbasedir),
			cc => DSCV::RCV::Utils::cc_maker(\$unbasedir,$workdir),
			ld=> DSCV::RCV::Utils::ld_maker(verifier=>\&verify_cpachecker, unbasedir_ref=>\$unbasedir, workdir=>$workdir, preprocess=>1, cilly=>$cilly, cilly_once=>$cilly, cil_path=>$cil_dir, cil_temps=>"$workdir/cil_temps"),
		}
	);
	$check_input_file->parsefile($config->{cmdfile});
}elsif ($mode eq 'raw'){
	# Parse CMDfile for arguments, and launch RCV only
	my %args = ();
	!-f $config->{rawcmdfile} and die "CPACHECKER's raw command file $config->{rawcmdfile} is not found";

	# How we parse raw xml to %args hash
	%args = Utils::xml_to_hash($config->{rawcmdfile},{to_array => [qw(files errlocs)], to_xml => [qw(hints)]});

	# in this mode work dir is passed as workdir
	$workdir ||= $args{workdir};
	-d $workdir or die "the workdir '$config->{workdir}' is not a directory!";

	# Now we can call BLAST, finally
	call_cpachecker(%args);

}else{
	die "Assertion failed";
}

exit 0;
# NO CODE AFTER THIS POINT!


#======================================================================
# CPACHECKER-SPECIFIC ROUTINES
#======================================================================

sub verify_cpachecker
{
	my %args = @_;
	$args{report} or die;
	# Since arguments alter depending on main, we should save them to temporary.
	my %args_template = (%args);

	for my $main (@{$args{mains}}){
		%args = DSCV::RCV::Utils::args_for_main($main, %args_template);
		if ($args{already_failed}){
			# Print at once, without spawning task through watcher
			open my $CPACHECKER_REPORT, ">", $args{report} or die "Can't open file $args{report}: $!";
			my $repT = XML::Twig::Elt->new('reports');

			# Prepare a failure command
			my $cmdInstT = XML::Twig::Elt->new('ld',{'ref'=>$args{cmd_id}, main=>$main});
			XML::Twig::Elt->new('trace',{},"")->paste($cmdInstT);
			XML::Twig::Elt->new('verdict',{},'UNKNOWN')->paste($cmdInstT);

			# HACK: fix failure description, so that BLAST's parse errors and CPAchecker errors are not mingled
			my $failmsg = $args{already_failed};
			$failmsg =~ s/Fatal error: exception Errormsg.Error//g;
			$failmsg =~ s/Errormsg.Error/\n/g;

			my $rcvResultT = XML::Twig::Elt->new('rcv',{'verifier'=>'cpachecker'});
			XML::Twig::Elt->new('status',{},'FAILED')->paste($rcvResultT);
			XML::Twig::Elt->new('desc',{},$failmsg)->paste($rcvResultT);

			# Calculate and output time elapsed
			XML::Twig::Elt->new('time',{'name'=>'ALL'},0)->paste($rcvResultT);

			$rcvResultT->paste(last_child =>$cmdInstT);
			$cmdInstT->paste($repT);

			# Commit the report
			$repT->set_pretty_print('indented');
			$repT->print($CPACHECKER_REPORT);
			close $CPACHECKER_REPORT;
		}else{
			# Sanity check
			$sanity->blast_called();

			$args{main} = $main;
			my $task_fname = "$config->{cmdfile}.for.$main";
			vsay('TRACE',"Writing command for a single RCV to '$task_fname'\n");
			my $TASK; open $TASK, ">", $task_fname or die "Can't open '$task_fname': $!";
			Utils::hash_to_xml(\%args,'input',$TASK);
			close $TASK;
			vsay('INFO',"Written RCV single command to '$task_fname'\n");
			$ENV{'RCV_FRONTEND_CMD'} = $0;
			# FIXME: key is transferred through env variable.  RCV should be rewritten.
			#                                            task        dir      >>>> the rest is the key to distinguis from others
			LDV::Utils::watcher_cmd_noread('queue','rcv',$task_fname,$workdir,@{$config->{watcher_key}},'rcv',$args{cmd_id},$main);
		}
	}
}

# Call cpachecker
use IPC::Open3;
use StreamAutomaton;
use File::Copy;
use IO::Select;
sub call_cpachecker
{
	my %args = @_;
	# Options that will be passed to the cpachecker tool
	my @cpachecker_options = ($cpachecker,@{$args{files}});

	# Set default options
	# If no config file is specified, create a temporary one
	my $cpa_cfg_original = $cpachecker_config || "$configs_dir/cpa.cfg.pattern";
	my $cpa_cfg_new = "$args{workdir}/cpa.cfg";
	# Create a temporary config file.  Config is based on our local config, or on user-defined one
	my $CPA_CFG; open $CPA_CFG, ">", $cpa_cfg_new or die;
	my $LDV_errloc_autom = "$args{workdir}/errloc_automaton.txt";

	vsay 40, "copy config from $configs_dir/cpa.cfg.pattern\n";
	open ORIG_CFG, $cpa_cfg_original or die "$!";
	my @orig_lines = <ORIG_CFG>;
	close ORIG_CFG;

	my $spec_state = 0;
	my $rifel_state = 0;
	foreach my $oline (@orig_lines) {
		if($oline =~ /\bspecification\s*=\s*.*/) {
			$spec_state = 1;
			$oline = "#The following line was automatically replaced by LDV tools!  We need this automaton!\nspecification = $LDV_errloc_autom\n";
		}
		if($oline =~ /\bcfa.removeIrrelevantForErrorLocations\s*=\s*.*/) {
			$rifel_state = 1;
			$oline = "#The following line was automatically replaced by LDV tools!\ncfa.removeIrrelevantForErrorLocations = false\n";
		}
		vsay 'TRACE', "$oline";
		print $CPA_CFG $oline;
	}
	# If settings aren't specified in the config, just print them
	if ($spec_state == 0) {
		# Automaton specification is not in the config file.  Add our own.
		print $CPA_CFG "\n#The following line was automatically added by LDV tools!  We need this automaton!\nspecification = $LDV_errloc_autom\n";
	}
	if($rifel_state == 0) {
		print $CPA_CFG "#The following line was automatically replaced by LDV tools!\ncfa.removeIrrelevantForErrorLocations = false\n";
	}
	close $CPA_CFG;

	# For now, only one error location is supported by CPACHECKER
	(scalar @{$args{errlocs}} > 1) and die;
	my $errloc = (@{$args{errlocs}})[0];


	# Copy Automaton and replace label name with the one we need

	open ERRLOC, "$configs_dir/errloc_automaton.txt" or die"$!";
	my @errloc_lines = <ERRLOC>;
	close ERRLOC;

	my $ERRLOC_AUT;  open $ERRLOC_AUT, ">", $LDV_errloc_autom or die;
	my $state = 0;
	foreach my $oeline (@errloc_lines) {
		if($oeline =~ /(.*)CPALABEL(.*)/) {
			$state = 1;
			$oeline = "$1\[$errloc\]$2";
		}
		vsay 'TRACE', "$oeline";
		print $ERRLOC_AUT $oeline;
	}
	close $LDV_errloc_autom;

	# Add config option to cpachecker call line
	push @cpachecker_options,
		"-config","$cpa_cfg_new"
	;

	# Add mains and error locations
	push @cpachecker_options, "-entryfunction",$args{main} if $args{main};

	#write ErrorPath.txt and other files to outputpath
	my $outputpath = "$args{debug}-stuff";
	push @cpachecker_options, "-outputpath",$outputpath;

	# For now we do not interpret hints.  We will be generating/copying certain config files for that
	my $hintsT = $args{hints};

	# Additional options
	push @cpachecker_options,(split /\s+/,$ENV{'CPACHECKER_OPTIONS'});

	# TODO rerouting like in blast

	# Resources limit.  We don't set memlimit--see below
	@cpachecker_options = DSCV::RCV::Utils::set_up_timeout({
		timelimit => $timelimit,
		pattern => ".*,ALL;.*java.*,JAVA-PROC;".($ENV{'CPACHECKER_TIMEWATCH'} ? ";".$ENV{'CPACHECKER_TIMEWATCH'} : "") ,
		output => $args{timestats},
		id_str => "DSCV_TIMEOUT ",
		kill_at_once => 1,
		},@cpachecker_options
	);

	# Set memory limit.
	if ($memlimit) {
		# We set memory limit with Java native capabilities.  We use -Xmx and set it to the value supplied by user.  Thus, the memory limit can be overflew a bit, but in return the exception will be native.
		my $memlimit_kb = int($memlimit / 1024);
		$ENV{'JAVA_VM_ARGUMENTS'} .= " -Xmx${memlimit_kb}m";
	}

	vsay ('NORMAL',"Running CPACHECKER for $args{dbg_target}, entry $args{main}...\n");
	vsay (20,@cpachecker_options,"\n");

	# Fork and run CPACHECKER in a child process.	Redirect its output (std and err) to a file
	# Open file to redirect
	my $CPACHECKER_DEBUG;
	open $CPACHECKER_DEBUG, ">", $args{debug} or die "Can't open file $args{debug}: $!";
	# Fork cpachecker
	local $"=" ";
	local (*CPACHECKER_IN,*CPACHECKER_OUT,*CPACHECKER_ERR);
	my $fpid = open3(*CPACHECKER_IN,*CPACHECKER_OUT,*CPACHECKER_ERR,@cpachecker_options) or die "INTEGRATION ERROR.	Can't open3. PATH=".$ENV{'PATH'}." Cmdline: @cpachecker_options";

	vsay (20,"CPACHECKER debug trace is being written to $args{debug}\n");

	# In CPAchecker trace is in the separate file.  We'll just copy it to $args{trace} at the end
	my $trace_fname = "$outputpath/ErrorPath.txt";
	# Create verdict calculator
	my $verdictor = StreamAutomaton->new([StreamAutomaton::limits_check($ENV{'TIMEOUT_IDSTR'}),cpachecker_verdict(),java_oom(),cpachecker_syntax()]);

	my $chunk_size = 4000;
	my $select = IO::Select->new();
	$select->add(\*CPACHECKER_OUT);
	$select->add(\*CPACHECKER_ERR);
	# Buffers to perform a non-block read and split it into lines
	my ($err_buf,$out_buf);
	while (my @ready_fhs = $select->can_read()){ for my $fh (@ready_fhs){
		if ($fh == \*CPACHECKER_OUT) {
			# Non-blocking read and add to buffer
			my $buf;
			my $read = sysread CPACHECKER_OUT,$buf,$chunk_size;
			$out_buf.=$buf;
			# Split buffer into lines and push to result calculator
			while ($out_buf =~ /(.*?\n)(.*)/s) {
				my $line = $1;
				$out_buf=$2;
				# Process the line fetched
				$verdictor->chew_line($line);
				print $CPACHECKER_DEBUG $line;
			}
			# Read of zero indicates an EOF, and read of undef indicates an error (which may be a closed pipe)
			unless ($read){
				# chew what's left in the buffer
				$verdictor->chew_line($out_buf);
				print $CPACHECKER_DEBUG $out_buf;
				$select->remove(\*CPACHECKER_OUT);
			}
		}elsif ($fh == \*CPACHECKER_ERR) {
			# Non-blocking read and add to buffer
			my $buf;
			my $read = sysread CPACHECKER_ERR,$buf,$chunk_size;
			$err_buf.=$buf;
			# Split buffer into lines and push to result calculator
			while ($err_buf =~ /(.*?\n)(.*)/s) {
				my $line = $1;
				$err_buf=$2;
				# Process the line fetched
				$verdictor->chew_line($line);
				print $CPACHECKER_DEBUG $line;
			}
			# Read of zero indicates an EOF, and read of undef indicates an error (which may be a closed pipe)
			unless ($read){
				# chew what's left in the buffer
				$verdictor->chew_line($err_buf);
				print $CPACHECKER_DEBUG $err_buf;
				$select->remove(\*CPACHECKER_ERR);
			}
		}
	}}

	my %child = Utils::hard_wait($fpid,0);
	close $CPACHECKER_DEBUG;

  vsay (40,"CPACHECKER open3 return value: $?\n");
	vsay (20,"CPACHECKER return value: $?\n");
	vsay (40,"CPACHECKER stats: utime $child{'utime'}, stime $child{'stime'}\n");
	my $cpachecker_rv = $? >> 8;
	my $cpachecker_rv_full = $?;
	if($? == 0){
		vsay (20,"CPACHECKER OK\n");
	}else{
		vsay ('WARNING',"CPACHECKER failed with exit code $cpachecker_rv.  We consider it fatal\n");
	}

	my $result = {%{$verdictor->result()}};
	# Don't set it up--it should be set by CPAchecker
	# $result->{'CPACHECKER'} = "yes";
	# Post limits and verdict on different lines!
	$result->{'CPACHECKER-detailed'} = join "\n",(grep {$_} ($result->{'CPACHECKER-detailed'},$result->{'LIMITS'}));
	# Add timing information into the result returned
	$result->{'utime'} = $child{'utime'};
	$result->{'stime'} = $child{'stime'};

	# Copy back trace if it exists
	if (-r $trace_fname) {
		copy($trace_fname,$args{trace}) or die;
	}

	# Add information about limits to result
	my $tl4rep = $timelimit ? "$timelimit sec" : "not set";
	my $ml4rep = $memlimit ? "$memlimit Kb" : "not set";
	# TODO: check of there is --version-like option to CPAchecker
	#my $ver4rep = `pbast.opt --version`;
	my $ver4rep = "";
	$result->{'CPACHECKER-detailed'} .= <<EOR ;

=========== Launch information ===========
Verifier: CPAchecker ($ver4rep)
Time Limit: $tl4rep
Memory Limit: $ml4rep (average)
Additional options: $ENV{'CPACHECKER_OPTIONS'}
=========== Launch inform ends ===========
EOR

	# OK, CPAchecker finished, and now we print small XML report for it

	# Assignments to port the old code
	my $main = $args{main};

	open my $CPACHECKER_REPORT, ">", $args{report} or die "Can't open file $args{report}: $!";
	my $repT = XML::Twig::Elt->new('reports');

	# Print verdict to console and to report
	vsay (10,"$main: CPACHECKER status: $result->{'CPACHECKER'}\n");
	vsay (20,"$main: CPACHECKER verdict: $result->{'CPACHECKER-detailed'}\n");

	# Verdict
	my $bv = $result->{'CPACHECKER-detailed'};
	if ($bv =~ /\bsafe\b/) {
		$bv='SAFE';
	}elsif($bv =~ /\bunsafe\b/){
		$bv='UNSAFE';
	}else{
		$bv='UNKNOWN';
	}
	# Result is derived from verdict
	my $br = $result->{'CPACHECKER'};
	vsay (40, "CPACHECKER status is $br\n");
	if($br =~ /\bno\b/i){
		$br='FAILED';
	}elsif (($br =~ /\byes\b/i) && ($bv ne 'UNKNOWN') ) {
		$br='OK';
	}else{
		$br='FAILED';
	}

	# Write source files to trace. This is needed since cpachecker
	# doesn't provide good location and just print links to lines of a
	# preprocessed cill file. At least add this file to trace.
	# I can't secure that there is a trace for each unsafe verdict so check it.
	if ($bv eq 'UNSAFE' and -f $args{trace}) {
		open(TRACE_FILE, '<', $args{trace}) or die "Can't open file with cpachecker trace: \"$args{trace}\", $!";
		my @cpachecker_trace = <TRACE_FILE>;
		close TRACE_FILE;
		open(TRACE_FILE, '>', $args{trace}) or die "Can't open file with cpachecker trace: \"$args{trace}\", $!";
		my @cpachecker_src_files = @{$args{files}};
		my $cpachecker_src_file = shift(@cpachecker_src_files);
		print TRACE_FILE "Src $cpachecker_src_file: ";
		foreach (@cpachecker_trace) {
			print TRACE_FILE $_;
		}
		close TRACE_FILE;
	}

	my $cmdInstT = XML::Twig::Elt->new('ld',{'ref'=>$args{cmd_id}, main=>$main});
	XML::Twig::Elt->new('trace',{},$args{trace})->paste($cmdInstT);
	XML::Twig::Elt->new('verdict',{},$bv)->paste($cmdInstT);
	# Confess who is responsible for that mess
	XML::Twig::Elt->new('verifier',{},'CPAchecker')->paste($cmdInstT);

	my $rcvResultT = XML::Twig::Elt->new('rcv',{'verifier'=>'cpachecker'});
	XML::Twig::Elt->new('status',{},$br)->paste($rcvResultT);
	XML::Twig::Elt->new('desc',{},$result->{'CPACHECKER-detailed'})->paste($rcvResultT);

	# Calculate and output time elapsed
	# Read file with time statistics
	# copied from blast script
	# TODO(time): check it
	my $timestats_fname = $args{timestats};
	if ( -f $timestats_fname && ! -z $timestats_fname ) {
		my %timestats;
		open(STATS_FILE, '<', $timestats_fname) or die "Can't open file with time statistics: \"$timestats_fname\", $!";
		while(<STATS_FILE>) {
			/^\s*<time\s+name="(.*)"\s*>\s*([0-9\.]*)\s*<\/time>/ or next;
			$timestats{$1} += $2;
		}
		close STATS_FILE;
		foreach(keys %timestats) {
			my $time_elt = XML::Twig::Elt->new('time',$timestats{$_});
			$time_elt->set_att( name =>$_);
			$time_elt->paste($rcvResultT);
		}
	} else {
		my $time_elt = XML::Twig::Elt->new('time',0);
		$time_elt->set_att( name =>"ALL");
		$time_elt->paste($rcvResultT);
	}

	$rcvResultT->paste(last_child =>$cmdInstT);
	$cmdInstT->paste($repT);

	$repT->set_pretty_print('indented');
	$repT->print($CPACHECKER_REPORT);
	close $CPACHECKER_REPORT;
}



# This subroutine used to
# Perform CPACHECKER quick check before running any verifications
# But it was suppressed because CPAchecker takes too much time to start.
sub cpachecker_quick_check
{
}

sub java_oom
{
	return[10_000,sub{
		my $l=shift or return undef;
		$l=~/^Exception.*OutOfMemory/i and return {'LIMITS'=>'Memory Limit Exceeded'};
		return undef;
	}];
}

sub cpachecker_verdict
{
	return[100_000,sub{
		my $l=shift or return undef;
		# Old versions of CPAchecker print somthing like this...
		$l =~ /Error location\(s\) reached\? NO/ and return {'CPACHECKER-detailed' => 'The system is safe.', 'CPACHECKER'=>'yes'};
		$l =~ /Error location\(s\) reached\? YES/ and return {'CPACHECKER-detailed' => 'The system is unsafe.', 'CPACHECKER'=>'yes'};
		# Newer versions choose more generic terms
		$l =~ /Given specification violated\? NO/ and return {'CPACHECKER-detailed' => 'The system is safe.', 'CPACHECKER'=>'yes'};
		$l =~ /Given specification violated\? YES/ and return {'CPACHECKER-detailed' => 'The system is unsafe.', 'CPACHECKER'=>'yes'};

		$l =~ /No error locations reachable from .*, analysis not necessary/ and return {'CPACHECKER-detailed' => "The system is safe.  Error location is not reachable.", 'CPACHECKER'=>'yes'};
		return undef;
	}];
}

sub cpachecker_syntax
{
	my $found_syntax_error = '';
	my $parse_errormsg = '';
	return[10_000,sub{
		my $l=shift;
		$l =~ /Syntax error in line / and do { $found_syntax_error = 1;};
		return undef unless $found_syntax_error;
		# Ok, we're inside the syntax error;
		if (defined $l){
			$parse_errormsg .= "$l";
		}else{
			# Last line of a trace, return what we've accumulated
			return {'CPACHECKER-detailed' => "CPAchecker couldn't parse file:\n$parse_errormsg\n", 'CPACHECKER'=>'no'};
		}
		return undef;
	}];
}

# Trace dumper.  Usage:  my $dumper = dumptrace(filename);
use constant { TRACE_WAIT => 0, TRACE_READ => 1, TRACE_DONE =>2};
my $current_fh;
sub dumptrace
{
	my $fname = shift or die;
	# In CPAchecker, the whole file is the trace
	my $state = TRACE_READ;
	my $current_fh;
	return [1_000_000,sub {
		my ($line) = @_;
		if ($state == TRACE_READ){
			unless ($current_fh){
				open $current_fh, ">>", $fname or die;
			}
			print $current_fh $line;
		}
		return undef;
	}];
}

