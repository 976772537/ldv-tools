#!/usr/bin/perl

# RCV Frontend for blast tool.

use strict;
use Pod::Usage;
use Getopt::Long;

my $config={
	cmdfile=>'',
};

my %optionSpecs = ();
$config->{verbosity} = $ENV{'DSCV_DEBUG'} || $ENV{'LDV_DEBUG'} || 10;
$optionSpecs{'cmdfile=s'} = \$config->{cmdfile};
$optionSpecs{'workdir=s'} = \$config->{workdir};

sub vsay
{
	my $verbosity = shift;
	local $,=' ';
	print @_,"\n" if $verbosity <= $config->{verbosity};
}

GetOptions(%optionSpecs) or die("Unrecognized options!");

# Prepare running environment
use FindBin;
my $shared_dir = "$ENV{'DSCV_HOME'}" or die;
my $backend_dir = "$shared_dir/rcv/backends/blast";
my $blast = "$backend_dir/bin/pblast.opt";
my $workdir = $config->{workdir};

-f $config->{cmdfile} or die "BLAST's command file $config->{cmdfile} is not found";
-d $backend_dir or die "BLAST's directory $backend_dir is not a directory";
-x $blast or die "BLAST's toplevel executable $blast is not an executable file";
-d $workdir or die "--workdir=$config->{workdir} is not a directory!";

# Add path for blast's supplementary scripts.  Prepending to system's to override other PATHs.
$ENV{'PATH'} = "$backend_dir/bin:".$ENV{'PATH'};

# Base Dir of system being checked
my $base_dir = undef;
sub get_base_dir
{
	my ($twig, $cmdT) = @_;
	$base_dir = $cmdT->text();
}
# Remove basedir to get a raw file name
sub unbasedir
{
	my $from = shift or die;
	my $rslt = $from;
	$rslt =~ s/^$base_dir\/*//;
	return $rslt;
}
sub relpath
{
	my $base = shift or die;
	my $to = shift or die;
	if ($to =~ /^\//) {
		return $to;
	}else{
		return "$base/$to";
	}
}
use File::Basename;
use File::Path qw(mkpath);

# We should have parsed the command file, get dependencies, etc, etc...  but now we just check if it's a valid XML.
use XML::Twig;
my $check_input_file = XML::Twig->new( twig_handlers => { basedir=>\&get_base_dir, cc => \&execute_cc, ld=>\&execute_ld});
sub execute_cc
{
	my ($twig, $cmdT) = @_;
	# Flush the list of all .c files to the .o file being checked
	local $_;
	my @c_files_raw = unbasedir($cmdT->children_text('in'));
	my $o_file_raw = unbasedir($cmdT->first_child_text('out'));
	my $o_file = "$workdir/$o_file_raw";
	# Write the list to o-file
	mkpath(dirname($o_file));
	my $children_FH; open $children_FH,">",$o_file or die "Dead while trying to open $o_file for writing";
	$cmdT->print($children_FH);
	#local $,="\n";
	#print $children_FH @c_files_raw;
	close $children_FH;
}
sub execute_ld
{
	my ($twig, $cmdT) = @_;
	# Get the list of c files for current linked file
	# We assume that each c-file is included into any executable file only once (otherwise there would have been undefined references).
	local $_;
	my @o_files_raw = map {unbasedir($_)} $cmdT->children_text('in');
	my $target = unbasedir($cmdT->first_child_text('out'));
	# Informaiton about C files should be a reference, for it to be accessible from within subs
	my $c_files_info = [];
	# List of c files that were processed.  Used in tracking the assersion that each c file is processed only once.  Value is an o-file, in which the c file was first encountered.
	my %c_files_Sanity = ();
	for my $o_file_raw (@o_files_raw){
		# From each o-file local copy, which contains list of c-files in that object one, get these files
		my $o_file = relpath($workdir,$o_file_raw);

		# Get information about this object file
		my $c_files = [];
		# Compiler options to build this particular o-file.  We *know* that there's only *one* command in this file, so there's no need to distpatch this level as well.
		my $aux_opts = [];
		my $cwd = undef;
		my $obj_file = undef;
		XML::Twig->new( twig_handlers=> {
			'opt' => sub { push @$aux_opts,$_[1]->text(); },
			# Input files are taking without change
			'in' => sub { push @$c_files,$_[1]->text(); },
			# Output files are tuned to be in-rcv
			'out' => sub { $$obj_file = relpath($workdir,unbasedir($_[1]->text())); },
			'cwd' => sub { $$cwd = $_[1]->text(); },
		})->parsefile($o_file);

		# Propagate the information gathered to c_files_info arrays
		local $_;
		for my $c_file (@$c_files){
			# Sanity check
			my $c_file_already_encountered = $c_files_Sanity{$c_file};
			$c_file_already_encountered and die "C file $c_file is used twice, when linking $target: in $c_file_already_encountered and $$obj_file"; 
			$c_files_Sanity{$c_file} = $$obj_file; 

			# Prepare record
			my $new_record = {c_file=>$c_file, opts=>$aux_opts, cwd=>$$cwd};
			# Preprocess file if necessary
			my $preprocess_dir = "$workdir/preprocessed";
			mkpath($preprocess_dir);
			my $i_file = $c_file; $i_file =~ s/\.c$/.i/; $i_file =~ s/\//-/g; $i_file = "$preprocess_dir/$i_file";
			mkpath(dirname($i_file));
			$new_record->{i_file} = $i_file;
			preprocess_file($new_record);

			push @$c_files_info, $new_record;
		}
	}

	# Call blast for all of the preprocessed c-files gotten at once, and and supply the additional arguments fetched from the tag record.

	# Get hints tag first 
	my $hintsT = $cmdT->first_child('hints');
	# Get entry points
	my @mains = $cmdT->children_text('main');
	# Get list of files to analyze:
	my @files = map {$_->{i_file}} @$c_files_info;
	# List of error locations
	my @errlocs = $cmdT->children_text('error');
	# Report file
	my $report = "$workdir/reports/$target";
	mkpath(dirname($report));

	# TODO: add a separate report file
	call_blast(files => \@files, hints=>$hintsT, main=>$_, errlocs=>\@errlocs, report=>$report) for @mains; 
	
}

sub hard_wait
{
	my $wpres = 0;
	while ($wpres == 0){
		$wpres = waitpid $_[0],$_[1];
	}
	return $wpres;
}

# Call blast
use IPC::Open3;
sub call_blast
{
	my %args = @_;
	# Options that will be passed to the blast tool
	my @blast_options = ("pblast.opt",@{$args{files}});
	# Set default options
	# These are: -alias bdd -cref -predH 7 -lattice -include-lattice symb -include-lattice list -craig 2 -cldepth 0 -nomusts -const
	push @blast_options,
		"-predH","7","-cref","-craig","2",	# Default heuristics on
		"-lattice","-include-lattice","symb", 	# Symbolic-store lattice
		"-nomusts","-const",	#Aliasing heuristics implemented in ISPRAS
	;

	# Add mains and error locations
	push @blast_options, "-main",$args{main} if $args{main};
	# For now, only one error location is supported by BLAST
	(scalar @{$args{errlocs}} > 1) and die;
	my $errloc = (@{$args{errlocs}})[0];
	push @blast_options, "-L",$errloc if $errloc;

	# Interpret hints
	my $hintsT = $args{hints};
	# Cldepth
	if (my $cld = $hintsT->first_child_text('cldepth')){
		push @blast_options,"-cldepth",$cld;
	}else{
		# Temporarly set cldepth to zero
		push @blast_options,"-cldepth","0";
	}
	if (my $ali = $hintsT->first_child_text('alias')){
		if ($ali eq 'none'){
		}else{
			die "Uninterpreted <alias> hint value: $ali";
		}
	}else{
		push @blast_options,
			"-alias","bdd"	# Turn alias analysis on
		;
	}
	vsay 20,@blast_options;

	# Fork and run BLAST in a child process.	Redirect its output (std and err) to a file
	# Open file to redirect
	my $BLAST_REPORT;
	open $BLAST_REPORT, ">", $args{report} or die "Can't open report $args{report}: $!";
	my ($BLAST_IN,$BLAST_OUT,$BLAST_ERR);
	# Fork blast
	local $"=" ";
	my $fpid = open3($BLAST_IN,$BLAST_OUT,$BLAST_ERR,@blast_options) or die "INTEGRATION ERROR.	Can't open3. PATH=".$ENV{'PATH'}." Cmdline: @blast_options";

	# Process output and redirect it to file
	local $_;
	print $BLAST_REPORT $_ while <$BLAST_OUT>;
	print $BLAST_REPORT $_ while <$BLAST_ERR>;
	# TODO: perhaps, here we can process it at once with filters?
	# TODO: add GZIPping as well

	# TODO: This should be replaced by select(2) call, but I'm too lazy to do it now.	We'll just print STDERR after STDOUT.
	hard_wait($fpid,0) < 0 and die;
	close $BLAST_REPORT;

  vsay 20,"BLAST open3 return value: $?\n";
	vsay 10,"Error return value: $?\n";
	my $blast_rv = $? >> 8;
	# NOTE that exit code 2 is for OCaml unhandled exceptions
	if ($blast_rv == 5){
		# BLAST didn't find input file -- integration error
		die "BLAST couldn't find some input files";
	}elsif($blast_rv == 3){
		die "BLAST couldn't find entry point/error location";
	}elsif($? == 0){
		warn "BLAST OK";
	}else{
		warn "BLAST failed with exit code $blast_rv.  But who cares?";
	}
}
use Cwd;
sub preprocess_file
{
	my $info = shift or die;
	# Change dir to cwd; then change back
	my $current_dir = getcwd();
	chdir $info->{cwd} or die;
	my @cpp_args = ("gcc","-E",
		"-o","$info->{i_file}",	#Output file
		"$info->{c_file}",	#Input file
		@{$info->{opts}},	#Options
	);
	vsay 20,@cpp_args;
	local $"; $"=' ';
	system @cpp_args and die "NON-FATAL error in preprocessing.  Cmdline: @cpp_args";
	chdir $info;
}


# Perform BLAST quick check before running any verifications

$" = ' ';      # For error reporting
vsay 10, "Trying to run blast without arguments to see it it works\n";
my @blast_args = ("pblast.opt","-help");
my $CHEW_BLAST_OUT;
my $fpid = open $CHEW_BLAST_OUT,"-|";
defined $fpid or die "Can't fork?  Wtf";
if ($fpid == 0){
       # child
       # Run blast
       exec @blast_args or die "INTEGRATION ERROR. PATH=".$ENV{'PATH'}." Cmdline: @blast_args";
       exit 1;
}
# Parent
# Chew blast's output.  Read into buffer
#my $read_bytes = 0; my $buffer; my $buflen = 1 << 12;
#while (($read_bytes = read $CHEW_BLAST_OUT,$buffer,$buflen) && $read_bytes) {};
#defined $read_bytes or die;	# undef in $read_bytes means read error

my $wpres = hard_wait($fpid,0);
$wpres > 0 or die;
$? == 0 or die die "INTEGRATION ERROR.  BLAST test exited with non-zero return code $?.";
# Ok, now we can close the pipe
close($CHEW_BLAST_OUT);



# Now all subroutines are initialized.  Let's start processing the cmdfile.
$check_input_file->parsefile($config->{cmdfile});
