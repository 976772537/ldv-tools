#!/usr/bin/perl

# RCV Frontend for blast tool.

use strict;
use Pod::Usage;
use Getopt::Long;

my $config={
	cmdfile=>'',
};

my %optionSpecs = ();
$config->{verbosity} = 10;
$optionSpecs{'cmdfile=s'} = \$config->{cmdfile};
$optionSpecs{'workdir=s'} = \$config->{workdir};
$optionSpecs{'debug!'} = sub {$config->{verbosity} = 20};

sub vsay
{
	my $verbosity = shift;
	local $,=' ';
	print @_,"\n" if $verbosity <= $config->{verbosity};
}

GetOptions(%optionSpecs) or die("Unrecognized options!");

# Prepare running environment
use FindBin;
my $shared_dir = "$ENV{'DSCV_HOME'}" or die;
my $backend_dir = "$shared_dir/rcv/backends/blast";
my $blast = "$backend_dir/bin/pblast.opt";
my $workdir = $config->{workdir};

-f $config->{cmdfile} or die "BLAST's command file $config->{cmdfile} is not found";
-d $backend_dir or die "BLAST's directory $backend_dir is not a directory";
-x $blast or die "BLAST's toplevel executable $blast is not an executable file";
-d $workdir or die "--workdir=$config->{workdir} is not a directory!";

# Add path for blast's supplementary scripts.  Prepending to system's to override other PATHs.
$ENV{'PATH'} = "$backend_dir/bin:".$ENV{'PATH'};

# Base Dir of system being checked
my $base_dir = undef;
sub get_base_dir
{
	my ($twig, $cmdT) = @_;
	$base_dir = $cmdT->text();
}
# Remove basedir to get a raw file name
sub unbasedir
{
	my $from = shift or die;
	my $rslt = $from;
	$rslt =~ s/^$base_dir\/*//;
	return $rslt;
}
use File::Basename;
use File::Path qw(mkpath);

# We should have parsed the command file, get dependencies, etc, etc...  but now we just check if it's a valid XML.
use XML::Twig;
my $check_input_file = XML::Twig->new( twig_handlers => { basedir=>\&get_base_dir, cc => \&execute_cc, ld=>\&execute_ld});
sub execute_cc
{
	my ($twig, $cmdT) = @_;
	# Flush the list of all .c files to the .o file being checked
	local $_;
	my @c_files_raw = unbasedir($cmdT->children_text('in'));
	my $o_file_raw = unbasedir($cmdT->first_child_text('out'));
	my $o_file = "$workdir/$o_file_raw";
	# Write the list to o-file
	mkpath(dirname($o_file));
	my $children_FH; open $children_FH,">",$o_file or die "Dead while trying to open $o_file for writing";
	$cmdT->print($children_FH);
	#local $,="\n";
	#print $children_FH @c_files_raw;
	close $children_FH;
}
sub execute_ld
{
	my ($twig, $cmdT) = @_;
	# Get the list of c files for current linked file
	# We assume that each c-file is included into any executable file only once (otherwise there would have been undefined references).
	local $_;
	my @o_files_raw = map {unbasedir($_)} $cmdT->children_text('in');
	my $target = unbasedir($cmdT->first_child_text('out'));
	# Informaiton about C files should be a reference, for it to be accessible from within subs
	my $c_files_info = [];
	# List of c files that were processed.  Used in tracking the assersion that each c file is processed only once.  Value is an o-file, in which the c file was first encountered.
	my %c_files_Sanity = ();
	for my $o_file_raw (@o_files_raw){
		# From each o-file local copy, which contains list of c-files in that object one, get these files
		my $o_file = "$workdir/$o_file_raw";

		# Get information about this object file
		my $c_files = [];
		# Compiler options to build this particular o-file.  We *know* that there's only *one* command in this file, so there's no need to distpatch this level as well.
		my $aux_opts = [];
		my $cwd = undef;
		my $obj_file = undef;
		XML::Twig->new( twig_handlers=> {
			'opt' => sub { push @$aux_opts,$_[1]->text(); },
			# Input files are taking without change
			'in' => sub { push @$c_files,$_[1]->text(); },
			# Output files are tuned to be in-rcv
			'out' => sub { $$obj_file = "$workdir/".unbasedir($_[1]->text()); },
			'cwd' => sub { $$cwd = $_[1]->text(); },
		})->parsefile($o_file);

		# Propagate the information gathered to c_files_info arrays
		local $_;
		for my $c_file (@$c_files){
			# Sanity check
			my $c_file_already_encountered = $c_files_Sanity{$c_file};
			$c_file_already_encountered and die "C file $c_file is used twice, when linking $target: in $c_file_already_encountered and $$obj_file"; 
			$c_files_Sanity{$c_file} = $$obj_file; 

			# Prepare record
			my $new_record = {c_file=>$c_file, opts=>$aux_opts, cwd=>$$cwd};
			# Preprocess file if necessary
			my $preprocess_dir = "$workdir/preprocessed";
			mkpath($preprocess_dir);
			my $i_file = $c_file; $i_file =~ s/\.c$/.i/; $i_file =~ s/\//-/g; $i_file = "$preprocess_dir/$i_file";
			$new_record->{i_file} = $i_file;
			preprocess_file($new_record);

			push @$c_files_info, $new_record;
		}
	}

	# Call blast for all of the preprocessed c-files gotten at once, and and supply the additional arguments fetched from the tag record.

	# Get hints tag first 
	my $hintsT = $cmdT->first_child('hints');
	# Get entry points
	my @mains = $cmdT->children_text('main');
	# Get list of files to analyze:
	my @files = map {$_->{i_file}} @$c_files_info;
	# List of error locations
	my @errlocs = $cmdT->children_text('error');

	# TODO: add a separate report file
	call_blast(files => \@files, hints=>$hintsT, main=>$_, errlocs=>\@errlocs) for @mains; 
	
}

# Call blast
sub call_blast
{
	my %args = @_;
	# Options that will be passed to the blast tool
	my @blast_options = ("pblast.opt",@{$args{files}});
	# Set default options
	# These are: -alias bdd -cref -predH 7 -lattice -include-lattice symb -include-lattice list -craig 2 -cldepth 0 -nomusts -const
	push @blast_options,
		"-predH","7","-cref","-craig","2",	# Default heuristics on
		"-lattice","-include-lattice","symb", 	# Symbolic-store lattice
		"-nomusts","-const",	#Aliasing heuristics implemented in ISPRAS
	;

	# Add mains and error locations
	push @blast_options, "-main",$args{main} if $args{main};
	# For now, only one error location is supported by BLAST
	(scalar @{$args{errlocs}} > 1) and die;
	my $errloc = (@{$args{errlocs}})[0];
	push @blast_options, "-L",$errloc if $errloc;

	# Interpret hints
	my $hintsT = $args{hints};
	# Cldepth
	if (my $cld = $hintsT->first_child_text('cldepth')){
		push @blast_options,"-cldepth",$cld;
	}else{
		# Temporarly set cldepth to zero
		push @blast_options,"-cldepth","0";
	}
	if (my $ali = $hintsT->first_child_text('alias')){
		if ($ali eq 'none'){
		}else{
			die "Uninterpreted <alias> hint value: $ali";
		}
	}else{
		push @blast_options,
			"-alias","bdd"	# Turn alias analysis on
		;
	}
	vsay 20,@blast_options;
	system(@blast_options) == -1 and die;
	vsay 10,"Error return value: $?\n";
	my $blast_rv = $? >> 8;
	if ($blast_rv == 2){
		# BLAST didn't find input file -- integration error
		die "BLAST couldn't find some input files";
	}elsif($blast_rv == 3){
		die "BLAST couldn't find entry point/error location";
	}elsif($? == 0){
		warn "BLAST OK";
	}else{
		warn "BLAST failed.  But who cares?";
	}
}
$" = ' ';	# For error reporting
my @blast_args = ("pblast.opt","-help");
my $blast_out_FH;
my $fpid = open $blast_out_FH,"-|",@blast_args;
defined $fpid or die "INTEGRATION ERROR. PATH=".$ENV{'PATH'}." Cmdline: @blast_args";
if ($fpid == 0){
	# child
	# chew the output.  Do nothing
	exit;
}
# Parent
# Parend for now does nothing as well

# ! PREPROCESS!


use Cwd;
sub preprocess_file
{
	my $info = shift or die;
	# Change dir to cwd; then change back
	my $current_dir = getcwd();
	chdir $info->{cwd} or die;
	my @cpp_args = ("gcc","-E",
		"-o","$info->{i_file}",	#Output file
		"$info->{c_file}",	#Input file
		@{$info->{opts}},	#Options
	);
	vsay 20,@cpp_args;
	local $"; $"=' ';
	system @cpp_args and die "NON-FATAL error in preprocessing.  Cmdline: @cpp_args";
	chdir $info;
}

# Now all subroutines are initialized.  Let's start processing the cmdfile.
$check_input_file->parsefile($config->{cmdfile});
