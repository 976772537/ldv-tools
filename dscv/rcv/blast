#!/usr/bin/perl

# RCV Frontend for BLAST tool.

#======================================================================
# PROCESS OPTIONS AND SET UP INITIAL VARIABLES
#======================================================================

BEGIN {
	# Add the lib directory to the @INC to be able to include local modules.
	push @INC,"$ENV{'DSCV_HOME'}/shared/perl";
}

use strict;
use Pod::Usage;
use Getopt::Long;

# Project modules
use LDV::Utils;
use DSCV::RCV::Utils;
use DSCV::Sanity;
use Utils;

# File modules
use File::Basename;
use File::Path qw(mkpath);

my $config={
	cmdfile=>'',
};

my %optionSpecs = ();
$config->{verbosity} = $ENV{'DSCV_DEBUG'} || $ENV{'LDV_DEBUG'};
$config->{verbosity} = 10 unless defined $config->{verbosity};
LDV::Utils::set_verbosity($config->{verbosity});
LDV::Utils::push_instrument('rcv-blast');

$optionSpecs{'cmdfile=s'} = \$config->{cmdfile};
$optionSpecs{'workdir=s'} = \$config->{workdir};
$optionSpecs{'sanity-dir=s'} = \$config->{sandir};

GetOptions(%optionSpecs) or die("Unrecognized options!");


# Prepare initial variables
my $shared_dir = "$ENV{'DSCV_HOME'}/dscv" or die;
my $backend_dir = "$shared_dir/rcv/backends/blast";
my $blast = "$backend_dir/bin/pblast.opt";
my $workdir = $config->{workdir};

-f $config->{cmdfile} or die "BLAST's command file $config->{cmdfile} is not found";
-d $backend_dir or die "BLAST's directory $backend_dir is not a directory";
-x $blast or die "BLAST's toplevel executable $blast is not an executable file";
-d $workdir or die "--workdir=$config->{workdir} is not a directory!";

# Resource limits processing
my $timelimit = $ENV{'RCV_TIMELIMIT'} || (15*60); # We always force time limit.  You can't run the checker without one.
my $memlimit = $ENV{'RCV_MEMLIMIT'} || (1_000_000); # Default memory limit is 1Gb
vsay 40,"Time limit is set to: $timelimit; memory limit is set to $memlimit.\n";


# Prepare sanity checks
my $sanity = DSCV::Sanity->new($config->{sandir});


# Add path for blast's supplementary scripts.  Prepending to system's to override other PATHs.
$ENV{'PATH'} = "$backend_dir/bin:".$ENV{'PATH'};

#Check if blast is available
blast_quick_check();


#======================================================================
# PREPARE CMDFILE TRAVERSERS AND RUN THEM
#======================================================================
use XML::Twig;

# Base Dir of system being checked
my $base_dir = undef;
my $unbasedir = undef;

# Now all subroutines are initialized.  Let's start processing the cmdfile.
my $check_input_file = XML::Twig->new(
	twig_handlers => {
		basedir=>DSCV::RCV::Utils::get_base_dir_maker(\$base_dir,\$unbasedir),
		cc => DSCV::RCV::Utils::cc_maker(\$unbasedir,$workdir),
		ld=> DSCV::RCV::Utils::ld_maker(verifier=>\&verify_blast, unbasedir_ref=>\$unbasedir, workdir=>$workdir, preprocess=>1, cilly=>0, archivated=>1),
	}
);
$check_input_file->parsefile($config->{cmdfile});

exit 0;
# NO CODE AFTER THIS POINT!


#======================================================================
# BLAST-SPECIFIC ROUTINES
#======================================================================

sub verify_blast
{
	my %args = @_;
	$args{report} or die;
	open my $BLAST_REPORT, ">", $args{report} or die "Can't open file $args{report}: $!";
	my $repT = XML::Twig::Elt->new('reports');

	# Since arguments alter depending on main, we should save them to temporary.
	my %args_template = (%args);

	for my $main (@{$args{mains}}){
		%args = DSCV::RCV::Utils::args_for_main($main, %args_template);
		my $result = call_blast(%args, main=>$main); 
	
		# Print verdict to console and to report 
		vsay (10,"$main: BLAST status: $result->{'BLAST'}\n");
		vsay (20,"$main: BLAST verdict: $result->{'BLAST-detailed'}\n");

		my $br = $result->{'BLAST'};
		if ($br =~ /\byes\b/i) {
			$br='OK';
		}elsif($br =~ /\bno\b/i){
			$br='FAILED';
		}else{
			$br='FAILED';
		}

		my $bv = $result->{'BLAST-detailed'};
		if (($br eq 'OK') && ($bv =~ /AAAA: safe\b/)) {
			$bv='SAFE';
		}elsif(($br eq 'OK') && ($bv =~ /AAAA: unsafe\b/)){
			$bv='UNSAFE';
		}else{
			$bv='UNKNOWN';
		}


		my $cmdInstT = XML::Twig::Elt->new('ld',{'ref'=>$args{cmd_id}, main=>$main});
		XML::Twig::Elt->new('trace',{},$args{trace})->paste($cmdInstT);
		XML::Twig::Elt->new('verdict',{},$bv)->paste($cmdInstT);
		# Confess who is responsible for that mess
		XML::Twig::Elt->new('verifier',{},'BLAST')->paste($cmdInstT);

		my $rcvResultT = XML::Twig::Elt->new('rcv',{'verifier'=>'blast'});
		XML::Twig::Elt->new('status',{},$br)->paste($rcvResultT);
		XML::Twig::Elt->new('desc',{},$result->{'BLAST-detailed'})->paste($rcvResultT);

		# Calculate and output time elapsed
		#		my $time_sec = $result->{'utime'}+$result->{'stime'};
		#		my $time_msec = int($time_sec * 1000);
		#		XML::Twig::Elt->new('time',{},$time_msec)->paste($rcvResultT);
		# Read file with time statistics
		if ( -f "$workdir/stats_rcv.xml" ) {
			my %timestats;
				open(STATS_FILE, '<', "$workdir/stats_rcv.xml") or die "Can't open file with time statistics: \"$workdir/stats_rcv.xml\", $!";
				while(<STATS_FILE>) {
					/^\s*<time\s+name="(.*)"\s*>\s*([0-9]*)\s*<\/time>/ or next;
					$timestats{$1} += $2;
					#my $time_elt = XML::Twig::Elt->new('time',$2);
					#$time_elt->set_att( name =>$1);
					#$time_elt->paste($rcvResultT);
				}
				close STATS_FILE;
				foreach(keys %timestats) {
					my $time_elt = XML::Twig::Elt->new('time',$timestats{$_});
					$time_elt->set_att( name =>$_);
					$time_elt->paste($rcvResultT);
				}
		} else {
			my $time_elt = XML::Twig::Elt->new('time',0);
			$time_elt->set_att( name =>"ALL");
			$time_elt->paste($rcvResultT);
		};

		$rcvResultT->paste(last_child =>$cmdInstT);
		$cmdInstT->paste($repT);
	}

	$repT->set_pretty_print('indented');
	$repT->print($BLAST_REPORT);
	close $BLAST_REPORT;
}

# Call blast
use IPC::Open3;
use StreamAutomaton;
use IO::Compress::Gzip qw($GzipError);
sub call_blast
{
	my %args = @_;
	# Options that will be passed to the blast tool
	my @blast_options = ("pblast.opt",@{$args{files}});
	# Set default options
	# These are: -predH 7 -lattice -include-lattice symb -include-lattice list -craig 2 -cldepth 0
	push @blast_options,
		"-predH","7","-craig","2",	# Default heuristics on
		"-ignoredupfn", # Ignore duplicated functions when constructing CFA
		"-nosserr", # Ignore "combining structure and non-structure values" error.  LLVM emits such nasty code.
	;

	# Add mains and error locations
	push @blast_options, "-main",$args{main} if $args{main};
	# For now, only one error location is supported by BLAST
	(scalar @{$args{errlocs}} > 1) and die;
	my $errloc = (@{$args{errlocs}})[0];
	push @blast_options, "-L",$errloc if $errloc;

	# Interpret hints
	my $hintsT = $args{hints};
	# Cldepth
	if (defined $hintsT
		&& ( my $cld = $hintsT->first_child_text('cldepth')))
	{
		push @blast_options,"-cldepth",$cld;
	}else{
		# Temporarly set cldepth to zero
		push @blast_options,"-cldepth","0";
	}
	# Alias hint
	my $do_aliases =
		# Aliases may be hinted by the model
		(defined $hintsT && ($hintsT->first_child_text('alias')))
		# But now we don't perform the analysis
		;
	# Special "aliases" switch may be activated (BLAST_EXP_NOALIAS is obsolete now)
	vsay('WARNING',"Use of BLAST_EXP_NOALIAS is obsolete!!\n") if $ENV{'BLAST_EXP_NOALIAS'};
	$do_aliases ||= $ENV{'BLAST_ALIASES'};
	if ($do_aliases){
		vsay ('NORMAL',"Running BLAST with alias analysis (this may take longer).\n");
		push @blast_options,
			"-alias","bdd",	# Turn alias analysis on
			"-cref",	#"Complete REFinement", performs alias iterations, implies alias analysis
			"-nomusts","-const",	#Aliasing heuristics implemented in ISPRAS
		;
	}else{
		vsay ('NORMAL',"Running BLAST without alias analysis.\n");
	}
	# Filter also lattices if specified
	unless ($ENV{'BLAST_EXP_NOLATTICE'}){
		push @blast_options,
			"-lattice","-include-lattice","symb", 	# Symbolic-store lattice
		;
	}

	# Rerouting functionality enabling
	my $rerouteT = $hintsT ? $hintsT->first_child('rerouter') : undef;
	if ($rerouteT){
		my @reroute_map = $rerouteT->children_text('map');
		my @reroute_foreach = $rerouteT->children_text('foreach');
		my $placeholder = $rerouteT->first_child_text('placeholder');
		# Skip if there's not map and foreach handlers
		if (@reroute_map || @reroute_foreach){
			push @blast_options,"-reroute";
			local $_;
			push @blast_options,"-reroute-map",$_ for @reroute_map;
			push @blast_options,"-reroute-foreach",$_ for @reroute_foreach;
			push @blast_options,"-reroute-placeholder",$placeholder if $placeholder;
		}
	}


	# External settings
	push @blast_options,(split /\s+/,$ENV{'BLAST_OPTIONS'});
	# Solver
	push @blast_options,"-smt" if $ENV{'BLAST_SOLVER'};

	# Adjust timewatch if a supported solver is set (it should begin with a semicolon if not empty!)
	my $solver_timewatch = '';
	if (my $slv = $ENV{'BLAST_SOLVER'}){
		if ($slv eq 'yices'){
			$solver_timewatch = ';.*yices.*,YICES';
		}
	}

	# Fork and run BLAST in a child process.	Redirect its output (std and err) to a file
	# To Limit resources for BLAST we use timeout script.
	@blast_options = DSCV::RCV::Utils::set_up_timeout({
		timelimit => $timelimit,
		memlimit => $memlimit,
		pattern => ".*,ALL;.*pblast\.opt.*,PBLAST.OPT;.*cvc3.*,CVC3;.*smtlibServer.*,SMTSERVER".$solver_timewatch.($ENV{'BLAST_TIMEWATCH'} ? ";".$ENV{'BLAST_TIMEWATCH'} : "") ,
		output => "$workdir/stats_rcv.xml",
		id_str => "DSCV_TIMEOUT ",
		},@blast_options
	);
	# Identification to distinguish timeout's messages from other stuff

	# Tune OCaml runtime options, if necessary
	# (this option will be default soon)
	unless ($ENV{'BLAST_NOOCAMLTUNE'}){
		my $ocamltune = "$ENV{'DSCV_HOME'}/shared/sh/ocaml_params";
		-x $ocamltune or die "Executable ocaml_params script needed but $ocamltune given!";
		my $params = `$ocamltune $memlimit`; chomp $params;
		if ($?){
			vsay ('WARNING',"OCaml machine-specific tuning ($ocamltune) failed!!!  No params set.\n");
		}else{
			$ENV{'OCAMLRUNPARAM'} = $params;
		}
		vsay ('INFO',sprintf("OCaml machine-specific tuning is performed!  OCAMLRUNPARAM='%s'\n",($ENV{'OCAMLRUNPARAM'}||'')));
	}else{
		vsay ('INFO',sprintf("OCaml machine-specific tuning is not performed.  OCAMLRUNPARAM='%s'\n",($ENV{'OCAMLRUNPARAM'}||'')));
	}

	# Tell arguments
	vsay ('NORMAL',"Running BLAST for $args{dbg_target}, entry $args{main}...\n");
	vsay (20,@blast_options,"\n");

	# Open file to redirect
	# The streams will be printing GZIP-compressed text.
	# TODO: Make it parallel.  Currently it's all processed inline, in the same thread.
	my $BLAST_DEBUG = new IO::Compress::Gzip $args{debug} or die "gzip failed: $GzipError\n";
	my ($BLAST_IN,$BLAST_OUT,$BLAST_ERR);
	# Fork blast
	local $"=" ";
	my $fpid = open3($BLAST_IN,$BLAST_OUT,$BLAST_ERR,@blast_options) or die "INTEGRATION ERROR.	Can't open3. PATH=".$ENV{'PATH'}." Cmdline: @blast_options";

	vsay (20,"BLAST debug trace is being written to $args{debug}\n");

	# Sanity check
	$sanity->blast_called();

	# Create trace printer
	my $dumptrace = dumptrace($args{trace});
	# Create verdict calculator
	my $verdictor = StreamAutomaton->new([$dumptrace,StreamAutomaton::limits_check($ENV{'TIMEOUT_IDSTR'})]);

	# Process output and redirect it to file
	local $_;
	# TODO: This should be replaced by select(2) call, but I'm too lazy to do it now.	We'll just print STDERR after STDOUT.
	while (<$BLAST_OUT>) {
		print $BLAST_DEBUG $_;
		$verdictor->chew_line($_);
	}
	while (<$BLAST_ERR>) {
		print $BLAST_DEBUG $_;
		$verdictor->chew_line($_);
	}

	my %child = Utils::hard_wait($fpid,0);
	close $BLAST_DEBUG;

	vsay (40,"BLAST open3 return value: $?\n");
	vsay (20,"BLAST return value: $?\n");
	vsay (40,"BLAST stats: utime $child{'utime'}, stime $child{'stime'}\n");
	my $blast_rv = $? >> 8;
	# NOTE that exit code 2 is for OCaml unhandled exceptions
	if ($blast_rv == 5){
		# BLAST didn't find input file -- integration error
		die "BLAST couldn't find some input files";
	}elsif($blast_rv == 3){
		die "BLAST couldn't find entry point/error location";
	}elsif($? == 0){
		vsay (20,"BLAST OK\n");
	}else{
		vsay (20,"BLAST failed with exit code $blast_rv.  But who cares?\n");
	}

	my $result = {%{$verdictor->result()}};
	$result->{'BLAST-detailed'} .= $result->{'LIMITS'};
	# Add timing information into the result returned
	$result->{'utime'} = $child{'utime'};
	$result->{'stime'} = $child{'stime'};

	# Add information about limits to result
	my $tl4rep = $timelimit ? "$timelimit sec" : "not set";
	my $ml4rep = $memlimit ? "$memlimit Kb" : "not set";
	# Should be like this, but BLAST doesn't support it...
	#my $ver4rep = `pbast.opt --version`;
	my $ver4rep = "";
	$result->{'BLAST-detailed'} .= <<EOR ;

=========== Launch information ===========
Verifier: BLAST ($ver4rep)
Time Limit: $tl4rep
Memory Limit: $ml4rep
Additional options: $ENV{'BLAST_OPTIONS'}
Solver: @{[ $ENV{'BLAST_SOLVER'} || 'default' ]}
=========== Launch inform ends ===========
EOR

	return $result;
}



# Perform BLAST quick check before running any verifications
sub blast_quick_check
{
	$" = ' ';      # For error reporting
	vsay ('INFO', "Trying to run blast without arguments to see it it works...");
	my @blast_args = ("pblast.opt","-help");
	my $CHEW_BLAST_OUT;
	my $fpid = open $CHEW_BLAST_OUT,"-|";
	defined $fpid or die "Can't fork?  Wtf";
	if ($fpid == 0){
		# child
		# Run blast
		exec @blast_args or die "INTEGRATION ERROR. PATH=".$ENV{'PATH'}." Cmdline: @blast_args";
		exit 1;
	}
	# Parent
	# Ignore blast's output.
	my %wpres = Utils::hard_wait($fpid,0);
	# \n to complement previous message
	$? == 0 or die "\nINTEGRATION ERROR.  BLAST test exited with non-zero return code $?.";
	# Ok, now we can close the pipe
	close($CHEW_BLAST_OUT);

	vsay ('INFO',"OK\n");
}



# Trace dumper.  Usage:  my $dumper = dumptrace(filename);
use constant { TRACE_WAIT => 0, TRACE_READ => 1, TRACE_DONE =>2};
sub dumptrace
{
	my $fname = shift or die;
	my $state = TRACE_WAIT;
	my $current_fh;
	return [1_000_000,sub {

		my ($line) = @_;
		!defined $line && $state==TRACE_DONE and do{ close $current_fh; return undef;};
		return undef if $state == TRACE_DONE;

		$line =~ /Error trace: \(final\)/ and do {$state = TRACE_READ; return undef;};
		$line =~ /Error trace ends \(final\)/ and do {$state = TRACE_DONE; return undef;};

		if ($state == TRACE_READ){
			unless ($current_fh){
				open $current_fh, ">>", $fname or die;
			}
			print $current_fh $line;
		}
		return undef;
	}];
}

