#!/usr/bin/perl
#=============================================
=head1 NAME

dscv - verify C program against one or several properties from a property database.

DSCV stands for B<Domain-Specific C Verifier>.  This is a working title.

=head1 SYNOPSIS

Compilation commands must be passed to the tool (all at once or sequentially), as well as a list of properties, and working directory. 

DSCV supports both cmdline interface (when a file with build commands is supplied) and direct interface (when files to verify are directly passed on command line).

If there's no argument named "inline", C<dscv> runs in cmdfile mode:

	dscv --cmdfile=commands.xml --rule-models=0032a,0039

Otherwise, DSCV runs in an inline mode:

	dscv --verifier=blast inline options -I include/ files file1.c file2.c

=head1 DESCRIPTION

TODO

=cut

use strict;

=head1 COMMAND LINE OPTIONS

=over 8

=cut

use Pod::Usage;
use Getopt::Long;

# Configuration structure
my $config={
	dir=>'./',
};

my %optionSpecs = ();

=item B<--cmdfile>

File with build commands.  The format is standard for LDV project.  Must be specified, at the current state of art.

=cut
$optionSpecs{'cmdfile=s'} = \$config->{cmdfile};

=item B<--rule-model=model_id>, B<--rule-models=model_id,model_id,...>

Properties to check.  They are looked for in property datbase.

=cut
$config->{property} = [];
$config->{properties} = [];
$optionSpecs{'rule-model=s@'} = \$config->{property};
$optionSpecs{'rule-models=s@'} = \$config->{properties};

=item B<--verifier=backend>

Overrides the verifier passed by rule instrumentor.

=cut
$optionSpecs{'verifier=s'} = \$config->{verifier_override};

=back

=cut
my %inline_handlers = ();
sub is_handler_keyword
{
	my $x = shift;
	local $_;
	# undef is thought of as a keyword (since it terminates the last sequence)
	return (!defined $x) || (grep {$_ eq $x} keys %inline_handlers);
}
# Create subroutine that, if at the beginning of input array there is a keyword, reads keyword-related words into $$target array; up to the next keyword otto the end of the array
sub make_handler
{
	my ($keyword, $target) = @_;
	$$target ||= [];
	return sub{
		return () unless @_;
		return @_ if $_[0] ne $keyword;
		shift;	#remove keyword
		my $f = shift;
		while (!is_handler_keyword($f)){
			push @$$target, $f;
			$f = shift;
		}
		return () unless defined $f;
		return ($f,@_);
	};
};


=pod
Inline mode options

=over 8

=item B<files> [list of files]

In inline mode, specifies the list of files that will be verified as if they were linked together.

=cut
$inline_handlers{'files'}=make_handler('files',\$config->{inl_files});

=item B<options> [list of GCC options]

In inline mode, specifies the list of GCC options that will be passsed to compiler and/or preprocessor

=cut
$inline_handlers{'options'}=make_handler('options',\$config->{inl_options});
=item B<option> [list of GCC options]

In inline mode, specifies the list of entry points to check.  If omitted, only one entry point, C<main>, is checked.

=cut
$inline_handlers{'entries'}=make_handler('entries',\$config->{inl_entries});

=back

=head1 ENVIRONMENT VARIABLES

=over 8

=cut

=item B<LDV_RULE_DB>

Rule database address.  It is interpreted by rule interpreter.  Also, the rule database should contain installing script, C<install> that prepares an instance of rule database for Rule Instrumentator to work.

=cut
$config->{rule_db_dir} = $ENV{'LDV_RULE_DB'};

=item B<WORK_DIR>

Working directory for a current instance of LDV scripts.  Unless specified, a current working dir is taken as working.

=cut
use Cwd;
$config->{work_dir} = $ENV{'WORK_DIR'} || getcwd();

=item B<DSCV_HOME>

Base directory, into which DSCV-related scripts and backends are installed.  Set automatically, but may be overridden.

=cut
use FindBin;
BEGIN {
	$ENV{'DSCV_HOME'} ||= "$FindBin::Bin/..";
	$ENV{'LDV_HOME'} ||= "$FindBin::Bin/..";
}
$config->{dscv_dir} = "$ENV{'DSCV_HOME'}/dscv";

BEGIN {
	# Add the lib directory to the @INC to be able to include local modules.
	push @INC,"$ENV{'LDV_HOME'}/shared/perl";
}

=item B<LDV_DEBUG>, B<DSCV_DEBUG>

Level of verbosity, ranging from 0 (silent) to 100 (trace).  Default is 10.  B<DSCV_DEBUG> takes precedence over B<LDV_DEBUG>.

=cut
$config->{verbosity} = $ENV{'DSCV_DEBUG'} || $ENV{'LDV_DEBUG'} || 10;


=item B<RULE_INSTRUMENTOR>

Specify custom rule instrumentor.  Unless specified, the program is deduced from C<DSCV_HOME> environment or taken from path.

=cut
$config->{rule_ins} = $ENV{'RULE_INSTRUMENTOR'} || "$ENV{'LDV_HOME'}/bin/rule-instrumentor.pl" || 'rule-instrumentor.pl';

=back

=cut

sub usage
{
	my $msg=shift;
	return pod2usage(-msg => $msg, -verbose => 99, -sections=>'SYNOPSIS|COMMAND LINE OPTIONS|ENVIRONMENT VARIABLES');
}

# Determine mode
my $mode;
my @inline_args = ();
if (grep {m/^inline$/} @ARGV){
	$mode = 'inline';
	# Cut last portion of ARGV into a separate array
	my ($index) = grep { $ARGV[$_] eq 'inline' } 0..$#ARGV;
	@inline_args = @ARGV[($index+1)..$#ARGV];
	@ARGV = @ARGV[0..$index-1];
}else{
	$mode = 'cmdfile';
}

GetOptions(%optionSpecs) or usage("Unrecognized options!");

# Do options tweaking (that doesn't require any semantical checking)

# Compact rule models
$config->{properties} = [split (/,/,join(',',(@{$config->{property}},@{$config->{properties}})))];


# INLINE mode preparation

use File::Path qw(mkpath);
# If we're in inline mode, we should create appropriate cmdfile in the working dir and use it as such.
if ($mode eq 'inline'){
	# First we parse options
	my @args = @inline_args;
	while (@args){
		my $len = scalar @args;
		@args = $_->(@args) for values %inline_handlers;
		# If we haven't processed anything, then something's wrong here.
		usage("Specify inline mode modifier at the beginning please") if $len eq scalar @args;
	}
	# Allocate file for "commands"
	my $CMDFILE;
	mkpath($config->{work_dir});
	my $cmdfile_name = "$config->{work_dir}/generated_cmdfile.xml";
	open $CMDFILE, ">", $cmdfile_name or die;
	my $streamT = XML::Twig::Elt->new('cmdstream');
	my $id = 1;	#ID with which entities are tagged
	my @outfiles = ();	# dummy o-files that will be created for input files.

	# Check if we verify default property (assert()).  If it's the case, we must include a special header file and tweak properties array.
	my $defprop = !@{$config->{properties}};

	# Create basic XML entry for compilation of each C file.
	for my $file (@{$config->{inl_files}}){
		my $ccT = XML::Twig::Elt->new('cc',{id=>$id++});
		# Add option tags
		XML::Twig::Elt->new('opt',{},$_)->paste(last_child => $ccT) for @{$config->{inl_options}};

		# Add input-output tags
		XML::Twig::Elt->new('in',{},$file)->paste($ccT);
		my $outfile = $file; $outfile =~ s/(.*)\.(.*)$/$1.o/;
		XML::Twig::Elt->new('out',{},$outfile)->paste($ccT);
		XML::Twig::Elt->new('cwd',{},getcwd())->paste($ccT);

		push @outfiles, $outfile;

		# Add default-property header
		if ($defprop){
			XML::Twig::Elt->new('opt',{},'-include')->paste(last_child => $ccT);
			XML::Twig::Elt->new('opt',{},'engine-blast.h')->paste(last_child => $ccT);
		}

		$ccT->paste(last_child => $streamT);
	}

	# Create a dummy "link" command.
	my $ldT = XML::Twig::Elt->new('ld',{id=>$id++});
	XML::Twig::Elt->new('in',{},$_)->paste($ldT) for @outfiles;
	XML::Twig::Elt->new('out',{check=>'true'},'link.exe')->paste($ldT);
	XML::Twig::Elt->new('cwd',{},getcwd())->paste($ldT);
	push @{$config->{inl_entries}},'main' unless @{$config->{inl_entries}};
	XML::Twig::Elt->new('main',{},$_)->paste($ldT) for @{$config->{inl_entries}};
	$ldT->paste(last_child=>$streamT);

	# Paste basedir
	XML::Twig::Elt->new('basedir',{},"./")->paste($streamT);

	# Write XML to the file and close it
	$streamT->print($CMDFILE,'indented');
	close $CMDFILE or die;

	#Prepare usual DSCV options and proceed to the rest of the script
	$config->{cmdfile}=$cmdfile_name;
	$config->{properties}=['BZ_1'] if $defprop;
}

# Sanity check

$config->{cmdfile} or usage("Work without cmdfile is not supported!\n");
$config->{work_dir} or usage("WORK_DIR is not specified!\n");
unless (scalar @{$config->{properties}}){
	usage("You should specify at least one property to verify!  Did you forget about it?\n");
}

# Prepare working dir
mkpath ($config->{work_dir});


use LDV::Utils;
LDV::Utils::set_verbosity($config->{verbosity});
LDV::Utils::push_instrument('dscv');


# Actual work.

# Create basic directory structure
my $dscv_base_dir = "$config->{work_dir}/dscv";
mkpath($dscv_base_dir);
my $dscv_tmp_dir = "$config->{work_dir}/tmp/dscv";
mkpath($dscv_tmp_dir);

# Prepare running environment
my $shared_dir = $config->{dscv_dir};
my $rcv_frontends_dir = "$shared_dir/rcv";

# Prepare more sanity checks
use DSCV::Sanity;
my $sanity = DSCV::Sanity->new($dscv_base_dir);
# Check how many times blast was run.  It's <number of rule-models>*<number of mains>
my $expected_blast_runs = 0;
my $rule_instr_mains = 0;

# Send cmdfile to Instrumentor for each rule.

use DSCV::RCV::Utils;
use XML::Twig;

# For now we just pass the whole file to Instrumentor
# This is just a simple check that XML is correct, and to perform sanity checks
my $process_input = XML::Twig->new( twig_handlers => { cc => \&execute_cmd, ld=>\&execute_cmd, basedir=>\&get_driver_dir });

sub execute_cmd
{
	my ($twig, $cmdT) = @_;
	# Sanity check
	if ($cmdT->tag eq 'ld') {
		$expected_blast_runs += scalar $cmdT->children("main");
	}
}
my $driver_dir = undef;
sub get_driver_dir
{
	my $bdT = $_[1];
	$driver_dir = $bdT->text();
}
$process_input->parsefile($config->{cmdfile});

# Sanity check for blast runs
$expected_blast_runs *= scalar @{$config->{properties}};
vsay ('DEBUG',"Expecting $expected_blast_runs runs of RCV backend.\n");

# Function that copies driver
use File::Copy::Recursive qw(dircopy);
my $copy_driver = sub
{
	my $to = shift or die;
	defined $driver_dir or die;
	dircopy($driver_dir,$to) or die $!;
};

$" = ' ';	# For error reporting

# Prepare working dirs

my $out_cmd_dir = "$dscv_base_dir/cmdfiles";
mkpath ($out_cmd_dir);
my $for_rcv_dir = "$dscv_base_dir/cmdfiles/rcv";
mkpath ($for_rcv_dir);

my $ri_basedir = "$dscv_base_dir/ri";
mkpath ($ri_basedir);

# Get list of properties to check
my @properties = @{$config->{properties}};

for my $property (@properties){
	# make outcmdfile
	my $outfile = "$out_cmd_dir/cmd$property.xml";
	# Prepare directory
	my $ri_basedir_for_rule;
	if ($mode ne 'inline'){
		$ri_basedir_for_rule = "$ri_basedir/$property";
		mkpath($ri_basedir_for_rule);
		# Copy driver
		$copy_driver->($ri_basedir_for_rule);
	}else{
		$ri_basedir_for_rule = './'
	}

	my @rule_instr_args = ($config->{rule_ins},
		"--basedir=$ri_basedir_for_rule",
		"--rule-model=$property",
		"--cmdfile=$config->{cmdfile}",
		"--cmdfile-out=$outfile"
	);
	vsay (10,"Calling rule_instrumenter for rule model $property...\n");
	vsay (20,@rule_instr_args,"\n");
	system @rule_instr_args and die "INTEGRATION ERROR.  Cmdline:  @rule_instr_args";
	#system "cp $config->{cmdfile} $outfile";
	# Call C verifier

	# Understand what C verfifier to call.
	# For now, just for integration purposes, we assume that the first verifier found is what we need.
	my $get_verifier_handler = sub{
		my $dir = shift or die;
		return sub{
			my ($twig, $cmdT_) = @_;
			my $cmdT = $cmdT_->copy();
			my $id = $cmdT->att('id');
			# Get verifier from command and override it if necessary
			my $verifier = $config->{verifier_override} || $cmdT->first_child_text('engine') or die "Command $id is without <engine> specification, and --verifier option is not set";
			if (defined $cmdT->first_child('engine')){
				$cmdT->first_child('engine')->set_text($verifier);
			}else{
				XML::Twig::Elt->new('engine',{},$verifier)->paste($cmdT);
			}

			# Sanity check
			if ($cmdT->tag eq 'ld') {
				$rule_instr_mains += scalar $cmdT->children("main");
			}

			# Enwrap tag into <cmdstream> and add <basedir>
			my $streamT = XML::Twig::Elt->new("cmdstream");
			$cmdT->paste($streamT);
			# WARNING: It's important to put <basedir> tag before anything else.
			XML::Twig::Elt->new("basedir",{},$ri_basedir_for_rule)->paste($streamT);
			# Print tag to temporary file
			my $cmdfile = "$dir/model$property-$verifier-$id.xml";
			my $tmp_FH; open $tmp_FH,">",$cmdfile or die "Couldn't create temporary file for RCV's command!";
			$streamT->print($tmp_FH,'indented');
			close $tmp_FH;

			# Run RCV
			my @rcv_args = ("$rcv_frontends_dir/$verifier",
				"--cmdfile=$cmdfile",
				"--workdir=$dir",
				"--sanity-dir=$dscv_base_dir",
			);
			vsay ('NORMAL',"Calling RCV $verifier backend for @{[$cmdT->tag]} command $id...\n");
			vsay (20, "@rcv_args\n");
			system @rcv_args and die "INTEGRATION ERROR.  Cmdline:  @rcv_args";
		};
	};
	my $verifier_dir = "$for_rcv_dir/$property";
	mkpath($verifier_dir);
	my $verify_Twig = XML::Twig->new( twig_handlers => { cc => $get_verifier_handler->($verifier_dir), ld=>$get_verifier_handler->($verifier_dir) });

	$verify_Twig->parsefile($outfile);

	# TODO: parallelize

	# Now we concatenate all reports into one file and pass that file to rule-instrumenter for it to tune that big report.
	my $before_ri_rep_name = "$verifier_dir/report.xml";
	my $after_ri_rep_name = "$verifier_dir/report_after_ri.xml";
	my $BIG_REPORT; open $BIG_REPORT, ">", $before_ri_rep_name or die;

	my $bigRepT = XML::Twig::Elt->new("reports");

	my $cat_rep=sub{
		my ($report_file) = @_;
		XML::Twig->new(
			twig_roots=> {'reports' => sub {
				my ($twig,$repT) = @_;
				local $_;
				$_->copy->paste($bigRepT) for $repT->children;
			}}
		)->parsefile($report_file);
	};
	DSCV::RCV::Utils::foreach_report($verifier_dir,$cat_rep);

	$bigRepT->print($BIG_REPORT,'indented');
	close ($BIG_REPORT);

	# Now feed that BIG_REPORT to rule-instrumenter
	my @rule_instr_report = ($config->{rule_ins},
		"--basedir=$ri_basedir_for_rule",
		"--rule-model=$property",
		"--report=$before_ri_rep_name",
		"--report-out=$after_ri_rep_name"
	);
	vsay ('NORMAL',"Calling rule-instrumenter to fix up report for rule $property...\n");
	vsay (20, "@rule_instr_report\n");
	# TEMPORAL: just show the report
	system ("cat",$before_ri_rep_name) and die "INTEGRATION ERROR.  Cmdline:  @rule_instr_report";
	#system @rule_instr_report and die "INTEGRATION ERROR.  Cmdline:  @rule_instr_report";
}

# Perform final sanity check

my $blast_runs = $sanity->get('blast_calls') || 0;

if ($blast_runs < $expected_blast_runs) {
	vsay ("WARNING", "SANITY CHECK FAILED: BLAST was run $blast_runs times, but was expected to run $expected_blast_runs times.  Check if rule-instrumenter worked correctly\n");
}



=head1 DOCUMENTATION FOR DEVELOPERS

=cut

=head1 AUTHORS

The DSCV component was implemented by

Pavel Shved L<shved@ispras.ru>, 2010

ISP RAS L<http://ispras.ru/>, 2010


