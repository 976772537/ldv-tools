#!/usr/bin/perl
#=============================================
=head1 NAME

dscv - verify C program against one or several properties from a property database.

DSCV stands for B<Domain-Specific C Verifier>.  This is a working title.

=head1 SYNOPSIS

Compilation commands must be passed to the tool (all at once or sequentially), as well as a list of properties, and working directory. 

DSCV supports both cmdline interface (when a file with build commands is supplied) and direct interface (when files to verify are directly passed on command line).

If there's no argument named "inline", C<dscv> runs in cmdfile mode:

	dscv --cmdfile=commands.xml --rule-models=0032a,0039

Otherwise, DSCV runs in an inline mode:

	dscv --rcv-verifier=blast inline options -I include/ files file1.c file2.c

=head1 DESCRIPTION

TODO

=cut

use strict;

=head1 COMMAND LINE OPTIONS

=over 8

=cut

use Pod::Usage;
use Getopt::Long;

# Configuration structure
my $config={
	dir=>'./',
};

my %optionSpecs = ();

=item B<--cmdfile>

File with build commands.  The format is standard for LDV project.  Must be specified, at the current state of art.

=cut
$optionSpecs{'cmdfile=s'} = \$config->{cmdfile};

=item B<--rule-model=model_id>, B<--rule-models=model_id,model_id,...>

Properties to check.  They are looked for in property datbase.

=cut
$config->{property} = [];
$config->{properties} = [];
$optionSpecs{'rule-model=s@'} = \$config->{property};
$optionSpecs{'rule-models=s@'} = \$config->{properties};

=item B<--report-out>=report.xml

Outfile to print comprehensive report about all rules to.

=cut
$optionSpecs{'report-out=s'} = \$config->{report};

=item B<--rcv-verifier=backend>

Overrides the reachability C verifier passed by rule instrumentor.

=cut
$config->{verifier_override} = {} unless exists $config->{verifier_override};
$optionSpecs{'rcv-verifier=s'} = \$config->{verifier_override}->{rcv};

=item B<--no-aspect>

B<ONLY inline mode!>  Turns off aspectator.  Ignored if some rule models are specified.

=cut
$config->{inline_aspect} = 1;
$optionSpecs{'aspect!'} = \$config->{inline_aspect};

=item B<--force>

Runs all the toolset even if no entry points were specified in the input cmdfile.  By default BLAST skips all checks and doesn't run Rule Instrumentor and RCV in such case.

=cut
$config->{force} = '';
$optionSpecs{'force'} = \$config->{force};


=back

=cut
my %inline_handlers = ();
sub is_handler_keyword
{
	my $x = shift;
	local $_;
	# undef is thought of as a keyword (since it terminates the last sequence)
	return (!defined $x) || (grep {$_ eq $x} keys %inline_handlers);
}
# Create subroutine that, if at the beginning of input array there is a keyword, reads keyword-related words into $$target array; up to the next keyword otto the end of the array
sub make_handler
{
	my ($keyword, $target) = @_;
	$$target ||= [];
	return sub{
		return () unless @_;
		return @_ if $_[0] ne $keyword;
		shift;	#remove keyword
		my $f = shift;
		while (!is_handler_keyword($f)){
			push @$$target, $f;
			$f = shift;
		}
		return () unless defined $f;
		return ($f,@_);
	};
};


=pod
Inline mode options

=over 8

=item B<files> [list of files]

In inline mode, specifies the list of files that will be verified as if they were linked together.

=cut
$inline_handlers{'files'}=make_handler('files',\$config->{inl_files});

=item B<options> [list of GCC options]

In inline mode, specifies the list of GCC options that will be passsed to compiler and/or preprocessor

=cut
$inline_handlers{'options'}=make_handler('options',\$config->{inl_options});
=item B<option> [list of GCC options]

In inline mode, specifies the list of entry points to check.  If omitted, only one entry point, C<main>, is checked.

=cut
$inline_handlers{'entries'}=make_handler('entries',\$config->{inl_entries});

=back

=head1 ENVIRONMENT VARIABLES

=over 8

=cut

=item B<LDV_RULE_DB>

Rule database address.  It is interpreted by rule interpreter.  Also, the rule database should contain installing script, C<install> that prepares an instance of rule database for Rule Instrumentator to work.

=cut
$config->{rule_db_dir} = $ENV{'LDV_RULE_DB'};

=item B<WORK_DIR>

Working directory for a current instance of LDV scripts.  Unless specified, a current working dir is taken as working.

=cut
use Cwd;
$config->{work_dir} = $ENV{'WORK_DIR'};

=item B<DSCV_HOME>

Base directory, into which DSCV-related scripts and backends are installed.  Set automatically, but may be overridden.

=cut
use FindBin;
BEGIN {
	$ENV{'DSCV_HOME'} ||= "$FindBin::Bin/..";
	$ENV{'LDV_HOME'} ||= "$FindBin::Bin/..";
}
$config->{dscv_dir} = "$ENV{'DSCV_HOME'}/dscv";

BEGIN {
	# Add the lib directory to the @INC to be able to include local modules.
	push @INC,"$ENV{'LDV_HOME'}/shared/perl";
}

=item B<LDV_DEBUG>, B<DSCV_DEBUG>

Level of verbosity, ranging from 0 (silent) to 100 (trace).  Default is 10.  B<DSCV_DEBUG> takes precedence over B<LDV_DEBUG>.

=cut
$config->{verbosity} = $ENV{'DSCV_DEBUG'} || $ENV{'LDV_DEBUG'};
$config->{verbosity} = 10 unless defined $config->{verbosity};

=item B<RCV_VERIFIER>

Reachability C verification tool used to checking all models, regardless of what is specified by Rule-instrumentor.  May be overridden by C<--verifier> option.

=cut
$config->{verifier_override}->{rcv} = $ENV{'RCV_VERIFIER'};


=item B<RULE_INSTRUMENTOR>

Specify custom rule instrumentor.  Unless specified, the program is deduced from C<DSCV_HOME> environment or taken from path.

=cut
$config->{rule_ins} = $ENV{'RULE_INSTRUMENTOR'} || "$ENV{'LDV_HOME'}/bin/rule-instrumentor.pl" || 'rule-instrumentor.pl';

=item B<RI_CACHE>

Cache directory for Rule Instrumentor.  When compiling large projects with many repeatedly checked files (if they're re-used among several verification tasks), we might want to cache these files after they're preprocessed with rule instrumentor.  If you specify folder in this variable, it will be used as cache.

=cut
$config->{ri_cache} = $ENV{'RI_CACHE'};


=item B<VERIFIER_OVERRIDE>

Overrides the verifier returned by the Rule Instrumentor.  C<--verifier> option takes precedence.

=cut
$config->{verifier_override_env} = $ENV{'VERIFIER_OVERRIDE'};


=back

=cut
$config->{verifier_override_env} = $ENV{'VERIFIER_OVERRIDE'};

$config->{timestats} = $ENV{'TIMESTATS'} || "$ENV{'LDV_HOME'}/shared/sh/timeout" || 'timeout';

sub usage
{
	my $msg=shift;
	return pod2usage(-msg => $msg, -verbose => 99, -sections=>'SYNOPSIS|COMMAND LINE OPTIONS|ENVIRONMENT VARIABLES');
}

# Determine mode
my $mode;
my @inline_args = ();
if (grep {m/^inline$/} @ARGV){
	$mode = 'inline';
	# Cut last portion of ARGV into a separate array
	my ($index) = grep { $ARGV[$_] eq 'inline' } 0..$#ARGV;
	@inline_args = @ARGV[($index+1)..$#ARGV];
	@ARGV = @ARGV[0..$index-1];
}else{
	$mode = 'cmdfile';
}

GetOptions(%optionSpecs) or usage("Unrecognized options!");

# Do options tweaking (that doesn't require any semantical checking)

# Compact rule models
$config->{properties} = [split (/,/,join(',',(@{$config->{property}},@{$config->{properties}})))];


# INLINE mode preparation

use File::Path qw(mkpath rmtree);
# If we're in inline mode, we should create appropriate cmdfile in the working dir and use it as such.
if ($mode eq 'inline'){
	# First we parse options
	my @args = @inline_args;
	while (@args){
		my $len = scalar @args;
		@args = $_->(@args) for values %inline_handlers;
		# If we haven't processed anything, then something's wrong here.
		usage("Specify inline mode modifier at the beginning please") if $len eq scalar @args;
	}
	# Then we generate workdir
	$config->{work_dir} = "verify-".join('-',@{$config->{inl_files}});
	$ENV{'WORK_DIR'} = $config->{work_dir};
	rmtree($config->{work_dir});

	# Allocate file for "commands"
	my $CMDFILE;
	mkpath($config->{work_dir});
	my $cmdfile_name = "$config->{work_dir}/generated_cmdfile.xml";
	open $CMDFILE, ">", $cmdfile_name or die;
	my $streamT = XML::Twig::Elt->new('cmdstream');
	my $id = 1;	#ID with which entities are tagged
	my @outfiles = ();	# dummy o-files that will be created for input files.

	# Check if we verify default property (assert()).  If it's the case, we must include a special header file and tweak properties array.
	my $defprop = !@{$config->{properties}};

	# Create basic XML entry for compilation of each C file.
	for my $file (@{$config->{inl_files}}){
		my $ccT = XML::Twig::Elt->new('cc',{id=>$id++});
		# Add option tags
		XML::Twig::Elt->new('opt',{},$_)->paste(last_child => $ccT) for @{$config->{inl_options}};

		# Add input-output tags
		XML::Twig::Elt->new('in',{},$file)->paste($ccT);
		my $outfile = $file; $outfile =~ s/(.*)\.(.*)$/$1.o/;
		XML::Twig::Elt->new('out',{},$outfile)->paste($ccT);
		XML::Twig::Elt->new('cwd',{},getcwd())->paste($ccT);

		push @outfiles, $outfile;

		# Add default-property header
		if ($defprop){
			XML::Twig::Elt->new('opt',{},'-include')->paste(last_child => $ccT);
			XML::Twig::Elt->new('opt',{},'engine-blast.h')->paste(last_child => $ccT);
		}

		$ccT->paste(last_child => $streamT);
	}

	# Create a dummy "link" command.
	my $ldT = XML::Twig::Elt->new('ld',{id=>$id++});
	XML::Twig::Elt->new('in',{},$_)->paste($ldT) for @outfiles;
	XML::Twig::Elt->new('out',{check=>'true'},'link.exe')->paste($ldT);
	XML::Twig::Elt->new('cwd',{},getcwd())->paste($ldT);
	push @{$config->{inl_entries}},'main' unless @{$config->{inl_entries}};
	XML::Twig::Elt->new('main',{},$_)->paste($ldT) for @{$config->{inl_entries}};
	$ldT->paste(last_child=>$streamT);

	# Paste basedir
	XML::Twig::Elt->new('basedir',{},"./")->paste($streamT);

	# Write XML to the file and close it
	$streamT->print($CMDFILE,'indented');
	close $CMDFILE or die;

	#Prepare usual DSCV options and proceed to the rest of the script
	$config->{cmdfile}=$cmdfile_name;
	if ($defprop){
		my $default_rule_model = $config->{inline_aspect}?'BZ_1':'BZ_2';
		$config->{properties}=[$default_rule_model];
	}
}

# Sanity check

$config->{cmdfile} or usage("Work without cmdfile is not supported!\n");
$config->{work_dir} or usage("WORK_DIR is not specified!\n");
unless (scalar @{$config->{properties}}){
	usage("You should specify at least one property to verify!  Did you forget about it?\n");
}

# Prepare working dir
mkpath ($config->{work_dir});


use LDV::Utils;
LDV::Utils::set_verbosity($config->{verbosity});
LDV::Utils::push_instrument('dscv');


# Actual work.

# Create basic directory structure
my $dscv_base_dir = "$config->{work_dir}/dscv";
mkpath($dscv_base_dir);
my $dscv_tmp_dir = "$config->{work_dir}/tmp/dscv";
mkpath($dscv_tmp_dir);

$config->{report} ||= "$dscv_base_dir/report.xml";

# Prepare running environment
my $shared_dir = $config->{dscv_dir};
my $rcv_frontends_dir = "$shared_dir/rcv";

# Prepare more sanity checks
use DSCV::Sanity;
my $sanity = DSCV::Sanity->new($dscv_base_dir);
# Check how many times blast was run.  It's <number of rule-models>*<number of mains>
my $expected_blast_runs = 0;
my $rule_instr_mains = 0;

# Send cmdfile to Instrumentor for each rule.

use DSCV::RCV::Utils;
use XML::Twig;

# For now we just pass the whole file to Instrumentor
# This is just a simple check that XML is correct, and to perform sanity checks
my $process_input = XML::Twig->new( twig_handlers => { cc => \&execute_cmd, ld=>\&execute_cmd, basedir=>\&get_driver_dir });

sub execute_cmd
{
	my ($twig, $cmdT) = @_;
	# Sanity check
	if ($cmdT->tag eq 'ld') {
		$expected_blast_runs += scalar $cmdT->children("main");
	}
}
my $driver_dir = undef;
sub get_driver_dir
{
	my $bdT = $_[1];
	$driver_dir = $bdT->text();
}
$process_input->parsefile($config->{cmdfile});

# Sanity check for blast runs
$expected_blast_runs *= scalar @{$config->{properties}};
vsay ('DEBUG',"Expecting $expected_blast_runs runs of RCV backend.\n");

# Now, if we don't expect RCV to be run, we just skip all the checking!  It takes considerable time: copying and building driver, running Rule Instrumentor, running RCV's just to get information that no runs was actually performed.
if ($expected_blast_runs == 0 && !$config->{force}){

	vsay 10,"Nothing will be run (no mains!).  Printing final report...\n";

	my $big_reportT = XML::Twig::Elt->new("reports");

	# Walk through cmdfile and build the report according to it
	sub fake_report_about_command
	{
		my ($twig,$cmdT) = @_;
		# For this command, find all entities that refer to it and print them to outfile
		my $id = $cmdT->id;
		my $name = $cmdT->tag;

		# Let's create new command tag
		my $copyT = $cmdT->copy();
		# Replace 'id' with 'ref'
		$copyT->set_att('ref'=>$copyT->att('id'));
		$copyT->del_att('id');
		if ($name eq 'cc'){
			# Nice and shiny bogus OK report
			# This adds RI's info, not DSCV's (yes, I know about the name)
			add_dscv_info($copyT,'OK',"RI wasnt even run--no mains anyway",'rule-instrumentor');
			# This adds DSCV's
			add_dscv_info($copyT,'OK',"DSCV wasnt even run--no mains anyway");
		}elsif ($name eq 'ld'){
			# RI is not necessary for DSCV.  Moreover, it will make ldv-upload fail with trace validation error.
			# DSCV's failure report
			add_dscv_info($copyT,'FAILED','No entry points specified');
		}else {
			vsay ('TRACE',"Encountered tag $name, skipping...\n");
		}
		$copyT->paste(last_child=>$big_reportT);
	}
	XML::Twig->new( twig_roots=> {
		'cc'=>\&fake_report_about_command,
		'ld'=>\&fake_report_about_command,
	})->parsefile($config->{cmdfile});

	my $BIG_REPORT; open $BIG_REPORT, ">", $config->{report} or die;
	$big_reportT->print($BIG_REPORT,'indented');
	close $BIG_REPORT;

	vsay 20,"Final report is written to $config->{report}\n";

	# Leave
	exit 0;
}

# Function that copies driver
use File::Copy::Recursive qw(dircopy);
my $copy_driver = sub
{
	my $to = shift or die;
	defined $driver_dir or die;
	dircopy($driver_dir,$to) or die $!;
};

$" = ' ';	# For error reporting

# Prepare working dirs

my $out_cmd_dir = "$dscv_base_dir/cmdfiles";
mkpath ($out_cmd_dir);
my $for_rcv_dir = "$dscv_base_dir/cmdfiles/rcv";
mkpath ($for_rcv_dir);

my $ri_basedir = "$dscv_base_dir/ri";
mkpath ($ri_basedir);

# Get list of properties to check
my @properties = @{$config->{properties}};

for my $property (@properties){
	# make outcmdfile
	my $outfile = "$out_cmd_dir/cmd$property.xml";
	# Prepare directory
	my $ri_basedir_for_rule;
	if ($mode ne 'inline'){
		$ri_basedir_for_rule = "$ri_basedir/$property";
		mkpath($ri_basedir_for_rule);
		# Copy driver
		$copy_driver->($ri_basedir_for_rule);
	}else{
		$ri_basedir_for_rule = './'
	}

	vsay ('NORMAL',"CMDFILE    : ".$config->{cmdfile}."\n");
	vsay ('NORMAL',"CMDFILE-OUT: ".$outfile."\n");
	vsay ('NORMAL',"BASEDIR: ".$ri_basedir_for_rule."\n");
	my @rule_instr_args = (
        #	$config->{timestats},
	#      	"--pattern=.*,ALL",
	#      	"--output=".$config->{work_dir}."/rule-instrumentor/$property/stats.xml",
		$config->{rule_ins},
		"--basedir=$ri_basedir_for_rule",
		"--rule-model=$property",
		"--cmdfile=$config->{cmdfile}",
		"--cmdfile-out=$outfile",
	);
	push @rule_instr_args, "--cache=$ENV{'RI_CACHE'}" if $ENV{'RI_CACHE'};
	vsay (10,"Calling rule_instrumenter for rule model $property...\n");
	vsay (20,@rule_instr_args,"\n");
	system @rule_instr_args and die "INTEGRATION ERROR.  Cmdline:  @rule_instr_args";
	#system "cp $config->{cmdfile} $outfile";
	# Call C verifier

	# Understand what C verfifier to call.
	# For now, just for integration purposes, we assume that the first verifier found is what we need.
	my $get_verifier_handler = sub{
		my $dir = shift or die;
		return sub{
			my ($twig, $cmdT_) = @_;
			my $cmdT = $cmdT_->copy();
			my $id = $cmdT->att('id');
			# Get verifier from command and override it if necessary
			# TODO: for now all our verifiers are Reachability C verifiers.  When more verifier classes will be added, more verifiers should be supplied here.
			my $verifier = $config->{verifier_override}->{rcv} || $cmdT->first_child_text('engine') or die "Command $id is without <engine> specification, and --rcv-verifier option is not set";
			if (defined $cmdT->first_child('engine')){
				$cmdT->first_child('engine')->set_text($verifier);
			}else{
				XML::Twig::Elt->new('engine',{},$verifier)->paste($cmdT);
			}

			# Sanity check
			if ($cmdT->tag eq 'ld') {
				$rule_instr_mains += scalar $cmdT->children("main");
			}

			# Enwrap tag into <cmdstream> and add <basedir>
			my $streamT = XML::Twig::Elt->new("cmdstream");
			$cmdT->paste($streamT);
			# WARNING: It's important to put <basedir> tag before anything else.
			XML::Twig::Elt->new("basedir",{},$ri_basedir_for_rule)->paste($streamT);
			# Print tag to temporary file
			my $cmdfile = "$dir/model$property-$verifier-$id.xml";
			my $tmp_FH; open $tmp_FH,">",$cmdfile or die "Couldn't create temporary file for RCV's command!";
			$streamT->print($tmp_FH,'indented');
			close $tmp_FH;
			# Run RCV
			my @rcv_args = (
				$config->{timestats},
				"--pattern=.*,ALL",
				"--output=$dir/stats.xml",
				"--reference=$id",
				"$rcv_frontends_dir/$verifier",
				"--cmdfile=$cmdfile",
				"--workdir=$dir",
				"--sanity-dir=$dscv_base_dir",
			);
			vsay ('NORMAL',"Calling RCV $verifier backend for @{[$cmdT->tag]} command $id...\n");
			vsay (20, "@rcv_args\n");
			system @rcv_args and die "INTEGRATION ERROR.  Cmdline:  @rcv_args";
		};
	};
	my $verifier_dir = "$for_rcv_dir/$property";
	mkpath($verifier_dir);
	my $verify_Twig = XML::Twig->new( twig_handlers => { cc => $get_verifier_handler->($verifier_dir), ld=>$get_verifier_handler->($verifier_dir) });

	$verify_Twig->parsefile($outfile);

	# TODO: parallelize

	# Now we concatenate all reports into one file and pass that file to rule-instrumenter for it to tune that big report.
	my $before_ri_rep_name = "$verifier_dir/report.xml";
	my $after_ri_rep_name = "$verifier_dir/report_after_ri.xml";
	my $BIG_REPORT; open $BIG_REPORT, ">", $before_ri_rep_name or die;

	my $bigRepT = XML::Twig::Elt->new("reports");

	my $cat_rep=sub{
		my ($report_file) = @_;
		XML::Twig->new(
			twig_roots=> {'reports' => sub {
				my ($twig,$repT) = @_;
				local $_;
				$_->copy->paste($bigRepT) for $repT->children;
			}}
		)->parsefile($report_file);
	};
	DSCV::RCV::Utils::foreach_report($verifier_dir,$cat_rep);

	$bigRepT->print($BIG_REPORT,'indented');
	close ($BIG_REPORT);

	# Now feed that BIG_REPORT to rule-instrumenter
	my @rule_instr_report = ($config->{rule_ins},
		"--basedir=$ri_basedir_for_rule",
		"--rule-model=$property",
		"--report=$before_ri_rep_name",
		"--report-out=$after_ri_rep_name"
	);
	vsay ('NORMAL',"Calling rule-instrumenter to fix up report for rule $property...\n");
	vsay (20, "@rule_instr_report\n");
	system @rule_instr_report and die "INTEGRATION ERROR.  Cmdline:  @rule_instr_report";
}

# Perform final sanity check
my $blast_runs = $sanity->get('blast_calls') || 0;

if ($blast_runs < $expected_blast_runs) {
	vsay ("WARNING", "SANITY CHECK FAILED: BLAST was run $blast_runs times, but was expected to run $expected_blast_runs times.  Check if rule-instrumenter worked correctly\n");
}


# Now we concatenate all reports after Rule instrumentor invocations into one file

# Load information from all RI reports into one XML tree (in memory)
my $reportsT = XML::Twig::Elt->new("reports");

for my $property (@properties){
	my $verifier_dir = "$for_rcv_dir/$property";
	my $after_ri_rep_name = "$verifier_dir/report_after_ri.xml";

	XML::Twig->new(
		twig_roots=> {'reports' => sub {
			my ($twig,$rule_repT) = @_;
			local $_;
			$_->copy->paste($reportsT) for $rule_repT->children;
		}}
	)->parsefile($after_ri_rep_name);
}

# Add <dscv> tag to the report
sub add_dscv_info
{
	my ($rep_entityT,$status_str,$descr,$name) = @_;

	my %timestats;
	my $rcv_tag = $rep_entityT->first_child('rcv');
	if ($rcv_tag) {
		foreach my $rcv_time ($rcv_tag->children('time')) {
			$timestats{$rcv_time->att('name')} = $rcv_time->text;
		}
	} 
	my $ri_tag = $rep_entityT->first_child('rule-instrumentor');
	if ($ri_tag) {
		foreach my $ri_time ($ri_tag->children('time')) {
			$timestats{$ri_time->att('name')} += $ri_time->text;
		}
	} 


	$name ||= 'dscv';
	$descr ||= '';

	# calculate dscv time as ALL=rcv ALL time + ri ALL time for this tag
	my $dscvT = XML::Twig::Elt->new($name);
	XML::Twig::Elt->new('status',{},$status_str)->paste(last_child=>$dscvT);
	#XML::Twig::Elt->new('time',{'note'=>'always zero for now :-('},'0')->paste(last_child=>$dscvT);
        foreach(keys %timestats) {
                my $time_elt = XML::Twig::Elt->new('time',$timestats{$_});
                $time_elt->set_att( name =>$_);
                $time_elt->paste(last_child=>$dscvT);
        } 
	XML::Twig::Elt->new('desc',{},$descr)->paste(last_child=>$dscvT);
	$dscvT->paste(last_child=>$rep_entityT);
}

my $big_reportT = XML::Twig::Elt->new("reports");

# Walk through cmdfile and build the report according to it
sub report_about_command
{
	my ($twig,$cmdT) = @_;
	# For this command, find all entities that refer to it and print them to outfile
	my $id = $cmdT->id;
	my $name = $cmdT->tag;

	my @reports = $reportsT->findnodes("$name\[\@ref=\"$id\"\]");

	if (@reports){
		for my $repT_ (@reports){
			my $repT = $repT_->copy();
			add_dscv_info($repT,'OK');
			$repT->paste(last_child=>$big_reportT);
		}
	}else{
		my $repT = XML::Twig::Elt->new($name,{'ref'=>$id});
		# Try to find out what happened
		# Was it because that main hasn't been specified?
		unless ($reportsT->findnodes("$name\[\@ref=\"$id\"\]/main")){
			add_dscv_info($repT,'FAILED','No entry points specified');
		}else{
			# If we don't know the reason, let's leave the field empty
			add_dscv_info($repT,'FAILED');
		}
		$repT->paste(last_child=>$big_reportT);
	}
}
XML::Twig->new( twig_roots=> {
	'cc'=>\&report_about_command,
	'ld'=>\&report_about_command,
})->parsefile($config->{cmdfile});

my $BIG_REPORT; open $BIG_REPORT, ">", $config->{report} or die;
$big_reportT->print($BIG_REPORT,'indented');
close $BIG_REPORT;

vsay 20,"Final report is written to $config->{report}\n";


=head1 DOCUMENTATION FOR DEVELOPERS

=cut

=head1 AUTHORS

The DSCV component was implemented by

Pavel Shved L<shved@ispras.ru>, 2010

ISP RAS L<http://ispras.ru/>, 2010


