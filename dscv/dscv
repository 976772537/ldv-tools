#!/usr/bin/perl
#=============================================
=head1 NAME

dscv - verify C program against one or several properties from a property database.

DSCV stands for B<Domain-Specific C Verifier>.  This is a working title.

=head1 SYNOPSIS

Compilation commands must be passed to the tool (all at once or sequentially), as well as a list of properties, and working directory. 

For now it only supports cmdfile interface.

	$ LDV_RULE_DB=/path/to/rule_db WORK_DIR=/path/to/workdir \
	    dscv --cmdfile=commands.xml --rules=0032a,0039

=head1 DESCRIPTION

TODO

=cut

use strict;

=head1 COMMAND LINE OPTIONS

=over 8

=cut

use Pod::Usage;
use Getopt::Long;

# Configuration structure
my $config={
	dir=>'./',
};

my %optionSpecs = ();

=item B<--cmdfile>

File with build commands.  The format is standard for LDV project.  Must be specified, at the current state of art.

=cut
$optionSpecs{'cmdfile=s'} = \$config->{cmdfile};

=item B<--rule-model=model_id>, B<--rule-models=model_id,model_id,...>

Properties to check.  They are looked for in property datbase.

=cut
$config->{property} = [];
$config->{properties} = [];
$optionSpecs{'rule-model=s@'} = \$config->{property};
$optionSpecs{'rule-models=s@'} = \$config->{properties};

=item B<--verifier=backend>

Overrides the verifier passed by rule instrumentor.

=cut
$optionSpecs{'verifier=s'} = \$config->{verifier_override};


=back

=head1 ENVIRONMENT VARIABLES

=over 8

=cut

=item B<LDV_RULE_DB>

Rule database address.  It is interpreted by rule interpreter.  Also, the rule database should contain installing script, C<install> that prepares an instance of rule database for Rule Instrumentator to work.

=cut
$config->{rule_db_dir} = $ENV{'LDV_RULE_DB'};

=item B<WORK_DIR>

Working directory for a current instance of LDV scripts.  Unless specified, a current working dir is taken as working.

=cut
use Cwd;
$config->{work_dir} = $ENV{'WORK_DIR'} || getcwd();

=item B<DSCV_HOME>

Base directory, into which DSCV-related scripts and backends are installed.  Set automatically, but may be overridden.

=cut
use FindBin;
BEGIN {
	$ENV{'DSCV_HOME'} ||= "$FindBin::Bin/..";
	$ENV{'LDV_HOME'} ||= "$FindBin::Bin/..";
}
$config->{dscv_dir} = "$ENV{'DSCV_HOME'}/dscv";

BEGIN {
	# Add the lib directory to the @INC to be able to include local modules.
	push @INC,"$ENV{'LDV_HOME'}/shared/perl";
}

=item B<LDV_DEBUG>, B<DSCV_DEBUG>

Level of verbosity, ranging from 0 (silent) to 100 (trace).  Default is 10.  B<DSCV_DEBUG> takes precedence over B<LDV_DEBUG>.

=cut
$config->{verbosity} = $ENV{'DSCV_DEBUG'} || $ENV{'LDV_DEBUG'} || 10;


=item B<RULE_INSTRUMENTOR>

Specify custom rule instrumentor.  Unless specified, the program is deduced from C<DSCV_HOME> environment or taken from path.

=cut
$config->{rule_ins} = $ENV{'RULE_INSTRUMENTOR'} || "$ENV{'LDV_HOME'}/bin/rule-instrumentor.pl" || 'rule-instrumentor.pl';

=back

=cut

sub usage
{
	my $msg=shift;
	return pod2usage(-msg => $msg, -verbose => 99, -sections=>'SYNOPSIS|COMMAND LINE OPTIONS|ENVIRONMENT VARIABLES');
}

GetOptions(%optionSpecs) or usage("Unrecognized options!");

# Sanity check

$config->{cmdfile} or usage("Work without cmdfile is not supported!\n");
$config->{work_dir} or usage("WORK_DIR is not specified!\n");
use File::Path qw(mkpath);
mkpath ($config->{work_dir});

$config->{properties} = [split (/,/,join(',',(@{$config->{property}},@{$config->{properties}})))];

unless (scalar @{$config->{properties}}){
	usage("You should specify at least one property to verify!  Did you forget about it?\n");
}


use LDV::Utils;
LDV::Utils::set_verbosity($config->{verbosity});
LDV::Utils::push_instrument('dscv');


# Actual work.

# Create basic directory structure
my $dscv_base_dir = "$config->{work_dir}/dscv";
mkpath($dscv_base_dir);
my $dscv_tmp_dir = "$config->{work_dir}/tmp/dscv";
mkpath($dscv_tmp_dir);

# Prepare running environment
my $shared_dir = $config->{dscv_dir};
my $rcv_frontends_dir = "$shared_dir/rcv";

# Prepare more sanity checks
use DSCV::Sanity;
my $sanity = DSCV::Sanity->new($dscv_base_dir);
# Check how many times blast was run.  It's <number of rule-models>*<number of mains>
my $expected_blast_runs = 0;
my $rule_instr_mains = 0;

# Send cmdfile to Instrumentor for each rule.

use XML::Twig;

# For now we just pass the whole file to Instrumentor
# This is just a simple check that XML is correct, and to perform sanity checks
my $process_input = XML::Twig->new( twig_handlers => { cc => \&execute_cmd, ld=>\&execute_cmd, basedir=>\&get_driver_dir });

sub execute_cmd
{
	my ($twig, $cmdT) = @_;
	# Sanity check
	if ($cmdT->tag eq 'ld') {
		$expected_blast_runs += scalar $cmdT->children("main");
	}
}
my $driver_dir = undef;
sub get_driver_dir
{
	my $bdT = $_[1];
	$driver_dir = $bdT->text();
}
$process_input->parsefile($config->{cmdfile});

# Sanity check for blast runs
$expected_blast_runs *= scalar @{$config->{properties}};
vsay ('DEBUG',"Expecting $expected_blast_runs runs of RCV backend.\n");

# Function that copies driver
use File::Copy::Recursive qw(dircopy);
my $copy_driver = sub
{
	my $to = shift or die;
	defined $driver_dir or die;
	dircopy($driver_dir,$to) or die $!;
};

$" = ' ';	# For error reporting

# Prepare working dirs

my $out_cmd_dir = "$dscv_base_dir/cmdfiles";
mkpath ($out_cmd_dir);
my $for_rcv_dir = "$dscv_base_dir/cmdfiles/rcv";
mkpath ($for_rcv_dir);

my $ri_basedir = "$dscv_base_dir/ri";
mkpath ($ri_basedir);


# Get list of properties to check
my @properties = @{$config->{properties}};

for my $property (@properties){
	# make outcmdfile
	my $outfile = "$out_cmd_dir/cmd$property.xml";
	# Prepare directory
	my $ri_basedir_for_rule = "$ri_basedir/$property";
	mkpath($ri_basedir_for_rule);
	# Copy driver
	$copy_driver->($ri_basedir_for_rule);

	my @rule_instr_args = ($config->{rule_ins},
		"--basedir=$ri_basedir_for_rule",
		"--rule-model=$property",
		"--cmdfile=$config->{cmdfile}",
		"--cmdfile-out=$outfile"
	);
	vsay (10,"Calling rule_instrumenter for rule model $property...\n");
	vsay (20,@rule_instr_args,"\n");
	system @rule_instr_args and die "INTEGRATION ERROR.  Cmdline:  @rule_instr_args";
	#system "cp $config->{cmdfile} $outfile";
	# Call C verifier

	# Understand what C verfifier to call.
	# For now, just for integration purposes, we assume that the first verifier found is what we need.
	my $get_verifier_handler = sub{
		my $dir = shift or die;
		return sub{
			my ($twig, $cmdT_) = @_;
			my $cmdT = $cmdT_->copy();
			my $id = $cmdT->att('id');
			# Get verifier from command and override it if necessary
			my $verifier = $config->{verifier_override} || $cmdT->first_child_text('engine') or die "Command $id is without <engine> specification, and --verifier option is not set";
			if (defined $cmdT->first_child('engine')){
				$cmdT->first_child('engine')->set_text($verifier);
			}else{
				XML::Twig::Elt->new('engine',{},$verifier)->paste($cmdT);
			}

			# Sanity check
			if ($cmdT->tag eq 'ld') {
				$rule_instr_mains += scalar $cmdT->children("main");
			}

			# Enwrap tag into <cmdstream> and add <basedir>
			my $streamT = XML::Twig::Elt->new("cmdstream");
			$cmdT->paste($streamT);
			# WARNING: It's important to put <basedir> tag before anything else.
			XML::Twig::Elt->new("basedir",{},$ri_basedir_for_rule)->paste($streamT);
			# Print tag to temporary file
			my $cmdfile = "$dir/model$property-$verifier-$id.xml";
			my $tmp_FH; open $tmp_FH,">",$cmdfile or die "Couldn't create temporary file for RCV's command!";
			$streamT->print($tmp_FH,'indented');
			close $tmp_FH;

			# Run RCV
			my @rcv_args = ("$rcv_frontends_dir/$verifier",
				"--cmdfile=$cmdfile",
				"--workdir=$dir",
				"--sanity-dir=$dscv_base_dir",
			);
			vsay ('NORMAL',"Calling RCV $verifier backend for @{[$cmdT->tag]} command $id...\n");
			vsay (20, "@rcv_args\n");
			system @rcv_args and die "INTEGRATION ERROR.  Cmdline:  @rcv_args";
		};
	};
	my $verifier_dir = "$for_rcv_dir/$property";
	mkpath($verifier_dir);
	my $verify_Twig = XML::Twig->new( twig_handlers => { cc => $get_verifier_handler->($verifier_dir), ld=>$get_verifier_handler->($verifier_dir) });

	$verify_Twig->parsefile($outfile);

	# TODO: parallelize
}

# Perform final sanity check

my $blast_runs = $sanity->get('blast_calls') || 0;

if ($blast_runs < $expected_blast_runs) {
	vsay ("WARNING", "SANITY CHECK FAILED: BLAST was run $blast_runs times, but was expected to run $expected_blast_runs times.  Check if rule-instrumenter worked correctly\n");
}



=head1 DOCUMENTATION FOR DEVELOPERS

=cut

=head1 AUTHORS

The DSCV component was implemented by

Pavel Shved L<shved@ispras.ru>, 2010

ISP RAS L<http://ispras.ru/>, 2010


