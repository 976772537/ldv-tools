#!/usr/bin/env ruby
#
# Watch for tasks to be completed in order
#

require 'fileutils'
require 'find'
require 'logger'

# Set up logging
$log = Logger.new(STDERR)
# NOTE: for compatibility we use different levels
levels = { 0 => Logger::FATAL, 4 => Logger::ERROR, 10 => Logger::WARN, 20 => Logger::INFO, 30 => Logger::DEBUG }
user_set_level = (ENV['LDV_DEBUG'] || '10').to_i;
$log.level = levels[levels.keys.select{|l| l <= user_set_level}.max]

# Process command arguments
#
# FIXME: for now this sample watcher only supports parallelization of RCV commands

command = ARGV.shift
arguments = ARGV
address = ENV['LDV_WATCHER_SRV'] or raise "Server address not found.  Please, specify LDV_WATCHER_SRV env var!"

# Main class
# It will be an interface (for now it's just a local implementation)
class Watcher

	attr_accessor :server_address

	def ensure_server_init
		unless File.directory? server_address
			['rcv'].each do |instr|
				instr_dir = File.join server_address,instr
				FileUtils.mkdir_p ['finished','queried','running','tasks'].map {|a| File.join instr_dir,a}
			end
		end
		@rcv_running = File.join server_address,'rcv','running'
		@rcv_queried = File.join server_address,'rcv','queried'
		@rcv_finished = File.join server_address,'rcv','finished'
	end

	# initialize control structures by the given server address
	def initialize(server_address)
		@server_address = server_address
		ensure_server_init
	end

	# Stop server
	def shutdown
		FileUtils.rm_r server_address
	end

	# Restart server: create the new state
	def restart(_ = [])
		shutdown
		ensure_server_init
	end

	def rcv_query_fname(key)
		rule_id, cmd_id, main_id = key
		query_fname = File.join server_address, 'rcv', 'queried', "query.rule-#{rule_id}.cmd-#{cmd_id}.main-#{main_id}"
		task_fname = File.join server_address, 'rcv', 'tasks', "query.rule-#{rule_id}.cmd-#{cmd_id}.main-#{main_id}.task"
		finished_fname = File.join server_address, 'rcv', 'finished', "query.rule-#{rule_id}.cmd-#{cmd_id}.main-#{main_id}"
		running_fname = File.join server_address, 'rcv', 'running', "query.rule-#{rule_id}.cmd-#{cmd_id}.main-#{main_id}"
		[query_fname, task_fname, running_fname, finished_fname]
	end

	def queue_rcv(args)
		rule_id, cmd_id, main_id, workdir, stuff = args[0..4]
		query_fname,task_fname,running_fname,finished_fname = rcv_query_fname([rule_id,cmd_id,main_id])
		# Ensure that file doesn't exist
		File.exists? query_fname and raise "The task is already in queue (#{query_fname})"
		$log.warn "Putting task credentials to: #{query_fname}."
		File.open(query_fname,'w') do |f|
			# write workdir to the file
			f.puts workdir
		end

		$log.warn "Copying task file to: #{task_fname} from #{stuff}"
		File.open(task_fname,'w') do |f|
			#...and write the rest of the supplied file there
			File.open(stuff,"r").each do |line|
				f.puts line
			end
		end

		# Now run RCV with task file supplied
		$log.warn "Forking process: #{['/home/pavel/tmp/ldv/dscv/rcv/blast',"--rawcmdfile=#{task_fname}"].join(" ")}..."
		rcv_pid = fork do
			# Spawn worker
			FileUtils.move(query_fname,running_fname)
			fork {Kernel.exec('/home/pavel/tmp/ldv/dscv/rcv/blast',"--rawcmdfile=#{task_fname}") }
			Process.waitall
			FileUtils.move(running_fname,finished_fname)
		end
		Process.detach rcv_pid
	end

	def wait_rcv(args)
		# This is not thread-safe, but in this prototype thread-safetyy while waiting is not very important
		$log.debug "Searching for files in #{@rcv_running} and #{@rcv_queried}"
		while ! (Dir["#{@rcv_running}/*","#{@rcv_queried}/*","#{@rcv_finished}/*"].empty?)
			$log.debug "Dirs are not empty"
			found_any = false
			waited_for = {}
			Find.find(@rcv_finished) do |file|
				$log.debug "Waited for #{file}"
				if file =~ /query.rule-([^.]*).cmd-([^.]*).main-([^.]*)/
					rule_id,cmd_id,main_id = $1,$2,$3
					# Read data
					waited_workdir = nil
					File.open(file,"r") { |f| waited_workdir = f.gets.chomp }
					# Add to out
					waited_for[ [rule_id,cmd_id,main_id] ] = { :workdir => waited_workdir }
					# Exit
					FileUtils.rm_f file
					found_any = true
					break
				end
			end
			if found_any
				waited_for.each { |k,v| $stdout.write "#{(k + [v[:workdir]]).join ","}\n" }
				exit 0
			else
				# Nothing found, sleep and repeat
				Kernel.sleep 1
			end
		end
		# Waited for all
		exit 5
	end

	# Add task to queue
	def queue(args)
		what = args.shift
		self.send("queue_#{what}",args)
	end

	# Wait and reap one task
	def wait(args)
		what = args.shift
		self.send("wait_#{what}",args)
	end

	def unpack(args)
		$log.warn "Fake unpack!"
	end
end

watcher = Watcher.new(address)

unless arguments.empty?
	watcher.send command, arguments
else
	watcher.send command
end

$log.close

