#!/usr/bin/perl -w

use XML::Twig;
use FindBin;

my $deg_home = "$FindBin::Bin";

# Xml nodes names.
my $xml_cmd_basedir = 'basedir';
my $xml_cmd_stream = 'cmdstream';
my $xml_cmd_attr_id = 'id';
my $xml_cmd_attr_check = 'check';
my $xml_cmd_entry_point = 'main';
my $xml_cmd_cc = 'cc';
my $xml_cmd_cwd = 'cwd';
my $xml_cmd_in = 'in';
my $xml_cmd_ld = 'ld';
my $xml_cmd_opt = 'opt';
my $xml_cmd_out = 'out';
my $xml_reports_cc = 'cc';
my $xml_reports = 'reports';
my $xml_reports_ld = 'ld';
my $xml_reports_attr_ref = 'ref';
my $xml_reports_verdict = 'verdict';

my $verdict_unknown = 'UNKNOWN';
my $verdict_ok = 'OK';

my $xml_instrument = 'build-cmd-extractor';
my $xml_build = 'build';
my $xml_instrument_status = 'status';
my $xml_instrument_time = 'time';
my $xml_instrument_desc = 'desc';

sub get_state;
#####################################################
# log options
#####################################################
my $psuffix="bce-reporter";
my $log_level=10;

my $report_out = "";
my $report_in = "";
my $stats_file = "";
my $cmdfile = "";

$state_file ="";
# 0. get options.
get_ldv_opts();
my $state_filename="$state_file.data";
# 0.1 Create state file name
# 1. read state file;
open(FIL,$state_filename); 
my @states = <FIL>; 
close(FIL);
my @astate = get_state();


my %cc_times;
my %average_times;
my $ld_counter = 0;

my @instruments = ('drv-env-gen','rcv','dscv','rule-instrumentor');


my $twig_handlers = {   "$xml_reports/$xml_cmd_cc"      => \&hxml_cmdstream_cc,
			"$xml_reports/$xml_cmd_ld"      => \&hxml_cmdstream_ld };
my $twig_inreport = new XML::Twig(TwigHandlers => $twig_handlers);
$twig_inreport->parsefile($report_in);


my $instrument = XML::Twig::Elt->new($xml_build);
XML::Twig::Elt->new($xml_instrument_desc,"")->paste($instrument);

if ( -f "$stats_file" ) {
	my %timestats;
        open(STATS_FILE, '<', "$stats_file") or die "Can't open file with time statistics: \"$stats_file\", $!";
        while(<STATS_FILE>) {
	        /^\s*<time\s+name="(.*)"\s*>\s*([0-9]*)\s*<\/time>/ or next;
        	$timestats{$1} += $2;
        }
        close STATS_FILE;
        foreach(keys %timestats) {
                my $time_elt = XML::Twig::Elt->new($xml_instrument_time,$timestats{$_});
                $time_elt->set_att( name =>$_);
                $time_elt->paste($instrument);
        }
} else {
        my $time_elt = XML::Twig::Elt->new($xml_instrument_time,0);
        $time_elt->set_att( name =>"ALL");
        $time_elt->paste($instrument);
};

XML::Twig::Elt->new($xml_instrument_status,"OK")->paste($instrument);
$outreport_root = $twig_inreport->root;
$instrument->paste('last_child',$outreport_root);



# set average time for all ld commands
my $croot=$twig_inreport->root;
my $children_build = $croot->first_child('build');

# calculate average build time
foreach ($children_build->children('time')) {
	if($ld_counter != 0) {
		$average_times->{'build'}->{$_->att('name')} = $_->text/$ld_counter;
	} else {
		$average_times->{'build'}->{$_->att('name')} = 0;
	}
}
my @childrens_ld = $croot->children('ld');
foreach my $entry(@childrens_ld) {
	my $build_fix_tag = XML::Twig::Elt->new('build');
	foreach my $build_time_fix_tag(keys %{$average_times->{'build'}}) {
		my $build_time = $average_times->{'build'}->{$build_time_fix_tag};
		my $build_time_tag = XML::Twig::Elt->new('time',"$build_time:$build_time:$build_time");
		$build_time_tag->set_att('name',$build_time_fix_tag);
		$build_time_tag->paste($build_fix_tag);
	}
	$build_fix_tag->paste($entry);
	foreach my $instrument(@instruments) {
	 	my $instrument_tag = $entry->first_child($instrument) or next;
	        foreach ($instrument_tag->children('time')) {
	         	$_->text =~ /([0-9]*):([0-9].*):([0-9].*)/;
			$average_times->{$instrument_tag->name}->{$_->att('name')} or next;
			$_->set_text("$1:$2:".($average_times->{$instrument_tag->name}->{$_->att('name')}/$ld_counter+$3));
			#$_->set_text("$2:".($average_times->{$instrument_tag->name}->{$_->att('name')}/$ld_counter+$3));
		}
	}
}

#my $instrument = XML::Twig::Elt->new($xml_build);
#XML::Twig::Elt->new($xml_instrument_desc,"")->paste($instrument);

#if ( -f "$stats_file" ) {
#	my %timestats;
#       open(STATS_FILE, '<', "$stats_file") or die "Can't open file with time statistics: \"$stats_file\", $!";
#        while(<STATS_FILE>) {
#	        /^\s*<time\s+name="(.*)"\s*>\s*([0-9]*)\s*<\/time>/ or next;
#        	$timestats{$1} += $2;
#        }
#        close STATS_FILE;
#        foreach(keys %timestats) {
#                my $time_elt = XML::Twig::Elt->new($xml_instrument_time,$timestats{$_});
#                $time_elt->set_att( name =>$_);
#                $time_elt->paste($instrument);
#        }
#} else {
#        my $time_elt = XML::Twig::Elt->new($xml_instrument_time,0);
#        $time_elt->set_att( name =>"ALL");
#        $time_elt->paste($instrument);
#};


#XML::Twig::Elt->new($xml_instrument_status,"OK")->paste($instrument);
#$outreport_root = $twig_inreport->root;
#$instrument->paste('last_child',$outreport_root);

$twig_inreport->set_xml_version('1.0');
$twig_inreport->set_pretty_print('indented');
$twig_inreport->print_to_file($report_out);


#####################################################
# twig  handlers
#####################################################
sub hxml_cmdstream_cc {
        my (undef, $entry) = @_; 
	my $model = $entry->att('model');
        foreach (@instruments) {
                my $instrumment_pattern = $entry->first_child($_) or next;
                local $_; 
                foreach ($instrumment_pattern->children('time')) {
			$average_times->{$instrumment_pattern->name}->{$_->att('name')} += $_->text;
                        $cc_times->{$model}->{$instrumment_pattern->name}->{$_->att('name')}->{'time'} += $_->text;
                }   
        } 
}

sub hxml_cmdstream_ld {
	$ld_counter++;
        my (undef, $entry) = @_;
	my $model = $entry->att('model');

        foreach my $instrument(@instruments) {
                my $instrument_tag = $entry->first_child($instrument) or next;
                foreach my $time_tag($instrument_tag->children('time')) {
			$time_tag->set_text($time_tag->text.':'.$time_tag->text.':'.$time_tag->text);
		}
	}

        foreach my $instrument(keys %{$cc_times->{$model}}) {
                my $instrument_tag = $entry->first_child($instrument) or next;
               foreach my $pattern(keys %{$cc_times->{$model}->{$instrument}}) {
                        # find time with attribute equals pattern
                        my $before = 0;
                        foreach ($instrument_tag->children('time')) {
                                $_->att('name') eq $pattern or next;
                                $before = 1;
				$_->text =~ /([0-9]*):([0-9]*):([0-9]*)/;
				$_->set_text($1.':'.($1+$cc_times->{$model}->{$instrument}->{$pattern}->{'time'}).":$1");
                        }   
                        $before == 0 or next;
                        my $newtime = XML::Twig::Elt->new('time','0:'.$cc_times->{$model}->{$instrument}->{$pattern}->{'time'}.":0");
                        $newtime->set_atts('name', $pattern);
                        $newtime->paste('last_child',$instrument_tag);
                }   
        } 
	$cc_times->{$model} = undef;
}	

sub get_state() {
        foreach my $state (@states) {
                if($state =~ m/^(\d+)$/) {
	                # time of work  
                        return ($1);
                }   
        }   
}

######################################################
# option test
######################################################
sub get_ldv_opts
{
	$log_level = $ENV{'LDV_DEBUG'};

	# get all options
	foreach $opt(@ARGV)
	{
		if($opt =~ s/--state-file=(.*)/$1/)
		{
			$state_file = $opt;
		}
		elsif($opt =~ s/--stats-file=(.*)/$1/)
		{
			$stats_file = $opt;
		}
		elsif($opt =~ s/--cmdfile=(.*)/$1/)
		{
			$cmdfile = $opt;
		}
		elsif($opt =~ s/--report-in=(.*)/$1/)
		{
			$report_in = $opt;
		}
		elsif($opt =~ s/--report-out=(.*)/$1/)
		{
			$report_out = $opt;
		}
		else
		{
			ldv_eprint("Unknown option:\"$opt\".");
			exit 1;
		}
	}
	# test all options
	if(!$state_file) {
		ldv_eprint("You must setup file with error state: \"--state-file\".");
		print_usage();
		exit 1;
	} elsif(! -f "$state_file.data" ) {

		ldv_wprint("Can not find file with state: \"$state_file.data\".");
	}
	if(!$stats_file) {
		ldv_eprint("You must setup input file with statistica in \"--stats-file\" option.");
		exit 1;
	} elsif(! -f $stats_file ) {
		ldv_eprint("Can not find stats file: \"$stats_file\".");
		exit 1;
	}
	if(!$cmdfile) {
		ldv_eprint("You must setup command stream file in \"--cmdfile\" option.");
		exit 1;
	} elsif(! -f $cmdfile ) {
		ldv_eprint("Can not find command stream file: \"$cmdfile\".");
		exit 1;
	}
	if(!$report_in) {
		ldv_eprint("You must setup input report file in option: \"--report-in\".");
		print_usage();
		exit 1;
	} elsif(! -f $report_in) {
		ldv_eprint("Can not find input report file: \"$report_in\".");
		print_usage();
		exit 1;
	}
	if(!$report_out) {
		ldv_eprint("You must setup output report file in option: \"--reoport-out\".");
		print_usage();
		exit 1;
	} elsif( -f $report_out) {
		ldv_eprint("Output report file already exists: \"$report_out\".");
		print_usage();
		exit 1;
	}
}

sub print_usage
{
	ldv_print("USAGE: $psuffix --report-out=reportfile --report-in=reportin --state-dir=statedir ");
}

#######################################################
# ldv print functions
#######################################################
sub ldv_print
{
	print "$psuffix: $_[0]\n";
}

sub ldv_eprint
{
	ldv_print "ERROR: $_[0]";
}

sub ldv_sprint
{
	if($log_level>=10) {
		ldv_print("$_[0]");
	}
}

sub ldv_iprint
{
	if($log_level>=20) {
		ldv_print("INFO: $_[0]");
	}
}

sub ldv_dprint
{
	if($log_level>=30) {
		ldv_print("DEBUG: $_[0]");
	}
}

sub ldv_tprint
{
	if($log_level>=40) {
		ldv_print("TRACE: $_[0]");
	}
}

sub ldv_aprint
{
	if($log_level==100) {
		ldv_print("$_[0]");
	}
}
