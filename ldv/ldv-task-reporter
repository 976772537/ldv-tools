#!/usr/bin/perl -w
#

my $instrumnet = 'ldv-task-reporter';

use FindBin;
BEGIN {
        $ENV{'LDV_HOME'} ||= "$FindBin::Bin/..";
        push @INC,"$ENV{'LDV_HOME'}/shared/perl";
	$LDV_ENVS_TARGET = $ENV{'LDV_ENVS_TARGET'} || " ";
}

sub usage{ print STDERR<<usage_ends;

Usage:
        $instrumnet -r reports-dir -f report-name -s state-file -o report-out

usage_ends
        die;
}

use Getopt::Long qw(:config require_order);

my $config = {
        'verbosity' => $ENV{'LDV_DEBUG'} || 'NORMAL',
        'error-trace-visualizer' => "$ENV{'LDV_HOME'}/bin/error-trace-visualizer.pl",
        'kernel-manager' => "$ENV{'LDV_HOME'}/ldv/ldv-kmanager",
};

GetOptions(
        'reports-dir|d=s'=>\$config->{'reports-dir'},
        'report-name|f=s'=>\$config->{'report-name'},
        'state-file|s=s'=>\$config->{'state-file'},
        'report-out|o=s'=>\$config->{'report-out'},
) or usage;

use LDV::Utils;
use File::Spec::Functions qw(splitpath catfile);
LDV::Utils::set_verbosity($config->{verbosity});
LDV::Utils::push_instrument($instrumnet);

###################################################
# subs
###################################################

sub get_states;
sub merge_reports;
sub search;
sub get_reports;
sub hxml_cmdstream;



###################################################
# main
###################################################

my @lstates = get_states($config);
merge_reports($config, @lstates);
exit;

use XML::Twig;
sub merge_reports {
	my ($config, @states) = @_;

	my $twig_inreport = XML::Twig->new();
	$twig_inreport->set_xml_version( '1.0');
	my $twig_inroot = XML::Twig::Elt->new('reports');
	$twig_inreport->set_root($twig_inroot);

	@reports=get_reports($config);
	foreach my $file (@reports) { 
		vsay 'DEBUG', "Process report from file: \"$file\".\n";
		my $twig_report = new XML::Twig();
		$twig_report->parsefile($file);
		my $twig_report_root=$twig_report->root;
		my @childrens = $twig_report_root->children();
		my @sections;
		local $_;
		foreach (@childrens) {
			$_->name =~ /cc|ld|build/ and hxml_cmdstream $_, $config, $file, @states;
			if($_->name =~ /build/) { 
				@sections = (@sections, $_) 
			} else {
				 @sections = ($_, @sections);
			}
			$_->name =~ /cc/ and @sections = (@sections, $_);
		}
		$_->move($twig_inroot) foreach @sections;
	};

	$twig_inreport->set_pretty_print('indented');
	$twig_inreport->print_to_file($config->{'report-out'});
	vsay 'NORMAL', "Report created successfully.\n";
}


#####################################################
# twig  handlers
#####################################################

sub hxml_cmdstream {
	my ($cmd, $config, $file, @states) = @_;
	my $state = get_state($file, @states);
	my $kernel = $state->{'env'};	
	$cmd->set_att('kernel'=>$kernel);
	my $verdict_section = $cmd->first_child('verdict');
	if($cmd->name eq 'ld' && $cmd->has_atts && $cmd->att('check') eq 'true') {
		vsay 'DEBUG', "Command have verdict: \"".$verdict_section->text."\"\n";
		if($verdict_section && $verdict_section->text eq 'UNSAFE') {
			my $model =$cmd->att('model');
			my $rcv_section = $cmd->first_child('rcv');
			my $verifier=$rcv_section->att('verifier');
			vsay 'DEBUG', "Verifier: \"$verifier\".\n";
			my $trace_section = $cmd->first_child('trace');
			my $trace = $trace_section->text;
			my $temp_file = $config->{'report-out'}.'.tmp';
			system('rm','-f',$temp_file);
			# call visualizer
			@etv_arg = ($config->{'error-trace-visualizer'},
					"--engine=$verifier",
					"--report=$trace",
					"--reqs-out=$temp_file");
			vsay 'TRACE', "Calling error-trace-visualizer: @etv_arg\n";
			system(@etv_arg) and die("Error trace visualizer failed\n");
			# read temp file
			open(FILT,$temp_file) or die"Can't open temp file $temp_file: $!";
			my @trace_files = <FILT>;
			close(FILT) or die"Can't close temp file $temp_file: $!";
			# Save list of files specific for this trace
			my %sources = ();
			foreach (@trace_files) {
				vsay 'TRACE', "Process trace file: $_\n";
				if(/$state->{'path'}\/+csd_deg_dscv\/+\d+\/+/) {
					my $brelpath = $_;
					$brelpath =~ s/$state->{'path'}\/+(csd_deg_dscv\/+)(\d+\/+.*)/$1$2/;
					my $relpath = $brelpath;
					$relpath =~ s/(.*)\/.*$/$1/;
					my $target_rel_path = "$kernel/$relpath";
					chomp($target_rel_path);
					my $rel_path_full="$config->{'report-out'}.source/$target_rel_path";

					system('mkdir','-p',$rel_path_full) and die("Can't create dir: \"$rel_path_full\": $!");
					chomp($_);
					system('cp',$_,$rel_path_full) and die("Can't copy file:\"$_\" to \"$rel_path_full\": $!");
					# Save relative file to the list
					my (undef,undef,$copied_file) = splitpath($_);
					my $r = File::Spec->catfile($target_rel_path,$copied_file);
					$sources{$r} = 1;
				} else {
					$relpath = $_;
					if(/$state->{'path'}\/+ldv_tempdir\/+driver\/+(.*)/) {
						$relpath =~ s/$state->{'path'}\/+ldv_tempdir\/+driver\/+(.*)/$1/;
						$relpath =~ s/(.*)\/.*$/$1/;
					} else {
						$relpath =~ s/.*$kernel//;
						$relpath =~ s/(.*\/+).*$/$1/;
					}
					my $target_rel_path="$kernel/$relpath";
					chomp($target_rel_path);
					my $rel_path_full="$config->{'report-out'}.source/$target_rel_path";
					system('mkdir','-p',$rel_path_full) and die "Can't create dir:\"$rel_path_full\": $!";
					$path_to_kernel=`LDV_ENVS_TARGET=$LDV_ENVS_TARGET $config->{'kernel-manager'} --action=getpath --name=$kernel`;
					chomp($path_to_kernel);
					if(!(-d $path_to_kernel)) {
						vsay 'NORMAL', "Can't get path for kernel.";
						return;
					}
					my $kernel_file;
					chomp($_);
					if(/$state->{'path'}\/+ldv_tempdir\/+driver\/+/) {
						$kernel_file="$_";
					} elsif ( -f && /$kernel\/+/) {
						$kernel_file = $_;
						$kernel_file =~ s/.*\/+$kernel\/+(.*)/$path_to_kernel\/$1/;
					} elsif (/^\//) {
						$kernel_file=$_;
					} else {
						$kernel_file="$path_to_kernel/$_";
					}
					chomp($kernel_file);
					if(!(-f $kernel_file)) {
						vsay 'NORMAL', "Can't find kernel file.";
						return;
					}
					if(system('cp',$kernel_file,$rel_path_full)) {
						vsay 'NORMAL', "Can't copy kernel file.";
						return;
					}
					# Save relative file to the list
					my (undef,undef,$copied_file) = splitpath($kernel_file);
					my $r = File::Spec->catfile($target_rel_path,$copied_file);
					$sources{$r} = 1;
				}
			}
			# Save source file names to the report
			for my $src_fname (keys %sources){
				XML::Twig::Elt->new('sourcefile',{},$src_fname)->paste(last_child=>$_[0]);
			}
		}
	}

}	

sub get_state {
	my ($ident,@states) = @_;
	foreach (@states) {
		/^(.*):(.*)$/ or next;
		my $path=$2;
		my $envid=$1;
		vsay 'TRACE', "STATES: $1, $2\n";
		$ident =~ m/$path/ and return {env=>$envid, val=>'0', path=>$path};
	}
}

use File::Find;
sub search {  push (@filelist,$File::Find::name) if(!-d); }
sub get_reports {
	my ($config) = @_;
	my @local_reports=();
	find(\&search, $config->{'reports-dir'});
	my @out_reports=();
	foreach(@filelist) { if(/.*$config->{'report-name'}/) { push(@out_reports,$_); } }
	return @out_reports;
}

sub get_states {
	my ($config) = @_;
	open FILE, $config->{'state-file'} or die"Can' open state file \"$config->{'state-file'}\": $!"; 
	my @states = <FILE>; 
	close FILE or die"Can't close state file \"$config->{'state-file'}\": $!";
	return @states;	
}


