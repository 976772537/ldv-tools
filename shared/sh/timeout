#!/usr/bin/perl
# Resource monitoring script for limiting black-boxed processes.
# It runs an arbitrary process and watches for memory and time consumption.
# The main feature is that it watches not only the process spawned, but also
# its children--as long as a process doesn't detach ownership from parent (or
# doesn't change process group; use -w).

sub usage{ print STDERR <<usage_ends;
Usage:
	timeout [-t timelimit] [-m memlimit] [-x herz] command [argumens ...]

usage_ends
	die;
}
# We use require_order because we don't want to process options of the command we run
use Getopt::Long qw(:config require_order);
use Time::HiRes qw( gettimeofday ); 

my $timelimit = undef;
my $hanguplimit = undef;
my $ticklimit = undef;
my $memlimit = undef;
my $strpat = undef;
my $output = undef;
my $reference = undef;
my $watchfor = 'tree';
# Requests per seccond
my $frequency = 10;

GetOptions(
	'timelimit|t=i'=>\$timelimit,
	'hanguplimit|h=i'=>\$hanguplimit,
	'memlimit|m=i'=>\$memlimit,
	'frequency|x=i'=>\$frequency,
	'pattern|p=s'=>\$strpat,
	'output|o=s'=>\$output,
	'reference|r=s'=>\$reference,
	'watchfor|w=s'=>\$watchfor,
) or usage;

@ARGV or usage;

my $uinfo = get_patterns($strpat);

my $uwait = int (1_000_000 / $frequency);

use strict;

# Fork process and set its process group
my $blackbox_pid = fork;
defined $blackbox_pid or die "Couldn't fork: $!";

unless ($blackbox_pid){
	# Set the process group of the blackbox process
	# We set it even if we watch for a process tree
	setpgrp 0,0;
	local $" = " ";
	exec @ARGV or die "Couldn't exec @ARGV: $!"; 
}
# Make sure we kill forked child on exit
sub when_die{
	kill_process_group_safely($blackbox_pid);
	exit -1;
};
$SIG{'INT'} = \&when_die;
$SIG{'TERM'} = \&when_die;
$SIG{'QUIT'} = \&when_die;
# We sleep between sending TERM and KILL to kids, so we might end up in a regular tick instead of the kill procedure!
# Here's a block for that
my $dying = 0;

use Data::Dumper;

# Now we'll just keep polling status of the process until we notice that resources are exhausted or until the child finishes
use Time::HiRes qw( ualarm );

# see sub update_time for explanations of this structure
my $timeinfo = { total => 0, finished => 0, current => {} };
# For this -- update_memory
my $meminfo = 0;
my $ticksinfo = 0;
my $fulltime = 0;

#
# Default ticklimit - empirical relationship
#
if(!$hanguplimit && $timelimit) {
	$ticklimit = 10*$timelimit*$frequency;
} elsif($hanguplimit) {
	$ticklimit = $hanguplimit*$frequency;
}

if(!$ticklimit && $timelimit) {
	$ticklimit = 10*$timelimit*$frequency;
}
 
my $status = 'wait';
my $box_status = 0;
while ($status eq 'wait'){
	my $child_errno;
	my $child_retv;
	# Usually we would just do alarm-waitpid, but in Perl we should do weird evals.
	# Refer to `perldoc alarm` if surprised.
	eval {
		local $SIG{'ALRM'} = sub {
			# If we're dying don't return to the embracing eval, return somewhere else!
			return if $dying;
			# Note that this signal can only interrupt "wait" function (unless we're currently in some internals of Perl implementation of waitpid wrapper, but must of the time we spend inside the wait() call).
			# According to signal(7), wait is a safe function, so we can call anything we want here.
			$timeinfo = update_time($blackbox_pid,$timeinfo);
			$meminfo = update_memory($blackbox_pid,$meminfo);
			$ticksinfo = update_info_by_ucmd($blackbox_pid,$uinfo);
			die "Assume waitpid return 0\n";
		};
		ualarm $uwait;
		my $arrived = waitpid $blackbox_pid,0;
		ualarm 0;
		die "Assume waitpid return $arrived\n";
	};
	$child_errno = $!;
	$child_retv = $?;
	my $arrived = -1;
	if ($@ =~ /Assume waitpid return (.*)/){
		$arrived = $1;
	}else{
		print_uinfo($uinfo,$fulltime);
		die "Fail: $@";
	}
	if ($arrived == $blackbox_pid){
		# Child process terminated.
		$box_status = $child_retv>>8;
		$status = 'exit'
	}elsif ($arrived == -1){
		# Something happened!
		print_uinfo($uinfo);
                print "ldv-timeout: WARNING: Wait($blackbox_pid) failed: $child_errno\n";
                exit 0;
	}else{
		# Check if limits are exhausted (they should be updated by signal handler).
		# First kill, then print the script's verdict, so that it's less likely to mingle with the output of the process being controlled.
		if (defined $timelimit && $timeinfo->{total} > $timelimit){
			kill_process_group_safely($blackbox_pid);
			# have some sleep for output to be flushed
			sleep(1);
			print STDERR "$ENV{'TIMEOUT_IDSTR'}TIMEOUT $timeinfo->{total} CPU\n";
			print_uinfo($uinfo);
			exit 0;
		}
		if (defined $ticklimit && $ticksinfo > $ticklimit) {
			kill_process_group_safely($blackbox_pid);
			sleep(1);
			print STDERR "$ENV{'TIMEOUT_IDSTR'}HANGUP ".ceil($ticksinfo/$frequency)."\n";
			print_uinfo($uinfo);
			exit 0;
		}
		if (defined $memlimit && $meminfo > $memlimit){
			kill_process_group_safely($blackbox_pid);
			sleep(1);
			print STDERR "$ENV{'TIMEOUT_IDSTR'}MEM $timeinfo->{total}\n";
			print_uinfo($uinfo);
			exit 0;
		}
	}
}

print_uinfo($uinfo);
exit $box_status;

#-----------------------------------------------
use POSIX;
my $ticksize;
BEGIN { $ticksize = POSIX::sysconf(&POSIX::_SC_CLK_TCK) or die "Couldn't get ticksize";}


# Function that traverses process tree (according to watchfor setting) and invokes the function supplied for each applicable process
sub foreach_applicable_process
{
	my ($pgrp,$watchfor,$sub) = @_;
	local $_;
	# Depending on whether we count time for process tree or for process group, we use different command.
	if ($watchfor eq 'tree') {
		# Read ps output of a process tree, and read a subtree of the pid we watch for
		# The tree will look like this:
		# 26944 26944 kdeinit4
		# 26944 26948  \_ klauncher
		# 26944 12501  \_ kio_pop3
		# 26944  1591  \_ VirtualBox
		# 26944  1598  |   \_ VirtualBox
		# 26944  1644  |       \_ VBoxXPCOMIPCD
		# 26944 28333  \_ pidgin
		# 26944 28581  \_ kio_file
		# 26944 12496 kmail
		my $chars = "\t \\_|";
		my $PS_FH; open $PS_FH, "-|", qw(ps -e f -o pgrp= -o pid= -o vsz= -o ucmd=) or die "Bad open ps: $!";
		my $state = 0;	# 0 - still haven't encounter root;	1 - reading tree; (when tree is read, we break the loop)
		my $initial_depth = undef;	# Initial depth of the root of a tree
		while (<$PS_FH>){
			/^\s*([0-9]+)\s*([0-9]+)\s*([0-9]+)([ |\\_]+)(.*)/ or next;
			#      PID                depth in process tree
			my ($grp,$pid,$vsz,$depth_str,$cmd) = ($1,$2,$3,$4,$5);
			if ($state == 0){
				# Still haven't encounter root, check if it's now
				$pid == $pgrp or next;
				$state = 1;
				$initial_depth = length $depth_str;
			}else{
				# Reading inside process tree, check if it's not over
				length $depth_str == $initial_depth and last;
			}
			# Ok, this is a node in the tree we want to process
			$sub->($pid,$grp,$cmd,$vsz);
		}
		close $PS_FH or die "Bad close ps: $!";
	}else{
		# Read ps output to get all processes within a group. Time output is not necessary, since we calculate it directly via /proc
		my $PS_FH; open $PS_FH, "-|", qw(ps -A -o pgrp= -o pid= -o vsz= -o ucmd=) or die "Bad open ps: $!";
		while (<$PS_FH>){
			/^\s*([0-9]+)\s*([0-9]+)\s*([0-9]+)\s*(.*)/ or next;
			my ($grp,$pid,$vsz,$cmd) = ($1,$2,$3);
			$grp == $pgrp or next;

			$sub->($pid,$grp,$cmd,$vsz);
		}
		close $PS_FH or die "Bad close ps: $!";
	}
}

sub hires_proc_runtime
{
	my ($pid) = @_;
	my $stat = `cat /proc/$pid/stat 2>/dev/null`;
	# Since we invoke this function quite often, process may decease betweem ps invocation and attempt to access its /proc entry.  So, we return undef and handle it in the caller.  That's also the reason of error redirection to void.
	return undef unless $stat;
	# Parse proc stats--14th is utime, and it's expressed in ticks.
	my (undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,$utime_ticks,$stime_ticks,$cum_utime_ticks,$cum_stime_ticks) = split /\s+/,$stat;
	return (($utime_ticks + $stime_ticks)/$ticksize, ($cum_utime_ticks + $cum_stime_ticks)/$ticksize);
}
sub update_time
{
	# Calculate the CPU+SYS time consumed by processes in the process group.  Updates special timeinfo structure fur future calculations
	my ($pgrp, $timeinfo) = @_;

	# For one process, cumulative time is its runtime plus runtime of its dead children.  Therefore, if we sum up cumulative times for all the eligible processes, we'll get the total runtime of the black box
	my $cumulative_time = 0;

	foreach_applicable_process($pgrp,$watchfor,sub { my ($pid,$grp,$cmd) = @_;
		# If hires_proc_runtime doesn't return a value (the $pid died before it tried), we keep the old value of time.  The error is not greater than ualarm interval.
		my ($pid_time,$pid_cum_time) = hires_proc_runtime($pid);
		if (defined $pid_time){
			$cumulative_time += $pid_time + $pid_cum_time;
		}
	});

	return {total => $cumulative_time};
}

sub update_memory
{
	# Calculate the amount of memory consumed by the process group given
	my ($pgrp) = @_;
	my $result = 0;
	foreach_applicable_process($pgrp,$watchfor,sub { my ($pid,$grp,$cmd,$vsz) = @_;
		$result += $vsz;
	});
	return $result;
}

sub signal_to_process_group_safely
{
	my ($pgrp,$signal) = @_;
	if ($watchfor eq 'tree') {
		# We can't kill the whole process group, so we do the following trick.
		# We send SIGSTOP to all applicable processes.  Since they could have spawned more kids between reading their PID from ps and sending signal, we repeat this step until all processes are stopped
		my $new_kids_spawned = 1;
		my %sent_to = ();
		while ($new_kids_spawned) {
			$new_kids_spawned = 0;
			foreach_applicable_process($pgrp,$watchfor,sub { my ($pid) = @_;
				return if $sent_to{$pid};
				$sent_to{$pid} = 1;
				$new_kids_spawned = 1;
				kill SIGSTOP, $pid;
			});
		}
		# Now all the controlled processes are stopped, we send them the signal we want
		foreach_applicable_process($pgrp,$watchfor,sub { my ($pid) = @_;
			kill $signal, $pid;
		});
		# Continue the proccesses, so that they can process the signal handler
		foreach_applicable_process($pgrp,$watchfor,sub { my ($pid) = @_;
			kill SIGCONT, $pid;
		});
	}else{
		# it's still unclear to me if there won't be a delay between catching signals in different processes when a signal is sent to a whole group.
		kill SIGSTOP, -$pgrp;
		kill $signal, -$pgrp;
		kill SIGCONT, -$pgrp;
	}
}

sub kill_process_group_safely
{
	my ($pgrp) = @_;
	# Show that we're dying, so that our timely alarm handler doesn't longjmp() control out of here
	$dying = 1;
	signal_to_process_group_safely($pgrp,SIGTERM);
	# Reset alarm handler (we need it for sleep to work)
	$SIG{'ALRM'} = 'DEFAULT';
	sleep(1);
	signal_to_process_group_safely($pgrp,SIGKILL);
}

sub update_info_by_ucmd
{
	my ($pgrp, $strpat) = @_;
	my $max_ticks = 0;

	foreach_applicable_process($pgrp,$watchfor,sub { my ($pid,$grp,$ucmd) = @_;
		my ($proctime,undef) = hires_proc_runtime($pid);
		#$proctime or next;
		# Search process by pattern
		foreach my $key(keys %{$strpat}) {
			$ucmd =~ m/$key/ or next;
			$strpat->{$key}->{pids}->{$pid}->{ptime} = $proctime;
			$strpat->{$key}->{pids}->{$pid}->{ucmd} = $ucmd;
		}
	});

	# Calculate full time for each pattern
	foreach my $key(keys %{$strpat}) {
		if($strpat->{$key}->{ptime}) {
			$strpat->{$key}->{oldtime} = $strpat->{$key}->{ptime};
		} else {
			$strpat->{$key}->{oldtime} = 0;
		};

		$strpat->{$key}->{ptime} = 0;
		foreach (keys %{$strpat->{$key}->{pids}}) {
			$strpat->{$key}->{ptime} += $strpat->{$key}->{pids}->{$_}->{ptime};
		}
	
		if($strpat->{$key}->{oldtime} == $strpat->{$key}->{ptime}) {
			%{$strpat->{$key}->{pids}} == 0 or $strpat->{$key}->{ticks}++; 
		} else {
			$strpat->{$key}->{ticks} = 0;
		}
		$max_ticks<$strpat->{$key}->{ticks} and $max_ticks = $strpat->{$key}->{ticks};
	}	
	return $max_ticks;
}


#
# TODO: If the file already exists, and it contains two or more <time>...</time>
#       blocks with equals references and name 
#       then we must be calculate summary time and write one <time>..</time> 
#       block  instead of more with equlas references.
#       It needs for rule-instrumentor, that execute aspectator two time for
#       one cc command. 
#
sub print_uinfo
{		
	defined $output and (open(FIL,">>", $output) or die "Can't open output file: $!\n");
	my ($strpat) = @_;
	my $reftext="";
	defined $reference and $reftext="ref=\"$reference\"";
	foreach my $key( keys %{$strpat}) {
		%{$strpat->{$key}->{pids}} or next;
		defined $output or next;
		print(FIL "<time ".$reftext." name=\"".$strpat->{$key}->{name}."\">".sprintf("%.0f", 1000*$strpat->{$key}->{ptime})."</time>\n");
		#foreach (keys %{$strpat->{$key}->{pids}}) {
		#	print FIL "<time ".$reftext." name=\"".$strpat->{$key}->{pids}->{$_}->{ucmd}."\">".1000*$strpat->{$key}->{pids}->{$_}->{ptime}."</time>\n";
		#}
	}
	defined $output and close FIL;
}

sub get_patterns
{
	my ($patterns_in_string) = @_;
	my @splitted_patterns = split(/;/,$patterns_in_string);
	my %patterns = ();
	foreach (@splitted_patterns) {
		my ($pattern, $name) = split(/,/,$_);
		$patterns{$pattern} = {name=>$name, ptime=>0, pids=>{}};
	}
	%patterns == 0 and $patterns{'.*'} = {name=>'ALL', prtime=>0, pids=>{}};
	return {%patterns};
}
