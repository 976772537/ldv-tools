#!/usr/bin/perl
# Resource monitoring script for limiting black-boxed processes.
# It runs an arbitrary process and watches for memory and time consumption.
# The main feature is that it watches not only the process spawned, but also
# its children--as long as it doesn't emerge a new process group, which it
# should watch for on its own.

sub usage{ print STDERR <<usage_ends;
Usage:
	timeout [-t timelimit] [-m memlimit] [-x herz] command [argumens ...]

usage_ends
	die;
}
# We use require_order because we don't want to process options of the command we run
use Getopt::Long qw(:config require_order);

my $timelimit = undef;
my $memlimit = undef;
my $strapt = undef;
my $output = undef;
my $reference = undef;
# Requests per seccond
my $frequency = 10;

GetOptions(
	'timelimit|t=i'=>\$timelimit,
	'memlimit|m=i'=>\$memlimit,
	'frequency|x=i'=>\$frequency,
	'pattern|p=s'=>\$strpat,
	'output|o=s'=>\$output,
	'reference|r=s'=>\$reference,
) or usage;

@ARGV or usage;

my $uinfo = get_patterns($strpat);

my $uwait = int (1_000_000 / $frequency);

use strict;

# Fork process and set its process group
my $blackbox_pid = fork;
defined $blackbox_pid or die "Couldn't fork: $!";

unless ($blackbox_pid){
	# Set the process group of the blackbox process
	setpgrp 0,0;
	local $" = " ";
	exec @ARGV or die "Couldn't exec @ARGV: $!"; 
}
# Make sure we kill forked child on exit
sub when_die{
	kill_process_group_safely($blackbox_pid);
	exit -1;
};
$SIG{'INT'} = \&when_die;
$SIG{'TERM'} = \&when_die;
$SIG{'QUIT'} = \&when_die;

use Data::Dumper;

# Now we'll just keep polling status of the process until we notice that resources are exhausted or until the child finishes
use Time::HiRes qw( ualarm );

# see sub update_time for explanations of this structure
my $timeinfo = { total => 0, finished => 0, current => {} };
# For this -- update_memory
my $meminfo = 0;

my $fulltime = 0;

my $status = 'wait';
my $box_status = 0;
while ($status eq 'wait'){
	# Usually we would just do alarm-waitpid, but in Perl we should do weird evals.
	# Refer to `perldoc alarm` if surprised.
	eval {
		local $SIG{'ALRM'} = sub {
			# Note that this signal can only interrupt "wait" function (unless we're currently in some internals of Perl implementation of waitpid wrapper, but must of the time we spend inside the wait() call).
			# According to signal(7), wait is a safe function, so we can call anything we want here.
			$timeinfo = update_time($blackbox_pid,$timeinfo);
			$meminfo = update_memory($blackbox_pid,$meminfo);
			$fulltime = update_info_by_ucmd($blackbox_pid,$uinfo);
			die "Assume waitpid return 0\n";
		};
		ualarm $uwait;
		my $arrived = waitpid $blackbox_pid,0;
		ualarm 0;
		die "Assume waitpid return $arrived\n";
	};
	my $arrived = -1;
	if ($@ =~ /Assume waitpid return ([0-9]+)/){
		$arrived = $1;
	}else{
		print_uinfo($uinfo,$fulltime);
		die "Fail: $@";
	}
	if ($arrived == $blackbox_pid){
		# Child process terminated.
		$box_status = $?>>8;
		$status = 'exit'
	}elsif ($arrived == -1){
		# Something happened!
		print_uinfo($uinfo,$fulltime);
		die "wait($blackbox_pid) failed: $!";
	}else{
		# Check if limits are exhausted (they should be updated by signal handler).
		if (defined $timelimit && $timeinfo->{total} > $timelimit){
			print STDERR "$ENV{'TIMEOUT_IDSTR'}TIMEOUT $timeinfo->{total} CPU\n";
			kill_process_group_safely($blackbox_pid);
			print_uinfo($uinfo,$fulltime);
			exit 0;
		}
		if (defined $memlimit && $meminfo > $memlimit){
			print STDERR "$ENV{'TIMEOUT_IDSTR'}MEM $timeinfo->{total}\n";
			kill_process_group_safely($blackbox_pid);
			print_uinfo($uinfo,$fulltime);
			exit 0;
		}
	}
}

print_uinfo($uinfo,$fulltime);
exit $box_status;

#-----------------------------------------------
use POSIX;
my $ticksize;
BEGIN { $ticksize = POSIX::sysconf(&POSIX::_SC_CLK_TCK) or die "Couldn't get ticksize";}
sub hires_proc_runtime
{
	my ($pid) = @_;
	my $stat = `cat /proc/$pid/stat 2>/dev/null`;
	# Since we invoke this function quite often, process may decease betweem ps invocation and attempt to access its /proc entry.  So, we return undef and handle it in the caller.  That's also the reason of error redirection to void.
	return undef unless $stat;
	# Parse proc stats--14th is utime, and it's expressed in ticks.
	my (undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,$utime_ticks,$stime_ticks) = split /\s+/,$stat;
	return ($utime_ticks + $stime_ticks)/$ticksize;
}
sub update_time
{
	# Calculate the CPU+SYS time consumed by processes in the process group.  Updates special timeinfo structure fur future calculations
	my ($pgrp, $timeinfo) = @_;
	my %terminated = (%{$timeinfo->{current}});
	my $result = {total => $timeinfo->{total}, finished => $timeinfo->{finished}, current => {} };
	# Read ps output to get all processes within a group. Time output is not necessary, since we calculate it directly via /proc
	my $PS_FH; open $PS_FH, "-|", qw(ps -A -o pgrp= -o pid=) or die "Bad open ps: $!";
	while (<$PS_FH>){
		/^\s*([0-9]+)\s*([0-9]+)/ or next;
		my ($grp,$pid) = ($1,$2);
		$grp == $pgrp or next;

		# If hires_proc_runtime doesn't return a value (the $pid died before it tried), we keep the old value of time.  The error is not greater than ualarm interval.
		$result->{current}->{$pid} = hires_proc_runtime($pid) || $timeinfo->{current}->{$pid};
		# Show that this process is still running by removind it from set of processes that were running in this group, but have been terminated.
		delete $terminated{$pid} if $terminated{$pid};
	}
	close $PS_FH or die "Bad close ps: $!";

	local $_;
	# Add the total time of terminated processes to finished time.
	$result->{finished}+=$_ for values %terminated;

	# Recalculate total time
	$result->{total}=$result->{finished};
	$result->{total}+=$_ for values %{$result->{current}};

	return $result;
}

sub update_memory
{
	# Calculate the amount of memory consumed by the process group given 
	my ($pgrp) = @_;
	my $result = 0;
	# Read ps output to get all processes within a group.
	my $PS_FH; open $PS_FH, "-|", qw(ps -A -o pgrp= -o pid= -o vsz=) or die "Bad open ps: $!";
	while (<$PS_FH>){
		/^\s*([0-9]+)\s*([0-9]+)\s*([0-9]+)/ or next;
		my ($grp,$pid,$mem) = ($1,$2,$3);
		$grp == $pgrp or next;
		$result += $mem;
	}
	close $PS_FH or die "Bad close ps: $!";
	return $result;
}

sub kill_process_group_safely
{
	my ($pgrp) = @_;
	# it's still unclear to me if there won't be a delay between catching signals in different processes when a signal is sent to a whole group.
	kill SIGSTOP, -$pgrp or die;
	kill SIGTERM, -$pgrp or die;
	kill SIGCONT, -$pgrp or die;

	kill SIGKILL, -$pgrp or die;
}

sub update_info_by_ucmd 
{
	my ($pgrp, $strpat) = @_;
	my $PS_FH; open $PS_FH, "-|", qw(ps -A -o pgrp= -o pid= -o ucmd=) or die "Bad open ps: $!"; 
	while(<$PS_FH>){
		/^\s*([0-9]+)\s+([0-9]+)\s+(.*)/ or next;
		my ($grp, $pid, $ucmd) = ($1, $2, $3);
		$pgrp == $grp or next;
		my $proctime = hires_proc_runtime($pid);
		$proctime or next;
		# Search process by pattern		
		foreach my $key(keys %{$strpat}) {
			$ucmd =~ m/$key/ or next;
			$strpat->{$key}->{pids}->{$pid}->{ptime} = $proctime;
			$strpat->{$key}->{pids}->{$pid}->{ucmd} = $ucmd;
		}	
	}
	close $PS_FH;

	# Calculate full time for each pattern
	foreach my $key(keys %{$strpat}) {
		$strpat->{$key}->{ptime} = 0;
		foreach (keys %{$strpat->{$key}->{pids}}) {
			$strpat->{$key}->{ptime} += $strpat->{$key}->{pids}->{$_}->{ptime};
		}
	}	
}


#
# TODO: If the file already exists, and it contains two or more <time>...</time>
#       blocks with equals references and name 
#       then we must be calculate summary time and write one <time>..</time> 
#       block  instead of more with equlas references.
#       It needs for rule-instrumentor, that execute aspectator two time for
#       one cc command. 
#
sub __print_uinfo
{		
	defined $output and (open(FIL,">>", $output) or die "Can't open output file: $!\n");
	my ($strpat) = @_;
	my $reftext="";
	defined $reference and $reftext="ref=\"$reference\"";
	foreach my $key( keys %{$strpat}) {
		%{$strpat->{$key}->{pids}} or next;
		defined $output or next;
		print(FIL "<time ".$reftext." name=\"".$strpat->{$key}->{name}."\">".1000*$strpat->{$key}->{ptime}."</time>\n");
		#foreach (keys %{$strpat->{$key}->{pids}}) {
		#	print FIL "<time ".$reftext." name=\"".$strpat->{$key}->{pids}->{$_}->{ucmd}."\">".1000*$strpat->{$key}->{pids}->{$_}->{ptime}."</time>\n";
		#}
	}
	defined $output and close FIL;
}

sub print_uinfo
{
	my ($strpat) = @_;
	foreach my $key( keys %{$strpat}) {
		%{$strpat->{$key}->{pids}} or next;
		print "NAME: \"".$strpat->{$key}->{name}."\" matched with pattern \"".$key."\", full time for pattern: ".1000*$strpat->{$key}->{ptime}." milliseconds\n";
		foreach (keys %{$strpat->{$key}->{pids}}) {
			print "\tpid: $_, time: ".1000*$strpat->{$key}->{pids}->{$_}->{ptime}." milliseconds, user command: \"".$strpat->{$key}->{pids}->{$_}->{ucmd}."\"\n";
		}
	}
	__print_uinfo($strpat);
}

sub get_patterns
{
	my ($patterns_in_string) = @_;
	my @splitted_patterns = split(/;/,$patterns_in_string);
	my %patterns = ();
	foreach (@splitted_patterns) {
		my ($pattern, $name) = split(/,/,$_);
		$patterns{$pattern} = {name=>$name, ptime=>0, pids=>{}};
	}
	return {%patterns};
}
