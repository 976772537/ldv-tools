#!/bin/bash
#
# The Bash shell script executes a command with a time-out and memory limit.
# Prints termination reason to STDERR or to a file specified.

# Extended by Pavel Shved <shved@ispras.ru>,
# based on a script by Dmitry V Golovashkin <Dmitry.Golovashkin@sas.com>

# This script is in public domain.

scriptName="${0##*/}"

declare -i DEFAULT_TIMEOUT=9
declare -i DEFAULT_HARD_TIMEOUT=-1
declare -i DEFAULT_INTERVAL=1
declare -i DEFAULT_DELAY=1

declare -i DEFAULT_MEMLIMIT=0

# Timeout for CPU and SYS time
declare -i timeout=DEFAULT_TIMEOUT
# Timeout for "real" elapsed time
declare -i real_timeout=DEFAULT_HARD_TIMEOUT
# Interval between checks if the process is still alive.
declare -i interval=DEFAULT_INTERVAL
# Delay between posting the SIGTERM signal and destroying the process by SIGKILL.
declare -i delay=DEFAULT_DELAY

# Memory limite
declare -i memlimit=DEFAULT_MEMLIMIT

# Report file
declare report_file=/dev/stderr

function printUsage() {
    cat <<EOF

Synopsis
    $scriptName [-t timeout] [-i interval] [-d delay] command
    Execute a command with a time-out.
    Upon time-out expiration SIGTERM (15) is sent to the process. If SIGTERM
    signal is blocked, then the subsequent SIGKILL (9) terminates it.

    -t timeout
        Number of seconds to wait for command to complete.  It only takes 
        CPU+System time into account.
        Default value: $DEFAULT_TIMEOUT seconds.

    -x timeout
        Number of seconds to wait for command to complete.  It counts 
        "real" time elapsed.  -1 if not used.
        Default value: $DEFAULT_HARD_TIMEOUT seconds.

    -i interval
        Interval between checks if the process is still alive.
        Positive integer, default value: $DEFAULT_INTERVAL seconds.

    -r report_file
        Prints report to the file specified.  The output is "OK <seconds>" if
        the script finished, "MEM <seconds>" if script is terminated due to 
        insufficient memory, and "TIMEOUT <seconds> WHAT" if timeout is
        reached (WHAT is "CPU" or "real").
        <seconds> is the CPU+sys time the process was running.
        Printed to STDERR by default.

    -d delay
        Delay between posting the SIGTERM signal and destroying the
        process by SIGKILL. Default value: $DEFAULT_DELAY seconds.

    -m memlimit (kB)
        Memory limit in kilobytes.  Limits virtual memory.
        Default value: $DEFAULT_MEMLIMIT kb.

Time limits are enforced with 2*interval accuracy.  Memory is not limited
with ulimit, so if during such a short time your program allocates the whole
memory, you're unlucky then.

As of today, Bash does not support floating point arithmetic (sleep does),
therefore all delay/time values must be integers.
EOF
}

# Options.
while getopts ":t:i:d:m:x:r:" option; do
    case "$option" in
        t) timeout=$OPTARG ;;
        x) real_timeout=$OPTARG ;;
        i) interval=$OPTARG ;;
        r) report_file=$OPTARG ;;
        d) delay=$OPTARG ;;
        m) memlimit=$OPTARG ;;
        *) printUsage; exit 1 ;;
    esac
done
shift $((OPTIND - 1))

# $# should be at least 1 (the command to execute), however it may be strictly
# greater than 1 if the command itself has options.
if (($# == 0 || interval <= 0)); then
    printUsage
    exit 1
fi

# We used to set memory limit with ulimit.  But then decided to limit on our own.
#if (( $memlimit != DEFAULT_MEMLIMIT )); then
#	ulimit -HSv $memlimit
#fi

# Convert time to seconds
function to_seconds ()
{
	date -u -d "1970-01-01 $@" +%s
}


"$@" &

jobs
watch_pid=`jobs -p 1`

# kill -0 pid   Exit code indicates if a signal may be sent to $pid process.
#(
	process_worked=$(to_seconds "$(ps -o time= $watch_pid)")
	process_memory=
	process_realtime=

	while ((timeout > process_worked)); do
		sleep $interval
		# Check if process is still running and print a report (if $report_file is set), then exit
		kill -0 $watch_pid 2>/dev/null || { echo OK $process_worked >$report_file ;  break; }
		
		# ATTENTION!  After this kill invocation process may terminate!  Wa have to carefully save older value.
		old_pw_value=$process_worked
		process_worked=$(to_seconds "$(ps -o time= $watch_pid)")
		[ $process_worked -eq 0 ] && process_worked=$old_pw_value

		# NOTE that it's irrelevant where to put process_worked assignment, since we can't guarantee the accuracy greater than $interval.

		# Check real time and exit if it's failed
		# Since ps sometimes reports time as MM:SS and sometimes - as HH:MM:SS, I have to hack this up
		process_realtime=$(to_seconds "$(ps -o etime= $watch_pid | sed 's/\s\([0-9]\+\):\([^:]*\)$/00:\1:\2/')")
		((real_timeout != -1)) && ((real_timeout < process_realtime)) && break

		# Check memory status of the process.
		# Ulimit is not sufficient, since we want to control output of it.
		process_memory="$(ps -o vsz= $watch_pid )"
		((memlimit != DEFAULT_MEMLIMIT)) && ((memlimit < process_memory)) && break
	done

	# Leave a message that programm is killed due to timeout
	if ((real_timeout != DEFAULT_HARD_TIMEOUT)) && ((real_timeout <= process_realtime)) ; then
		echo "${TIMEOUT_IDSTR}TIMEOUT $process_worked real" 1>$report_file
	fi
	# Real time limit
	if ((timeout != DEFAULT_TIMEOUT)) && ((timeout  <= process_worked)) ; then
		echo "${TIMEOUT_IDSTR}TIMEOUT $process_worked CPU" 1>$report_file
	fi
	# Memory limit
	if ((memlimit != DEFAULT_MEMLIMIT)) && ((memlimit <= process_memory)) ; then
		echo "${TIMEOUT_IDSTR}MEM $process_worked" 1>$report_file
	fi

	# Be nice, post SIGTERM first.
	# The 'exit 0' below will be executed if any preceeding command fails.
	(
		kill -s SIGTERM $watch_pid && kill -0 $watch_pid || exit 0 
		sleep $delay
		kill -s SIGKILL $watch_pid
	) 2>/dev/null

	# Get exit code of the child process (wait returns immediately, since the process is already dead)
	wait $watch_pid
	cmd_excode=$?
	exit $cmd_excode

#) &


