#!/usr/bin/perl -w
#

my $instrumnet = 'ldv-core';

use FindBin;
# To prevent meaningless module warnings use this instead of use.
BEGIN { $SIG{'__WARN__'} = sub{}; require SOAP::Lite; SOAP::Lite->import(); $SIG{__WARN__}='DEFAULT'; }
use POSIX ":sys_wait_h";
use XML::Twig;
use IO::Socket::INET;
#use File::MimeInfo;
use File::Basename;


BEGIN {
        $ENV{'LDV_HOME'} ||= "$FindBin::Bin/..";
        push @INC,"$ENV{'LDV_HOME'}/shared/perl";
}

sub usage{ print STDERR<<usage_ends;

Usage:
        $instrumnet TBD

usage_ends
        die;
}


use Cwd 'abs_path';
use Utils;
$ENV{'WORK_DIR'} || die"Please, specify WORK_DIR environment variable!";

use Getopt::Long qw(:config require_order);

my $config = {
        'verbosity' => $ENV{'LDV_DEBUG'} || 'NORMAL',
        'workdir' => $ENV{'WORK_DIR'},
        'csd-reporter' => "$ENV{'LDV_HOME'}/build-cmd-extractor/cmd-stream-divider-reporter",
        'is-empty' => "$ENV{'LDV_HOME'}/build-cmd-extractor/is_empty.pl",
        'patchmod' => "$ENV{'LDV_HOME'}/ldv-core/patchmod.pl",
        'csd' => "$ENV{'LDV_HOME'}/build-cmd-extractor/csd.jar",
        'ruledb' => "$ENV{'LDV_HOME'}/kernel-rules/model-db.xml",
        'dscv' => "$ENV{'LDV_HOME'}/bin/dscv",
        'ldv-core-reporter' => "$ENV{'LDV_HOME'}/ldv-core/ldv-core-reporter",
        'bce' => "$ENV{'LDV_HOME'}/build-cmd-extractor/build-cmd-extractor",
        'bce-reporter' => "$ENV{'LDV_HOME'}/build-cmd-extractor/build-cmd-extractor-reporter",
        'deg' => "$ENV{'LDV_HOME'}/drv-env-gen/drv-env-gen",
        'deg-reporter' => "$ENV{'LDV_HOME'}/drv-env-gen/drv-env-gen-reporter",
        'rule-instrumentor' => "$ENV{'LDV_HOME'}/rule-instrumentrule-instrumentor.pl",
        'dscv' => "$ENV{'LDV_HOME'}/bin/dscv",
        'timeout' => "$ENV{'LDV_HOME'}/shared/sh/timeout",
        'rule-db' => "$ENV{'LDV_HOME'}/kernel-rules",


	'DRIVER_DIR_NAME' => 'driver',
	'EXTRACTOR_LOG_FILENAME' => 'unarch.log'
};

GetOptions(
        'rule-models|m=s'=>\$config->{'rule-models'},
        'report-out|o=s'=>\$config->{'report-out'},
        'env|e=s'=>\$config->{'env'},
        'cmdstream|s=s'=>\$config->{'cmdstream'},
        'kernel-driver|k=s'=>\$config->{'kernel-driver'},
        'driver|d=s'=>\$config->{'driver'},
) or usage;

use File::Path qw(make_path remove_tree);
use LDV::Utils;
use IPC::Open3;
use File::Spec::Functions qw(splitpath catfile);
LDV::Utils::set_verbosity($config->{verbosity});
LDV::Utils::push_instrument($instrumnet);

sub init_config;
sub bce_create_report;
sub bce_ldv_report;
sub start_csd;
sub start_bce;
sub prepare_driver;
sub parallel_run;
sub scheduler_send_task;
sub deg_create_report;
sub find_unused_port;
sub verbose_system;
sub prepare_driver_source;
sub prepare_patch;
sub detect_dir_source;
sub detect_type;

#########################################################
#             MAIN 					#
#########################################################

# Generate unique number for CSD Server name 
my $wsdl_uid="$$".`date +%Y%H%M%S`;
chomp $wsdl_uid;

# Find free port and generate adress for starting CSD Server
$ENV{'WSDLADDR'} = "http://localhost:".find_unused_port()."/csd$wsdl_uid";
vsay 'TRACE', "WSDL Address is $ENV{'WSDLADDR'}\n";

# Initialize config (create dirs, files and etc)
init_config;

# Prepare driver and kernel for work with Build Command Extractor
# (Unpack driver and kernel, copy ...)
prepare_driver;

#
# Process 1: Starting Command Stream Divider server 
#
my $csd_pid = start_csd;
is_exists($csd_pid) or die"Starting CSD failed: $!";

#
# Process 2: Starting Build Command Extractor
#
my $bce_pid = start_bce;
if(!is_exists($bce_pid)) {
	vsay 'TRACE', "Try to kill CSD...\n";
	kill 9, $csd_pid;
	waitpid $csd_pid, 0;
}

#
# Process 3: Process for getting, preparing and sending to DSCV commands 
#           from CSD. Also generate reports.
#
my $next_pid = start_next($csd_pid);
if(!is_exists($next_pid)) {
	vsay 'TRACE', "Try to kill BCE and CSD...\n";
	kill 9, $bce_pid, $csd_pid;
	waitpid $bce_pid, 0;
	waitpid $csd_pid, 0;
}

#
# Wait while BCE not finished
#
waitpid $bce_pid, 0;
vsay 'TRACE', "BCE successfully finished\n";

#
# Try to connect to CSD and white while verification process is finished.
# There are two ways to determine it:
#
#   1. - stack with commands is empty and bce finished (see before).
#        (BCE is dead and new commands are not received to CSD cmd stack.)
#  
#   2. - Verification process already finished (failed) and stack is not empty. 
#
my $csd = SOAP::Lite -> service($ENV{'WSDLADDR'}.'?wsdl');

vsay 'DEBUG', "Wait until CSD is empty...\n";

# Due to memory leak in SOAP::Lite, we can't call isEmpty() directly many times; instead we call an external program
#while($csd->isEmpty() eq 'false') {
while(system($config->{'is-empty'})) {
	is_exists($next_pid) or last;
	sleep 1;
}

#
# kill CSD
#
vsay 'TRACE', "Kill CSD and reap it...\n";
kill 9, $csd_pid;
waitpid $csd_pid, 0;

#
# Wait until verification process finished her works. Verification
# process guaranteed to terminate if CSD is dead.
#
vsay 'TRACE', "Wait until the fork finishes...\n";
waitpid $next_pid, 0;


#
# check if process is exists in /proc, AND if it's not defunct (zombie).
# The PID of the process may still be in the system, but it may have long be gone.
#
sub is_exists {
	my ($pid) = @_;
	defined $pid or return 0;
	return (-d "/proc/$pid") && (`cat /proc/$pid/status` !~ /State:.*Z/);
}

#
# Verification process starter
#
sub start_next {
	my ($csd_pid) = @_; 
	my $pid = fork;
	#return $pid unless defined $pid;
	unless ($pid) {
		vsay 'NORMAL', "Connect to CSD WSDL Service...\n";
		my $csd = eval{ return SOAP::Lite -> service($ENV{'WSDLADDR'}.'?wsdl') };
		my $old_workdir = $ENV{'WORK_DIR'};
	
		# eval block for watcher scope
		eval {

		sub kill_watcher {
			vsay 'WARNING', "Killing build...\n";
			kill 9, $bce_pid;
			vsay 'INFO', "Shutting down watcher\n";
			LDV::Utils::watcher_cmd('fail', @{$config->{'watcher_key'}});
			bce_ldv_report 'FAILED', 'exit', "Watcher exception";
			die "Fatal error: $@";
		}

		$SIG{TERM} = \&kill_watcher;
		$SIG{INT} = \&kill_watcher;
		$SIG{QUIT} = \&kill_watcher;

		my $tasks = {};
		while(1) {
			my $command =  eval{ return $csd->getCommand(); };
			if($command) {
				vsay 'TRACE', "Calling external interface to submit task\n";
				vsay 'NORMAL', "Prepared command in: $command\n";
				vsay 'NORMAL', "Calling drv-env-gen...\n";
				#make_path("$command/deg");
				$ENV{'WORK_DIR'} = $command;
				
				my @deg_args = (
					$config->{'deg'},
					"--basedir=deg",
					"--cmdfile=$command/cmd_after_csd.xml",
					"--cmdfile-out=$command/cmd_after_deg.xml",
					"--state-file=$command/deg.state"
				);
		
				$config->{'kernel-driver'} or push @deg_args,"--driver-name=$config->{'driver_name'}";

				if($config->{'cmdstream'}) {
                                        push @deg_args,"--kernel-driver";       
				} else {
                                        push @deg_args,"--kernel-driver" if $config->{'kernel-driver'};       
				}

				vsay 'TRACE', "$ENV{'WORK_DIR'} @deg_args\n";
				system(@deg_args) and die"$!"; # if it die -> create corresponding report! and die"$!";
				$ENV{'WORK_DIR'} = $old_workdir;

				$command =~ m/.*\/+([0-9]+)/ and my $cid=$1;	
				$tasks->{$cid}->{state} = 'wait';
				$tasks->{$cid}->{path} = $command;
				vsay 'TRACE', "Calling external interface to submit task for CID=$cid\n";
			
				scheduler_send_task($tasks->{$cid}, $cid);		
					
		
				vsay 'NORMAL', "Wait for command...\n";
			} else {
				vsay 'TRACE', "Test for next command...\n";
				!is_exists($csd_pid) and last;
			}
		}

		vsay 'NORMAL', "Sleep while all tasks verified.\n";
		# pass this stage in single machine
		vsay 'NORMAL', "Wait for all tasks are verified...\n";
		wait_for_all_verified($tasks);
		vsay 'NORMAL', "Collect and process reports.\n";	
		foreach my $ltask (values %{$tasks}) {
			deg_create_report($ltask->{path});
		}
		my $rep_result = csd_create_report($tasks);
		
		# create 
		vsay 'TRACE', "Try to send 'success' message to watcher...\n";
		LDV::Utils::watcher_cmd('success', @{$config->{'watcher_key'}});
		vsay 'TRACE', "Message 'success' was sent to watcher.\n";
		bce_ldv_report $rep_result;
		1;
		} or do {
			print STDERR $@ if ($@);
			vsay 4, "Fatal error.  Stopping services before reporting...\n";
			kill_watcher();
		};

		exit 0;
	}
	return $pid;
}

#
# Create report after Command Stream Divider 
#
sub csd_create_report {
	my ($tasks) = @_;
	
	vsay 'DEBUG', "Prepare list of DEG reports for CSD reporter \"$config->{'csd_tempdir'}/list_of_deg_reports\"...\n";
	open DEGLIST, ">","$config->{'csd_tempdir'}/list_of_deg_reports" or die"$!";
	print DEGLIST "$tasks->{$_}->{path}/report_after_deg.xml\n" foreach keys %{$tasks};
	close DEGLIST;

	vsay 'NORMAL', "Calling CSD reporter...\n";
	
	my @csd_reporter_args = ($config->{'csd-reporter'},
		"--cmdfile=$config->{'xml_after_bce'}",
		'--report-name=report_after_deg.xml',
		"--report-out=$config->{'csd_tempdir'}/report_after_csd.xml",
		"--report-list=$config->{'csd_tempdir'}/list_of_deg_reports",
		"--state-file=$config->{'csd_state'}"
	);
			
	vsay 'TRACE', "LDV_DEBUG=$ENV{'LDV_DEBUG'} WORK_DIR=$ENV{'WORK_DIR'} @csd_reporter_args\n";	 
	-f $config->{'csd_state'} or return 'FAILED';
	system(@csd_reporter_args) and return 'FAILED';
	return 'OK';
}

#
# Create reports for Driver Environment Generator
#
sub deg_create_report {
	my ($task_path)  = @_;
	vsay 'DEBUG', "Calling DEG reporter for \"$task_path\"\n";

	@deg_reporter_args = ($config->{'deg-reporter'},
		"--stats-file=$task_path/deg/stats.xml",
		"--cmdfile=$task_path/cmd_after_csd.xml",
		"--report-in=$task_path/dscv_tempdir/report_after_dscv.xml",
		"--report-out=$task_path/report_after_deg.xml",
		"--state-file=$task_path/deg.state"
	);
		
	vsay 'TRACE', "LDV_DEBUG=$ENV{'LDV_DEBUG'} WORK_DIR=$ENV{'WORK_DIR'} @deg_reporter_args\n";	 
	system(@deg_reporter_args);
}

#
# Wait until all queued to DSCV tasks are verified.
# For all tasks (The number of tasks is calculated before cycle):
#  --->
#  |   1. wait queued task
#  |   2. unpack by watcher
#  |<--
#
sub wait_for_all_verified {
	my ($tasks) = @_;
	vsay 'TRACE', "Start watcher waiting...\n";

	# calculate number of queued task
	my $wait_counter = 0;
	foreach (keys %{$tasks}) {
		$tasks->{$_}->{state} eq 'queued' and $wait_counter++;
	}

	#
	# waiting for all tasks
	#
	vsay 'TRACE', "Number of tasks in status 'queued' is - $wait_counter\n";
	while($wait_counter > 0) {
		vsay 'TRACE', "Tasks for wait_for_dscv: $wait_counter\n";
	        my ($path, $contents, @key) = wait_for_dscv() and $wait_counter--;
		#not defined $path and die"Can't get path!";
	        for my $wk (@{$config->{'watcher_key'}}){
	                my $k = shift @key;
	                die "Assertion failed: '$k' == '$wk'" if $k ne $wk;
	        }
	        my (undef, $cid) = @key;

	        # unpack the incoming package
	        vsay 'INFO', "Successfully waited for command id \"$cid\" from \"$tasks->{$cid}->{path}\"\n";
	        vsay 'DEBUG', "Unpacking '$contents' to '$path'\n";
	        LDV::Utils::watcher_cmd('unpack', $path, $contents);

		# find corresponding task descriptor and set status to 'verified'
		vsay 'TRACE', "Set status 'verified' to task id \"$cid\"\n";
		$tasks->{$cid}->{state} = 'verified';
	}
}

sub wait_for_dscv {
	vsay 'TRACE', "Wait for dscv tasks: watcher_cmd('wait', 'any', @{$config->{'watcher_key'}})\n";
	my ($dscv_id, undef) = LDV::Utils::watcher_cmd('wait', 'any', @{$config->{'watcher_key'}});
	$dscv_id or return;
	return split /,/,$dscv_id;	
}

#
# Prepare task descriptor for DSCV and queue task.
#
sub scheduler_send_task {
	my ($task_descriptor, $cid) = @_;
	my $command = $task_descriptor->{'path'};
	$task_descriptor->{'state'} eq 'wait' or return;
	$task_descriptor->{'task_fname'} = "$command/task_descriptor";

	make_path("$command/dscv_tempdir") or die"$!";
	my $dscv_report = "$command/dscv_tempdir/report_after_dscv.xml";
	vsay 'NORMAL', "Calling Domain Speicific C-Verifier\n";
	
	my $dscv_args = {
		'cmdfile'      => "$command/cmd_after_deg.xml",
		'properties'   => "$config->{'rule-models'}",
		'report'       => "$command/dscv_tempdir/report_after_dscv.xml",
		'workdir'      => "$command/dscv_tempdir",
		'ruledb'       => "$config->{'ruledb'}"
	};
		
	vsay 'TRACE', "Write DSCV arguments to task descriptor file \"$task_descriptor->{'task_fname'}\".\n";
        my $TASK; open $TASK, ">", $task_descriptor->{'task_fname'} or die "Can't open '$task_descriptor->{'task_fname'}': $!";
	Utils::hash_to_xml($dscv_args, 'input', $TASK);
        close $TASK;

	vsay 'TRACE', "Make work dir for task \"$command/input_task\"\n";
	make_path("$command/task_input");
	
	vsay 'TRACE', "Set RCV_FRONTEND_CMD to \"$config->{'dscv'}\"\n";
	$ENV{'RCV_FRONTEND_CMD'} = $config->{'dscv'}
;
	vsay 'TRACE', "Calling watcher...\n";
	LDV::Utils::watcher_cmd_noread('queue', 'dscv', $task_descriptor->{'task_fname'}, "$command/task_input", @{$config->{'watcher_key'}}, 'dscv', $cid);

	vsay 'TRACE', "Set task status to \"queued\"\n";
	$task_descriptor->{'state'} = 'queued';
}

sub parallel_run {
        my ($args, $err, $out) = @_;
	vsay 'TRACE', "$args\n";
	vsay 'TRACE', "Logging stdout to file: \"$out\".\n"; 
	vsay 'TRACE', "Logging stderr to file: \"$err\".\n"; 
        open FILERR, ">$err" or die"$!";
        open FILOUT, ">$out" or die"$!";
        my $pid = open3(undef, ">&FILOUT", ">&FILERR", $args);
        my $child_pid = fork;
        unless ($child_pid) {
                waitpid $pid, 0;
                close FILERR;
                close FILOUT;
                exit 0;
        }
        return $pid;
}

#
# Build Command Extractor starter
#
sub start_bce {
	vsay 'NORMAL', "Starting BCE...\n";
	$ENV{'BUILDFILE'} = "$config->{'bce_tempdir'}/build.xml";
	my @bce_args = ($config->{'timeout'},
		'-p',
		'.*,ALL\;CHILD:.*,ALL\;.*bce_gcc.*,BCE_GCC\;.*as_gcc.*,AS_GCC\;.*cc1.*,CC1',
		'--allow-hangups',
		'-o',
		$config->{'bce_stats'},
		$config->{'bce'},
		"--env=$config->{'env'}",
		"--basedir=bce_tempdir",
		"--state=$config->{'bce_state'}",
		"--cmdfile-out=$config->{'xml_after_bce'}",
	);
	if($config->{'cmdstream'}) {
		push @bce_args, "--cmdstream=$config->{'cmdstream'}";
		push @bce_args, '--kernel-driver';
	} elsif($config->{ptarget}) {
		$config->{ptarget} =~ s/ /&/g;
		push @bce_args, "--driver=\"$config->{ptarget}\""; 
		push @bce_args, '--kernel-driver';
	} else {
		push @bce_args, "--driver=$config->{'driver'}";
		$config->{'kernel-driver'} and push @bce_args, '--kernel-driver';
	}

	my $pid = parallel_run "@bce_args", "$config->{'ldv_tempdir'}/bce_err.log", "$config->{'ldv_tempdir'}/bce_out.log";
	
	vsay 'NORMAL', "BCE Started\n";
	return $pid;

}

#
# Command Stream Divider starter
#
sub start_csd {
	vsay 'NORMAL', "Starting CSD (WSDL)...\n";
	my @csd_options = ('java',
		'-Xmx256M',
		'-jar',
		$config->{'csd'},
		"--wsdladdr=$ENV{'WSDLADDR'}",
		'--basedir=csd_deg_dscv',
		'--cmdfile-out=cmd_after_csd',
		"--state-file=$config->{'csd_state'}",
#		"--tagbd=$config->{'env'}",
	);

	if($config->{'kernel-driver'} || $config->{ptarget}) {
		push @csd_options,"--tagbd=$config->{'env'}";
	} else {
		push @csd_options,"--tagbd=$config->{'driver'}";
		push @csd_options,"--full-copy";
	}
	
	my $pid = parallel_run "@csd_options", "$config->{'ldv_tempdir'}/csd_err.log", "$config->{'ldv_tempdir'}/csd_out.log";

	my $csd = undef;
	vsay 'TRACE', "Wait for CSD service...\n";
	while(!$csd) {
		$csd = eval{ return SOAP::Lite -> service($ENV{'WSDLADDR'}.'?wsdl');};
		waitpid $pid, WNOHANG;
		if(!$csd and !is_exists($pid)) {
			die"CSD process is died!\n";
		}
		sleep 2;
	}
	vsay 'NORMAL', "CSD Started\n";
	return $pid;

}

sub init_config {
	vsay 'DEBUG', "Config initialization...\n";
	
	$config->{'driver_name'} = $config->{'driver'};
	$config->{'workdir'} || die"Please, specify WORKDIR environment variable options.";
	$config->{'workdir'} = abs_path($config->{'workdir'});
	
	# path to file with path targets
	$config->{'pout'} = "$config->{'workdir'}/patchmod.xml";
	$config->{'rule-models'}   or die"Please, specify --rule-models options.";
	$config->{'report-out'}    or die"Please, specify --report-out options.";
	$config->{'env'}           or die"Please, specify --env options.";
	$config->{'backup'}->{'patch'}->{'folder'} = "$config->{'env'}/ldv_backup/backup_before_patch";
#	$config->{'kernel-driver'} or die"Please, specify --kernel-driver options.";
	#$config->{'driver'} is checked only out of cmdstream mode
	$config->{'env'}           = abs_path($config->{'env'});
	$config->{'report-out'}    = abs_path($config->{'report-out'});
	-d $config->{'env'} or die"Environmnet dir \"$config->{'env'}\" - not exists!";
	-d $config->{'report-out'} and die"Output report file \"$config->{'report-out'}\" - already exists as dir!";
	-f $config->{'report-out'} and die"Output report file \"$config->{'report-out'}\" - already exists as file!";

	$config->{'bce_tempdir'} = "$config->{'workdir'}/bce_tempdir";
	$config->{'ldv_tempdir'} = "$config->{'workdir'}/ldv_tempdir";
	$config->{'csd_tempdir'} = "$config->{'workdir'}/csd_deg_dscv";
	if($config->{'cmdstream'}) {
		$config->{'cmdstream'} = abs_path($config->{'cmdstream'});
		-f $config->{'cmdstream'} or die"Cmd stream file not exists \"$config->{'cmdstream'}\".";
		$config->{'xml_after_bce'} = $config->{'cmdstream'};
		vsay 'INFO', "Artificial environment mode.\n";
	} else {
		$config->{'driver'}        or die"Please, specify --driver options.";
		$config->{'xml_after_bce'} = "$config->{'bce_tempdir'}/cmd_after_bce.xml";
		if(!$config->{'kernel-driver'}) {
			$config->{'driver'} = abs_path($config->{'driver'});
		};
		defined $config->{'report-out'} or die"Please, specify --report-out options.";
	}
	vsay 'DEBUG', "Config initialization - ok\n";
	vsay 'DEBUG', "Creating working dirs...\n";

	vsay 'DEBUG', "Creating dir \"$config->{'ldv_tempdir'}\"...\n";
	not -d $config->{'ldv_tempdir'} and  make_path("$config->{'ldv_tempdir'}");
	vsay 'DEBUG', "Creating dir \"$config->{'bce_tempdir'}\"...\n";
	not -d $config->{'bce_tempdir'} and make_path("$config->{'bce_tempdir'}");
	vsay 'DEBUG', "Creating dir \"$config->{'csd_tempdir'}\"...\n";
	not -d $config->{'csd_tempdir'} and make_path("$config->{'csd_tempdir'}");

	$config->{'bce_report'} = "$config->{'bce_tempdir'}/report_after_bce.xml";
	$config->{'bce_stats'} = "$config->{'bce_tempdir'}/stats.xml";
	$config->{'csd_report'} = "$config->{'csd_tempdir'}/report_after_csd+PLACE+.xml";
	$config->{'bce_state'} = "$config->{'bce_tempdir'}/err.state";
	$config->{'unarch_log'} = "$config->{'ldv_tempdir'}/unarch.log";
	$config->{'as_gcc_pool'} = "$config->{'bce_tempdir'}/as_gcc_pool";
	$config->{'csd_state'} = "$config->{'csd_tempdir'}/csd.state";
	$ENV{'AS_GCC_POOL'} = $config->{'as_gcc_pool'};
	$config->{'driverdir'} = "$config->{'ldv_tempdir'}/$config->{'DRIVER_DIR_NAME'}";
	$config->{'DRIVER_UNPACK_NAME'} = 'driver_unpacked';
	$config->{'driver_unpacked'} = "$config->{'ldv_tempdir'}/$config->{'DRIVER_UNPACK_NAME'}";

	$ENV{'LDV_WATCHER_SRV'} ||= "$config->{'workdir'}/watcher";
	vsay ('INFO',"Watcher server is $ENV{'LDV_WATCHER_SRV'}\n");
	my ($key_str,undef) = LDV::Utils::watcher_cmd('key','ldv-core');
	vsay 'DEBUG', "Got key string $key_str.\n";
	my @watcher_key = split /,/,$key_str;
	$config->{'watcher_key'} = \@watcher_key;
}

sub bce_create_report {
	vsay 'NORMAL', "Creating BCE report...\n";
	my ($state, $msg) = @_;
	my $report_lines;
	if($state eq 'FAILED') {
		$msg ||= 'Kernel compile error';
		vsay 'TRACE', "BCE report saved in $config->{'bce_report'}\n";
		open FILE, ">", "$config->{'bce_report'}" or die"$!";
		print FILE "<?xml version=\"1.0\"?>\n<reports>\n  <build>\n    <status>$state</status>\n    <time></time>\n    <desc>";
		if( -f $config->{'bce_state'}) {
			open FILE_STATE, $config->{'bce_state'} or die "$!";
			my $state = '';
			while(<FILE_STATE>){
				print FILE "$_";
				# When in patch mode, the following error is shown if configuration is insufficient for this driver to compile.  Print the relevant message in this case.
				/No rule to make target/ and $state="Compile error.  Maybe the driver the patch introduces is not turned on on make allmodconfig?\n";
			}
			print FILE $state;
			close FILE_STATE or die "$!";
		} else {
			print FILE $msg;
		}
		print FILE "    </desc>\n  </build>\n</reports>\n";
		close FILE or die"$!";
	} else {
		vsay 'DEBUG', "Calling BCE reporter...\n";
		my @bce_reporter_args = ($config->{'bce-reporter'},
			"--cmdfile=$config->{'xml_after_bce'}",
			"--stats-file=$config->{'bce_stats'}",
			"--report-in=$config->{'csd_tempdir'}/report_after_csd.xml",
			"--report-out=$config->{'bce_report'}",
			"--state-file=$config->{'bce_state'}"
		);
		vsay 'TRACE', "@bce_reporter_args\n";
		system(@bce_reporter_args) and die"$!";
	}
}

sub detect_type {
	vsay 'TRACE', "Detecting source type for \"$_[0]\"...\n";
#  	my $mime_type = mimetype($_[0]);
  	my $mime_type = `file -b --mime-type $_[0]`;
	chomp $mime_type;
	if(!$mime_type) {
		vsay 'TRACE', "Can't detect source type for \"$_[0]\"\n";
		ldv_report_and_exit("Can't detect source type for \"$_[0]\"\n");
	};
	vsay 'TRACE', "Source type for \"$_[0]\" is - \"$mime_type\"\n";
	return $mime_type;
}

sub restore_kernel {
	# if backup folder after patcg applying exists then
	# restore files from it...
	vsay 'TRACE', "Starting restore kernel...\n";
	foreach my $backup_type (keys %{$config->{'backup'}}) {
		-d $config->{'backup'}->{$backup_type}->{'folder'} or next;
		copy_backup($config->{'backup'}->{$backup_type}->{'folder'}, $config->{'env'});

		# remove backup folder
		vsay 'TRACE', "Remove backup folder \"$config->{'backup'}->{$backup_type}->{'folder'}\"\n";
		verbose_system("rm -fr $config->{'backup'}->{$backup_type}->{'folder'}") and warn "Can't remove backup folder \"$config->{'backup'}->{$backup_type}->{'folder'}\": $!";
	};
}

#
# $source and $dest must be an absolute path
#
sub copy_backup {
	my ($source, $dest) = @_;

	vsay 'TRACE', "Copy files from backup folder \"$source\" to \"$dest\"\n.";
	-d $source or ldv_report_and_exit("Source backup source dir \"$source\" not exists..");
	-d $source or ldv_report_and_exit("Destination dir \"$dest\" for restore not exists.");

	my $files = findFiles($source);
	foreach my $src (@$files) {
		
		# prepare destination path
		my $dst = $src;
		$dst =~ s/$source\/+(.*)/$dest\/$1/;
		
		# create destination dirs if it needs
		my $dst_dir = dirname($dst);
		if(! -d $dst_dir) {
			make_path($dst_dir) or ldv_report_and_exit("Can't create dir \"$dst_dir\" for copy backup:$!"); 
		}
		
		# copy backup file to destination dir
		verbose_system("cp $src $dst") and ldv_report_and_exit("Can't copy backup file \"$src\" to \"$dst\":$!\n");
	};
}

sub prepare_driver {

	#
	#  Restore kernel files from backup, if it exists
	#
	restore_kernel();

	#
	#  Detect  input source type
	# 

	#  no prepared cmdstream from ldv-git.... 
	if(!$config->{'cmdstream'}) {

		#
		# Only for no internal kernel drivers...
		#      It may be:
		#  	- ARCHIVE: detect archive type and unpack...
		# 		+ application/x-bzip2 
		# 		+ application/x-gzip 
		# 	- OTHER:
		# 		+ detect it..
		#


		if(!$config->{'kernel-driver'}) {
			my $type = detect_type($config->{'driver'});
			
			vsay 'DEBUG', "First source detection stage...\n";
			#  I. If source - is archive - then unpack it and get type again...
			if(unpack_if_archive($type, $config->{'driver'}, $config->{'driver_unpacked'}, $config->{'unarch_log'})) {
				$config->{'driver'} = $config->{'driver_unpacked'};
				$type = detect_type($config->{'driver'});
			}

			vsay 'DEBUG', "Second source detection stage...\n";
			# II. Detect - source type and corresponding action...
			#if($type eq 'inode/directory') {
			if($type eq 'application/x-directory') {

				# detect - is it patch or driver or nothing...
			
				vsay 'DEBUG', "Dir source detection stage...\n";
				my $dir_type = detect_dir_source($config->{'driver'});
				if($dir_type eq 'driver') {
					prepare_driver_source();
				} elsif($dir_type eq 'patch') {
					prepare_patch();
				}
			#} elsif($type eq 'text/x-patch') {
			} elsif($type eq 'text/x-diff') {

				# actions for single patch
				prepare_patch();
			#} elsif($type eq 'text/plain') {
			} elsif($type eq 'text/plain') {

				# Text/plain may be patch too. Try to detect it...
				if(is_contains_patch($config->{'driver'}) == 1) {
					prepare_patch();
				} else {
					# We do not want to embarass user with our long irrelevant paths...
					my $filename_to_report = basename($config->{'driver'});
					ldv_report_and_exit("File \"$filename_to_report\" - is not a patch or driver archive");
				}
			} else {
				ldv_report_and_exit("Source type \"$type\" not supported");
			}
		} else {
			# vsay 'NORMAL', "Copy in-kernel driver environment\n";
			# my @copy_args = ('cp', '-r', $config->{'env'}, $config->{'driverdir'});
			# verbose_system("@copy_args") and ldv_report_and_exit("$!");
			# $config->{'env'} = $config->{'driverdir'};
			# $config->{'driverdir'} = $config->{'driver'};
		}
	}
}


#
# Get all files in dir, determine mime-types
# and return detected type of dir
# it may be:
#   - dir with external driver (dri contains Makefile or Kbuild)
#   - dir with patch (all files - text/plain or text/x-patch)
#   - Unknwon => exit from ldv-core with corresponding report
#
sub detect_dir_source {
	my ($dir) = @_;
	-d $dir or ldv_create_report("It is not dir \"$dir\"");
	my $files = findFiles($dir);
	$patch_counter = 0;
	foreach $file (@$files) {
		my $basename = basename($file);
		if($basename eq 'Makefile' || $basename eq 'Kbuild') {
			return 'driver';
		};
		my $type = detect_type($file);
		$type eq 'text/x-diff' and ++$patch_counter and next;
		$type eq 'text/plain' and is_contains_patch($file) == 1 and ++$patch_counter and next;
	}
	scalar(@{$files}) == 0 and ldv_report_and_exit("Dir with driver is empty.");
	$patch_counter == scalar(@{$files}) and return 'patch';
	ldv_report_and_exit("Can't detect source type in dir \"$dir\"");
}

#
# Some operation for patch detection in files 
# with "text/plain" mime type
#
sub is_contains_patch {
	my ($file) = @_;
	-f $file or ldv_create_report("It is not file \"$file\"");
	# TODO:
	#   heuristics for detect that file is patch
	open FILE, $file or ldv_report_and_exit("Can't open file \"$file\" for patch detection");
	my @lines = <FILE>;
	close FILE or ldv_report_and_exit("Can't close file \"$file\" after patch detection");
	foreach (@lines) {
		/^diff .*/ and return 1;
	};
	return 0;
}

sub prepare_driver_source {
	vsay 'NORMAL', "Prepare driver...\n";
}

sub prepare_patch {
	print "CONFIG:".$config->{'env'}."\n";
	vsay 'NORMAL', "Starting patchmod...\n";

#	vsay 'NORMAL', "Copy in-kernel driver environment\n";
#	my @copy_args = ('cp', '-r', $config->{'env'}, $config->{'driverdir'});

#	verbose_system("@copy_args") and ldv_report_and_exit("$!");

#	$config->{'env'} = $config->{'driverdir'};
#	$config->{'driverdir'} = $config->{'driver'};

        vsay 'DEBUG', "Path to kernel is: \"$config->{'env'}\"\n";
	my @patchmod_args = ("$config->{patchmod}",
		"--kernel=$config->{'env'}",
		"--backup=$config->{'backup'}->{'patch'}->{'folder'}",
		"--patch=$config->{driver}",
		"--out=$config->{pout}");

	vsay 'DEBUG', "Start patchmod script!\n";
        verbose_system("@patchmod_args") and ldv_report_and_exit("Pathcmod script failed!");

	if(-f $config->{pout}) {
		open FILE, $config->{pout} or ldv_report_and_exit("Can't open pathmod output file \"$config->{pout} : $!\"");
		my $state = 'OK';
		my $patch_msg="";
		while(<FILE>) {
			if(/  <result>(.*)<\/result>/) {
				$state = $1;
				next;
			} 
			if($state eq 'OK') {
				/  <target> (.*)<\/target>/ or next;
				$config->{ptarget} = $1;
				last;
			} elsif($state eq 'FAILED') {
				/  <desc>(.*)<\/desc>/ and ldv_report_and_exit($1);
				if(/  <desc>(.*)/) {
					$patch_msg.=$1;
				} elsif(/(.*)<\/desc>/) {
					$patch_msg.=$1;
					ldv_report_and_exit($patch_msg);
				} else {
					$patch_msg.=$_;
				}
			}
		}
		close FILE;
		vsay 'DEBUG', "Targets from patchmod: \"$config->{'driverdir'}\"\n";
	} else {
		ldv_report_and_exit("Error during patch processing...");
	}
}

sub unpack_if_archive {
	my ($type, $file, $outdir, $logfile) = @_;
	verbose_system("touch $config->{'unarch_log'}") and die"$!";

	# I. If source - is archive - then unpack it...
	#if($type eq 'application/x-bzip-compressed-tar') {
	if($type eq 'application/x-bzip2') {
		not -d $outdir and make_path($outdir);
		vsay 'TRACE', "Unpacking source x-bzip2\n";
		verbose_system("tar xvjpf $file -C $outdir > $logfile 2>&1") and ldv_report_and_exit("Can't unpack \"$file\"");
		return 1;
	#} elsif ($type eq 'application/x-compressed-tar') {
	} elsif ($type eq 'application/x-gzip') {
		not -d $outdir and make_path($outdir);
		vsay 'TRACE', "Unpacking source gzip\n";
		verbose_system("tar xvzpf $file -C $outdir > $logfile 2>&1") and ldv_report_and_exit("Can't unpack \"$file\"");
		return 1;
	};
}

sub verbose_system {
        my ($args) = @_;
        vsay 'TRACE', "Command: \"$args\"\n";
	return system("$args");
}

#
# Function for creating small reports without calling
# ldv-core-reporter. It needs for internal problems
# of ldv-core script.
# For examle - when ldv-core can't detect source type.
#
sub ldv_report_and_exit {
        vsay 'DEBUG', "Creating small report for LDV...\n";

        my $xmlRep = XML::Twig->new();
        $xmlRep->set_xml_version( '1.0');
        my $reportsT = XML::Twig::Elt->new('reports');
        $xmlRep->set_root($reportsT);

	my $buildT = XML::Twig::Elt->new('build');
	$buildT->set_att('kernel' =>$config->{'env'});
	XML::Twig::Elt->new('status', "FAILED")->paste('last_child', $buildT);
	XML::Twig::Elt->new('time')->paste('last_child', $buildT);
	XML::Twig::Elt->new('desc', $_[0])->paste('last_child', $buildT);
	$buildT->paste('last_child', $reportsT); 
	$buildT->set_pretty_print('indented');

        $xmlRep->set_pretty_print('indented');
        $xmlRep->print_to_file($config->{'report-out'});

#	my $report_text = "<?xml version=\"1.0\"?>\n";
#	$report_text .= "  <reports>\n";
#	$report_text .= "    <build kernel=\"$config->{'env'}\">\n";
#	$report_text .= "      <status>FAILED</status>\n";
#	$report_text .= "      <time></time>\n";
#	$report_text .= "      <desc>$_[0]</desc>\n";
#	$report_text .= "    </build>\n";
#	$report_text .= "  </reports>\n";  
#	open FILE, '>', $config->{'report-out'} or die"Can't create report file \"$config->{'report-out'}\":$!";
#	print FILE $report_text;
#	close FILE or die"Can't close report file \"$config->{'report-out'}\":$!";
	exit;
}

sub ldv_create_report {
        vsay 'DEBUG', "Calling LDV core reporter...\n";

	my @ldv_reporter_args = ($config->{'ldv-core-reporter'},
		"--report-in=$config->{'bce_report'}",
		"--report-out=$config->{'report-out'}",
		"--state-dir=$config->{'ldv_tempdir'}"
	);

        vsay 'TRACE', "LDV_DEBUG=$ENV{'LDV_DEBUG'} WORK_DIR=$ENV{'WORK_DIR'} @ldv_reporter_args\n";
        system(@ldv_reporter_args);
};

sub bce_ldv_report {
	my ($status, $action, $msg) = @_;
	vsay 'TRACE', "BCE and LDV report process staring...\n";
	bce_create_report $status, $msg;
	ldv_create_report;
	defined $action and $action eq 'exit' and exit;
}

#
# Find unused port for CSD server
#
sub find_unused_port {
        for($testport = 8080; $testport<8090; $testport++) {
                vsay 'DEBUG', "Test port: \"$testport\".\n";
                $testsocket = new IO::Socket::INET(LocalPort => $testport) and close $testsocket and return $testport;
                vsay 'DEBUG', "Failed to capture the port: \"$testport\": $!\n";
                vsay 'DEBUG', "Try next port...\n";
        }
        die"Can't find free ports from 8080 to 8090!";
}

sub findFiles {
        my @files = ();
        findFilesRec($_[0], \@files);
        return \@files;
};

sub findFilesRec {
        my ($dir, $files) = @_;
        opendir DIR, $dir or die"Can't open dir!";
        my @lfiles = readdir DIR;
        foreach (@lfiles) {
                /^\.$/ and next;
                /^\.\.$/ and next;
                -d "$dir/$_" and findFilesRec("$dir/$_", $files) and next;
                push @$files, "$dir/$_";
        }
        close DIR;
        return 1;
}

