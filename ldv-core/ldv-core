#!/usr/bin/perl -w
#

my $instrumnet = 'ldv-core';

use FindBin;
use SOAP::Lite; 
use POSIX ":sys_wait_h";
use XML::Twig;

BEGIN {
        $ENV{'LDV_HOME'} ||= "$FindBin::Bin/..";
        push @INC,"$ENV{'LDV_HOME'}/shared/perl";
}

sub usage{ print STDERR<<usage_ends;

Usage:
        $instrumnet TBD

usage_ends
        die;
}


use Cwd 'abs_path';
use Utils;
$ENV{'WORK_DIR'} || die"Please, specify WORK_DIR environment variable!";

use Getopt::Long qw(:config require_order);

my $config = {
        'verbosity' => $ENV{'LDV_DEBUG'} || 'NORMAL',
        'workdir' => $ENV{'WORK_DIR'},
        'csd-reporter' => "$ENV{'LDV_HOME'}/build-cmd-extractor/cmd-stream-divider-reporter",
        'csd' => "$ENV{'LDV_HOME'}/build-cmd-extractor/csd.jar",
        'ruledb' => "$ENV{'LDV_HOME'}/kernel-rules/model-db.xml",
        'dscv' => "$ENV{'LDV_HOME'}/bin/dscv",
        'ldv-core-reporter' => "$ENV{'LDV_HOME'}/ldv-core/ldv-core-reporter",
        'bce' => "$ENV{'LDV_HOME'}/build-cmd-extractor/build-cmd-extractor",
        'bce-reporter' => "$ENV{'LDV_HOME'}/build-cmd-extractor/build-cmd-extractor-reporter",
        'deg' => "$ENV{'LDV_HOME'}/drv-env-gen/drv-env-gen",
        'deg-reporter' => "$ENV{'LDV_HOME'}/drv-env-gen/drv-env-gen-reporter",
        'rule-instrumentor' => "$ENV{'LDV_HOME'}/rule-instrumentrule-instrumentor.pl",
        'dscv' => "$ENV{'LDV_HOME'}/bin/dscv",
        'timeout' => "$ENV{'LDV_HOME'}/shared/sh/timeout",
        'rule-db' => "$ENV{'LDV_HOME'}/kernel-rules",


	'DRIVER_DIR_NAME' => 'driver',
	'EXTRACTOR_LOG_FILENAME' => 'unarch.log'
};

GetOptions(
        'rule-models|m=s'=>\$config->{'rule-models'},
        'report-out|o=s'=>\$config->{'report-out'},
        'env|e=s'=>\$config->{'env'},
        'cmd-stream|s=s'=>\$config->{'cmd-stream'},
        'kernel-driver|k=s'=>\$config->{'kernel-driver'},
        'driver|d=s'=>\$config->{'driver'},
) or usage;

use File::Path qw(make_path remove_tree);
use LDV::Utils;
use IPC::Open3;
use File::Spec::Functions qw(splitpath catfile);
LDV::Utils::set_verbosity($config->{verbosity});
LDV::Utils::push_instrument($instrumnet);

sub init_config;
sub bce_create_report;
sub bce_ldv_report;
sub start_csd;
sub start_bce;
sub prepare_driver;
sub parallel_run;
sub scheduler_send_task;
sub deg_create_report;



my $wsdl_uid="$$".`date +%Y%H%M%S`;
chomp $wsdl_uid;
$ENV{'WSDLADDR'} = "http://localhost:8080/csd$wsdl_uid";
vsay 'TRACE', "WSDL Address is $ENV{'WSDLADDR'}\n";

init_config;
prepare_driver;

my $csd_pid = start_csd;
is_exists($csd_pid) or die"Starting CSD failed: $!";

my $bce_pid = start_bce;
if(!is_exists($bce_pid)) {
	vsay 'TRACE', "Try to kill BCE...\n";
	kill 9, $csd_pid;
	waitpid $csd_pid, 0;
}

my $next_pid = start_next($csd_pid);
if(!is_exists($next_pid)) {
	vsay 'TRACE', "Try to kill BCE and CSD...\n";
	kill 9, $bce_pid, $csd_pid;
	waitpid $bce_pid, 0;
	waitpid $csd_pid, 0;
}

waitpid $bce_pid, 0;
vsay 'TRACE', "BCE successfully finished\n";
my $csd = SOAP::Lite -> service($ENV{'WSDLADDR'}.'?wsdl');
sleep 5 while($csd->isEmpty() eq 'false');
kill 9, $csd_pid;

waitpid $csd_pid, 0;
waitpid $next_pid, 0;



sub is_exists {
	my ($pid) = @_;
	defined $pid or return 0;
	return -d "/proc/$pid";
}

sub start_next {
	my ($csd_pid) = @_; 
	my $pid = fork;
	#return $pid unless defined $pid;
	unless ($pid) {
		vsay 'NORMAL', "Connect to CSD WSDL Service...\n";
		my $csd = eval{ return SOAP::Lite -> service($ENV{'WSDLADDR'}.'?wsdl') };
		my $old_workdir = $ENV{'WORK_DIR'};
	
		# eval block for watcher scope
		eval {

		sub kill_watcher {
			bce_ldv_report 'FAILED', 'exit', "Watcher exception";
                        vsay 20, "Shutting down watcher\n";
                        LDV::Utils::watcher_cmd('fail', @{$config->{'watcher_key'}});
                        die"Fatal error: $@";
		}

		$SIG{TERM} = \&kill_watcher;
		$SIG{INT} = \&kill_watcher;
		$SIG{QUIT} = \&kill_watcher;

		my $tasks = {};
		while(1) {
			my $command =  eval{ return $csd->getCommand(); };
			if($command) {
				vsay 'TRACE', "Calling external interface to submit task\n";
				vsay 'NORMAL', "Prepared command in: $command\n";
				vsay 'NORMAL', "Calling drv-env-gen...\n";
				#make_path("$command/deg");
				$ENV{'WORK_DIR'} = $command;
				
				my @deg_args = (
					$config->{'deg'},
					"--basedir=deg",
					"--cmdfile=$command/cmd_after_csd.xml",
					"--cmdfile-out=$command/cmd_after_deg.xml",
					"--state-file=$command/deg.state"
				);
		
				$config->{'kernel-driver'} or push @deg_args,"--driver-name=$config->{'driver'}";

				if($config->{'cmdstream'}) {
                                        push @deg_args,"--kernel-driver";       
				} else {
                                        push @deg_args,"--kernel-driver" if $config->{'kernel-driver'};       
				}
		
				vsay 'TRACE', "$ENV{'WORK_DIR'} @deg_args\n";
				system(@deg_args) and die"$!"; # if it die -> create corresponding report! and die"$!";
				$ENV{'WORK_DIR'} = $old_workdir;
		
				$command =~ m/.*\/+([0-9]+)/ and my $cid=$1;	
				$tasks->{$cid}->{state} = 'wait';
				$tasks->{$cid}->{path} = $command;
				vsay 'TRACE', "Calling external interface to submit task for CID=$cid\n";
			
				scheduler_send_task($tasks->{$cid}, $cid);		
					
		
				vsay 'NORMAL', "Wait for command...\n";
			} else {
				vsay 'TRACE', "Test for next command...\n";
				!is_exists($csd_pid) and last;
			}
		}

		vsay 'NORMAL', "Sleep while all tasks verified.\n";
		# pass this stage in single machine
		vsay 'NORMAL', "Wait for all tasks are verified...\n";
		wait_for_all_verified($tasks);
		vsay 'NORMAL', "Collect and process reports.\n";	
		foreach my $ltask (values %{$tasks}) {
			deg_create_report($ltask->{path});
		}
		my $rep_result = csd_create_report($tasks);
		
		# create 
		vsay 'TRACE', "Try to send 'success' message to watcher...\n";
		LDV::Utils::watcher_cmd('success', @{$config->{'watcher_key'}});
		vsay 'TRACE', "Message 'success' was sent to watcher.\n";
		bce_ldv_report $rep_result;
		1;
		} or do {
		        vsay 4, "Fatal error.  Stopping services before reporting...\n";
			kill_watcher();
		};

		exit 0;
	}
	return $pid;
}

sub csd_create_report {
	my ($tasks) = @_;
	
	vsay 'DEBUG', "Prepare list of DEG reports for CSD reporter \"$config->{'csd_tempdir'}/list_of_deg_reports\"...\n";
	open DEGLIST, ">","$config->{'csd_tempdir'}/list_of_deg_reports" or die"$!";
	print DEGLIST "$tasks->{$_}->{path}/report_after_deg.xml\n" foreach keys %{$tasks};
	close DEGLIST;

	vsay 'NORMAL', "Calling CSD reporter...\n";
	
	my @csd_reporter_args = ($config->{'csd-reporter'},
		"--cmdfile=$config->{'xml_after_bce'}",
		'--report-name=report_after_deg.xml',
		"--report-out=$config->{'csd_tempdir'}/report_after_csd.xml",
		"--report-list=$config->{'csd_tempdir'}/list_of_deg_reports",
		"--state-file=$config->{'csd_state'}"
	);
			
	vsay 'TRACE', "LDV_DEBUG=$ENV{'LDV_DEBUG'} WORK_DIR=$ENV{'WORK_DIR'} @csd_reporter_args\n";	 
	-f $config->{'csd_state'} or return 'FAILED';
	system(@csd_reporter_args) and return 'FAILED';
	return 'OK';
}

sub deg_create_report {
	my ($task_path)  = @_;
	vsay 'DEBUG', "Calling DEG reporter for \"$task_path\"\n";

	@deg_reporter_args = ($config->{'deg-reporter'},
		"--stats-file=$task_path/deg/stats.xml",
		"--cmdfile=$task_path/cmd_after_csd.xml",
		"--report-in=$task_path/dscv_tempdir/report_after_dscv.xml",
		"--report-out=$task_path/report_after_deg.xml",
		"--state-file=$task_path/deg.state"
	);
		
	vsay 'TRACE', "LDV_DEBUG=$ENV{'LDV_DEBUG'} WORK_DIR=$ENV{'WORK_DIR'} @deg_reporter_args\n";	 
	system(@deg_reporter_args);
}

sub wait_for_all_verified {
	my ($tasks) = @_;
	vsay 'TRACE', "Start watcher waiting...\n";
	while (my @rv = wait_for_dscv()){
	        my ($path, $contents, @key) = @rv;
	        for my $wk (@{$config->{'watcher_key'}}){
	                my $k = shift @key;
	                die "Assertion failed: '$k' == '$wk'" if $k ne $wk;
	        }
	        my (undef, $cid) = @key;
	        # unpack the incoming package
	        vsay 'INFO', "Successfully waited for command id \"$cid\" from \"$tasks->{$cid}->{path}\"\n";
	        vsay 'DEBUG', "Unpacking '$contents' to '$path'\n";
	        LDV::Utils::watcher_cmd('unpack', $path, $contents);
		# find corresponding task descriptor and set status to 'verified'
		vsay 'TRACE', "Set status 'verified' to task id \"$cid\"\n";
		$tasks->{$cid}->{state} = 'verified';
	}
}

sub wait_for_dscv {
	vsay 'TRACE', "Wait for dscv tasks: watcher_cmd('wait', 'any', @{$config->{'watcher_key'}})\n";
	my ($dscv_id, undef) = LDV::Utils::watcher_cmd('wait', 'any', @{$config->{'watcher_key'}});
	$dscv_id or return;
	return split /,/,$dscv_id;	
}

sub is_all_verified {
	my ($tasks) = @_;
	foreach my $task (@$tasks) {
		$task->{'state'} ne 'verified' and return 0;
	}
}

sub scheduler_send_task {
	my ($task_descriptor, $cid) = @_;
	my $command = $task_descriptor->{'path'};
	$task_descriptor->{'state'} eq 'wait' or return;
	$task_descriptor->{'task_fname'} = "$command/task_descriptor";

	make_path("$command/dscv_tempdir") or die"$!";
	my $dscv_report = "$command/dscv_tempdir/report_after_dscv.xml";
	vsay 'NORMAL', "Calling Domain Speicific C-Verifier\n";
	
	my $dscv_args = {
		'cmdfile'      => "$command/cmd_after_deg.xml",
		'properties'   => "$config->{'rule-models'}",
		'report'       => "$command/dscv_tempdir/report_after_dscv.xml",
		'workdir'      => "$command/dscv_tempdir",
		'ruledb'       => "$config->{'ruledb'}"
	};
		
	vsay 'TRACE', "Write DSCV arguments to task descriptor file \"$task_descriptor->{'task_fname'}\".\n";
        my $TASK; open $TASK, ">", $task_descriptor->{'task_fname'} or die "Can't open '$task_descriptor->{'task_fname'}': $!";
	Utils::hash_to_xml($dscv_args, 'input', $TASK);
        close $TASK;

	vsay 'TRACE', "Make work dir for task \"$command/input_task\"\n";
	make_path("$command/task_input");
	
	vsay 'TRACE', "Set RCV_FRONTEND_CMD to \"$config->{'dscv'}\"\n";
	$ENV{'RCV_FRONTEND_CMD'} = $config->{'dscv'}
;
	vsay 'TRACE', "Calling watcher...\n";
	LDV::Utils::watcher_cmd_noread('queue', 'dscv', $task_descriptor->{'task_fname'}, "$command/task_input", @{$config->{'watcher_key'}}, 'dscv', $cid);

	vsay 'TRACE', "Set task status to \"queued\"\n";
	$task_descriptor->{'state'} = 'queued';
}

sub parallel_run {
        my ($args, $err, $out) = @_;
	vsay 'TRACE', "$args\n";
	vsay 'TRACE', "Logging stdout to file: \"$out\".\n"; 
	vsay 'TRACE', "Logging stderr to file: \"$err\".\n"; 
        open FILERR, ">$err" or die"$!";
        open FILOUT, ">$out" or die"$!";
        my $pid = open3(undef, ">&FILOUT", ">&FILERR", $args);
        my $child_pid = fork;
        unless ($child_pid) {
                waitpid $pid, 0;
                close FILERR;
                close FILOUT;
                exit 0;
        }
        return $pid;
}


sub start_bce {
	vsay 'NORMAL', "Starting BCE...\n";
	$ENV{'BUILDFILE'} = "$config->{'bce_tempdir'}/build.xml";
	my @bce_args = ($config->{'timeout'},
		'-p',
		'.*,ALL\;.*bce_gcc.*,BCE_GCC\;.*as_gcc.*,AS_GCC\;.*cc1.*,CC1',
		'-o',
		$config->{'bce_stats'},
		$config->{'bce'},
		"--env=$config->{'env'}",
		"--basedir=bce_tempdir",
		"--state=$config->{'bce_state'}",
		"--cmdfile-out=$config->{'xml_after_bce'}",
	);
	if($config->{'cmdstream'}) {
		push @bce_args, "--cmdstream=$config->{'cmdstream'}";
		push @bce_args, '--kernel-driver';
	} else {
		push @bce_args, "--driver=$config->{'driverdir'}";
		$config->{'kernel-driver'} and push @bce_args, '--kernel-driver';
	}

	my $pid = parallel_run "@bce_args", "$config->{'ldv_tempdir'}/bce_err.log", "$config->{'ldv_tempdir'}/bce_out.log";
	
	vsay 'NORMAL', "BCE Started\n";
	return $pid;

}


sub start_csd {
	vsay 'NORMAL', "Starting CSD (WSDL)...\n";
	my @csd_options = ('java',
		'-ea',
		'-jar',
		$config->{'csd'},
		"--wsdladdr=$ENV{'WSDLADDR'}",
		'--basedir=csd_deg_dscv',
		'--cmdfile-out=cmd_after_csd',
		"--state-file=$config->{'csd_state'}",
#		"--tagbd=$config->{'env'}",
	);

	if(not defined $config->{'kernel-driver'}) {
		push @csd_options,"--tagbd=$config->{'driverdir'}";
		push @csd_options,"--full-copy";
	} else {
		push @csd_options,"--tagbd=$config->{'env'}";
	}
	
	my $pid = parallel_run "@csd_options", "$config->{'ldv_tempdir'}/csd_err.log", "$config->{'ldv_tempdir'}/csd_out.log";

	my $csd = undef;
	vsay 'TRACE', "Wait for CSD service...\n";
	while(!$csd) {
		$csd = eval{ return SOAP::Lite -> service($ENV{'WSDLADDR'}.'?wsdl');};
		waitpid $pid, WNOHANG;
		if(!$csd and !is_exists($pid)) {
			die"CSD process is died!\n";
		}
		sleep 2;
	}
	vsay 'NORMAL', "CSD Started\n";
	return $pid;

}

sub init_config {
	vsay 'DEBUG', "Config initialization...\n";

	$config->{'workdir'} || die"Please, specify WORKDIR environment variable options.";
	$config->{'workdir'} = abs_path($config->{'workdir'});
	$config->{'rule-models'}   or die"Please, specify --rule-models options.";
	$config->{'report-out'}    or die"Please, specify --report-out options.";
	$config->{'env'}           or die"Please, specify --env options.";
#	$config->{'kernel-driver'} or die"Please, specify --kernel-driver options.";
	$config->{'driver'}        or die"Please, specify --driver options.";
	$config->{'env'}           = abs_path($config->{'env'});
	$config->{'report-out'}    = abs_path($config->{'report-out'});
	-d $config->{'env'} or die"Environmnet dir \"$config->{'env'}\" - not exists!";
	-d $config->{'report-out'} and die"Output report file \"$config->{'report-out'}\" - already exists as dir!";
	-f $config->{'report-out'} and die"Output report file \"$config->{'report-out'}\" - already exists as file!";

	$config->{'bce_tempdir'} = "$config->{'workdir'}/bce_tempdir";
	$config->{'ldv_tempdir'} = "$config->{'workdir'}/ldv_tempdir";
	$config->{'csd_tempdir'} = "$config->{'workdir'}/csd_deg_dscv";
	if($config->{'cmdstream'}) {
		$config->{'cmdstream'} = abs_path($config->{'cmdstream'});
		-f $config->{'cmdstream'} or die"Cmd stream file not exists \"$config->{'cmdstream'}\".";
		$config->{'xml_after_bce'} = $config->{'$cmdstream'};
		vsay 'INFO', "Artificial environment mode.\n";
	} else {
		$config->{'xml_after_bce'} = "$config->{'bce_tempdir'}/cmd_after_bce.xml";
		if(!$config->{'kernel-driver'}) {
			$config->{'driver'} = abs_path($config->{'driver'});
		};
		defined $config->{'report-out'} or die"Please, specify --report-out options.";
	}
	vsay 'DEBUG', "Config initialization - ok\n";
	vsay 'DEBUG', "Creating working dirs...\n";

	vsay 'DEBUG', "Creating dir \"$config->{'ldv_tempdir'}\"...\n";
	not -d $config->{'ldv_tempdir'} and  make_path("$config->{'ldv_tempdir'}");
	vsay 'DEBUG', "Creating dir \"$config->{'bce_tempdir'}\"...\n";
	not -d $config->{'ldv_tempdir'} and make_path("$config->{'bce_tempdir'}");
	vsay 'DEBUG', "Creating dir \"$config->{'csd_tempdir'}\"...\n";
	not -d $config->{'ldv_tempdir'} and make_path("$config->{'csd_tempdir'}");

	$config->{'bce_report'} = "$config->{'bce_tempdir'}/report_after_bce.xml";
	$config->{'bce_stats'} = "$config->{'bce_tempdir'}/stats.xml";
	$config->{'csd_report'} = "$config->{'csd_tempdir'}/report_after_csd+PLACE+.xml";
	$config->{'bce_state'} = "$config->{'bce_tempdir'}/err.state";
	$config->{'unarch_log'} = "$config->{'ldv_tempdir'}/unarch.log";
	$config->{'as_gcc_pool'} = "$config->{'bce_tempdir'}/as_gcc_pool";
	$config->{'csd_state'} = "$config->{'csd_tempdir'}/csd.state";
	$ENV{'AS_GCC_POOL'} = $config->{'as_gcc_pool'};

	$ENV{'LDV_WATCHER_SRV'} ||= "$config->{'workdir'}/watcher";
	vsay ('INFO',"Watcher server is $ENV{'LDV_WATCHER_SRV'}\n");
	my ($key_str,undef) = LDV::Utils::watcher_cmd('key','ldv-core');
	vsay 'DEBUG', "Got key string $key_str.\n";
	my @watcher_key = split /,/,$key_str;
	$config->{'watcher_key'} = \@watcher_key;
}

sub bce_create_report {
	vsay 'NORMAL', "Creating BCE report...\n";
	my ($state, $msg) = @_;
	my $report_lines;
	if($state eq 'FAILED') {
		$msg ||= 'Kernel compile error';
		vsay 'TRACE', "BCE report saved in $config->{'bce_report'}\n";
		open FILE, ">", "$config->{'bce_report'}" or die"$!";
		print FILE "<?xml version=\"1.0\"?>\n<reports>\n  <build>\n    <status>$state</status>\n    <time></time>\n    <desc>";
		if( -f $config->{'bce_state'}) {
			open FILE_STATE, $config->{'bce_state'} or die "$!";
			print FILE "$_\n" while(<FILE_STATE>); 
			close FILE_STATE or die "$!";
		} else {
			print FILE $msg;
		}
		print FILE "    </desc>\n  </build>\n</reports>\n";
		close FILE or die"$!";
	} else {
		vsay 'DEBUG', "Calling BCE reporter...\n";
		my @bce_reporter_args = ($config->{'bce-reporter'},
			"--cmdfile=$config->{'xml_after_bce'}",
			"--stats-file=$config->{'bce_stats'}",
			"--report-in=$config->{'csd_tempdir'}/report_after_csd.xml",
			"--report-out=$config->{'bce_report'}",
			"--state-file=$config->{'bce_state'}"
		);
		vsay 'TRACE', "@bce_reporter_args\n";
		system(@bce_reporter_args) and die"$!";
	}
}

sub prepare_driver {
	`touch $config->{'unarch_log'}` and die"$!";
	my $driverdir;
	if(!$config->{'cmdstream'}) {
		$driverdir = "$config->{'ldv_tempdir'}/$config->{'DRIVER_DIR_NAME'}";
		if(!$config->{'kernel-driver'}) {
			vsay 'NORMAL', "Prepare driver...\n";
			not -d $driverdir and make_path($driverdir);
			my $driver_src_type = `file -b $config->{'driver'} --mime-type`;
			chomp $driver_src_type;
			vsay 'TRACE', "Driver source type $driver_src_type\n";
			if($driver_src_type eq 'application/x-bzip2') {
				`tar xvjpf $config->{'driver'} -C $driverdir > $config->{'unarch_log'} 2>&1` and bce_ldv_report 'FAILED', 'exit', "Can't unpack driver";
			} elsif($driver_src_type eq 'application/x-gzip') {
				`tar xzjpf $config->{'driver'} -C $driverdir > $config->{'unarch_log'} 2>&1` and bce_ldv_report 'FAILED', 'exit', "Can't unpack driver";
			} else {
				bce_ldv_report 'FAILED', 'exit', "Unknown driver source type";
			}
		} else {
			vsay 'NORMAL', "Copy in-kernel driver environment\n";
			my @copy_args = ('cp', '-r', $config->{'env'}, $driverdir);
			vsay 'TRACE', "@copy_args\n";
			system(@copy_args) and die"$!";
			$config->{'env'} = $driverdir;
			$driverdir = $config->{'driver'};
		}
	}
	$config->{'driverdir'} = $driverdir;
}

sub ldv_create_report {
        vsay 'DEBUG', "Calling LDV core reporter...\n";

	my @ldv_reporter_args = ($config->{'ldv-core-reporter'},
		"--report-in=$config->{'bce_report'}",
		"--report-out=$config->{'report-out'}",
		"--state-dir=$config->{'ldv_tempdir'}"
	);

        vsay 'TRACE', "LDV_DEBUG=$ENV{'LDV_DEBUG'} WORK_DIR=$ENV{'WORK_DIR'} @ldv_reporter_args\n";
        system(@ldv_reporter_args);
};

sub bce_ldv_report {
	my ($status, $action, $msg) = @_;
	vsay 'TRACE', "BCE and LDV report process staring...\n";
	bce_create_report $status, $msg;
	ldv_create_report;
	defined $action and $action eq 'exit' and exit;
}
