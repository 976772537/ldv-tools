#!/usr/bin/ruby
require 'rubygems'
require 'active_record'
require 'find'
require 'open3'
require 'logger'
require 'rexml/document'
require 'fileutils'

ENV['LDV_SRVHOME'] ||= File.expand_path("../",File.dirname(__FILE__))
manhome = File.join(ENV['LDV_SRVHOME'],"ldv-manager")

require File.join(manhome,"upload_utils.rb")
ldv_db_connect

# We should connect before we load our data model
require File.join(manhome,"results_model.rb")

# All models were loaded in results_model.rb.  Now we just add a couple of methods that regard loading them from report
#
# Convenience functions are in upload_utils.rb


## Ancillary commands for loading models from XML

class Task
	# Get date and time of a task from a special "timestamp" tag.  It should be set in report-fixup correspondingly!
	def self.process_timestamp_tag(timestamp_tag)
		# List of tags to read
		tags = %w{sec min hour mday mon year wday yday isdst}
		# Read tags into tag->value hash
		d = {}
		tags.each {|tn| d[tn] = (timestamp_tag/tn).to_i}
		# Return date
		DateTime.civil(d['year'], d['mon'], d['mday'], d['hour'], d['min'], d['sec'])
	end

	def self.from_xml(tag)
		# Get parameters that may characterize the task
		task_id = ENV['LDV_TASK_ID'] || tag.field("task_id")
		task_name = ENV['LDV_TASK_NAME'] || tag.field("task_name")
		task_username = ENV['LDV_TASK_USERNAME'] || tag/"username"
		if ENV['LDV_TASK_TIMESTAMP']
			begin
				task_timestamp = DateTime.parse(ENV['LDV_TASK_TIMESTAMP'])
			rescue ArgumentError
				task_timestamp = nil
			end
		elsif tt = tag.elements["timestamp"]
			task_timestamp ||= Task.process_timestamp_tag(tt)
		else
			task_timestamp = nil
		end
		task_description = ENV['LDV_TASK_DESCRIPTION'] || (tag/"description")

		if task_id
			# Get task from database
			task_id = task_id.to_i
			task = Task.find(task_id)
			raise "Couldn't find task for task_id=#{task_id.to_s}" unless task
			if ENV['LDV_TASK_DESCRIPTION']
				task.description = task_description
				task.save
			end
			return task
		end

		if task_name
			# Get task from database or add it there
			task = Task.find_or_create_by_name(task_name)
			raise "Couldn't find or create task for task_name=#{task_name}" unless task
			# Of course, we should re-create the other fields
			task.username = (tag/"username")
			task.timestamp = Task.process_timestamp_tag(tag.elements["timestamp"])
			task.description = task_description
			task.driver_spec = (tag/"driver")
			task.driver_spec_origin = (tag/"driver_origin")
			task.save
			return task
		end

		unless task_username.nil? || task_timestamp.nil?
			# Create task for user/given timestamp
			username = task_username
			timestamp = task_timestamp
			description = task_description
			driver_spec = (tag/"driver")
			driver_spec_origin = (tag/"driver_origin")
			task = Task.find_or_create(:username=>username,:timestamp=>timestamp,:description=>description,:driver_spec=>driver_spec,:driver_spec_origin=>driver_spec_origin)
			raise "Couldn't find or create task for username=#{username.to_s} and timestamp=#{timestamp.to_s} and description=#{description} and driver=#{driver_spec.to_s} with driver_origin=#{driver_spec_origin.to_s}" unless task
			return task
		end

		# No means to create a task found -- okay, then there's no task
		nil
	end
end

class Trace
	# Do not log how these HUGE traces are saved
	def save(validate=true)
		ActiveRecord::Base.silence { super(validate) }
	end

	# Load time statistics for this trace
	def time_from_xml(tag)
		# Tag query-target hash to make code DRY
		query_target = Trace.tools.inject({}) {|hash,kv| hash["#{kv[1]}/time"] = kv[1]; hash }
		query_target["build/time"] = 'build-cmd-extractor'
		# Load time for each target
		query_target.each do |query,target|
			tag.elements.each(query) do |entry|
				times = entry.text.split(':')
				processe.create(:name => target, :pattern => entry.attributes['name'], :time_detailed => times[1], :time_average => times[2])
			end
		end
	end
end

class Stats
	def self.from_xml(entry,do_nulls)
		return nil if do_nulls && !entry

		st = Stats.new
		st.success = (entry/"status") == 'OK'
		st.loc = (entry/"loc").to_i || 0
		entry.elements.each("time") do |tag|
			if tag.attributes['name'] == 'ALL' then st.time=tag.text.to_i else st.time=0 end
		end
		st.description = (entry/"desc")
		st
	end
end

class Source
	# Returns hash of sources found in the directory supplied
	# We will attach sources based on this hash to the relevant traces
	def self.from_dir(dirname)
		return [] unless FileTest.directory? dirname
		file_recs = {}
		Find.find(dirname) do |path|
			unless FileTest.directory?(path)
				# Strip dirname from the file name and save it as database key
				filename = path.gsub(Regexp.new("^#{Regexp.quote(dirname)}\/*"),"")
				file_recs[filename] = Source.new({ :name => filename, :contents => File.open(path, "rb").read })
			end
		end
		file_recs
	end

	# Do not log how these HUGE files are saved
	def save(validate=true)
		ActiveRecord::Base.silence { super(validate) }
	end
end

class Launch
	def self.init_global_params(a)
		@@driver_origin = a[:driver_origin]
		@@driver_name = a[:driver_name]
		@@git_tag = a[:git_tag]
		@@global_verifier = a[:global_verifier] || "model-specific"
		@@task = a[:task]
	end

	def self.init_from_xml(ld,launch=nil)
		launch ||= Launch.new

		# Get parameters from XML
		kernel_name = ld.attributes['kernel']
		kernel = Environment.find_or_create_by_version(kernel_name)

		local_driver_name = ld.attributes['driver_name'] || @@driver_name
		raise "Driver name is empty for ld #{ld.attributes['id']}!" if local_driver_name.nil? || local_driver_name.empty?
		driver = Driver.find_or_create(:name=>local_driver_name,:origin=>@@driver_origin)

		rule_model_name = ld.attributes['model']
		if rule_model_name && !rule_model_name.empty?
			rule_model = Rule_Model.find_or_create_by_name(rule_model_name)
		else
			rule_model = nil
		end

		if ld.attributes['module_name'] || ld.attributes['main']
			# If we have only "module_name" it may be a module, in which no names were found.  We should add this to the database anyway, but just insert an empty string instead of main name.
			main_name = ld.attributes['main'] || ''
			# If we have only "main", but no "module name" specified, we fail!
			# FIXME just like the main above if it's necessary
			module_name = ld.attributes['module_name'] or raise "module_name attribute is empty for ld #{ld.attributes['ref']}.  Fix ldv-upload or reporter!"
			scenario = Scenario.find_or_create(:driver_id=>driver.id,:executable=>module_name,:main=>main_name)
		else
			scenario = nil
		end

		toolset = Toolset.find_or_create_by_version_and_verifier(@@git_tag,@@global_verifier)

		# Update launch with the parameters gotten
		launch.driver = driver
		launch.environment = kernel
		launch.toolset = toolset
		launch.rule_model = rule_model
		launch.scenario = scenario
		launch.task = @@task
		launch
	end

	# Parse current LD tag and select from database the relevant master launches.  Master launches are those with no scenario or trace identifiers; they're used in "LDV online" to check if the launch is running or have already finished.
	# The block can "reject" current launch--i.e. if the block is true (for an _unsaved_ launch record it takes), then the function returns no launches.
	def self.master_launches_for_xml(ld)
		l = Launch.init_from_xml(ld)

		return [] if yield(l)

		unless l.rule_model.nil?
			[Launch.first(:conditions => { :driver_id=>l.driver, :environment_id=>l.environment, :rule_model_id=>l.rule_model, :scenario_id=>nil, :task_id=>l.task})].compact
				# NOTE: we use compact to return an empty list without nils
		else
			# If rule_model is unspecified, we should update all relevant records
			Launch.all(:conditions => { :driver_id=>l.driver, :environment_id=>l.environment, :scenario_id=>nil, :task_id=>l.task})
		end
	end

end

#Unpack and load document
tmpdir=`mktemp -d`.chomp
paxname = ARGV[0] or raise "Specify the package name, please"
paxname = File.expand_path(paxname)
Dir.chdir(tmpdir) do |dir|
	# Unpack to temporary dir
	Kernel.system("pax","-r","-f",paxname) or raise "pax didn't work."
end
$stderr.write "Unpacked to: #{tmpdir}\n"
# Get report name
filenames = Dir.glob(File.join(tmpdir,'*.report.xml'))
raise "Only one report in the archive given should match *.report.xml pattern!  These found: #{filenames.join(",")}" if filenames.size != 1

filename = filenames[0]

# Load document
doc = REXML::Document.new File.new(filename)

launch_info_tag = doc.elements["reports/launch_info"]

driver_name = launch_info_tag.field("driver")
driver_origin = launch_info_tag.field("driver_origin")
git_tag = launch_info_tag.field("tag")

# Get verifier name
global_verifier = launch_info_tag.field("globalverifier")

# Create current task unless it's already added
task = Task.from_xml(launch_info_tag.elements["task"])

# Fetch dources (due to not very beautiful structure of the output reports, the sources are fetched beforehand).
sources_dir = File.join(tmpdir,"sources/")
sources={}
sources_for_kernel={}
unless sources_dir.empty?
	# If sources dir is not empty, then we ignore its value and fetch source code files from sources/ dir of the unpacked package
	# We do not descend into sources firecotry and we don't try to separate the files there, as they aren't made for this purpose.
	sources = Source.from_dir(File.join(sources_dir))
end

# Traces will be taken from this folder
traces_dir = File.join(tmpdir,"traces")

# Records, for which master status is already set up
class MasterStats
	def initialize
		@fixed = Hash.new
	end
	def fix(driver,kernel,rule)
		@fixed["#{driver}:#{kernel}:#{rule}"] = true
	end

	def lookup(driver,kernel,rule)
		@fixed.include? "#{driver}:#{kernel}:#{rule}"
	end
end
masters = MasterStats.new

Launch.init_global_params(:driver_name => driver_name, :driver_origin=>driver_origin, :git_tag => git_tag, :global_verifier => global_verifier, :task => task)

doc.elements.each("reports/ld") do |ld|
	puts "Uploading ld #{ld.attributes['ref'] || 'UNKNOWN! ref is not set!'}..."
	launch = Launch.init_from_xml(ld)
	#Get status, and if it's "failed" skip the rest
	status = (ld.field("ldv_status") || "OK").downcase
	if status == "failed"
		launch.scenario = nil

		launch = launch.load_on_duplicate_key

		launch.status = status
		launch.trace = nil

		# Because of :autosave property, recursively saves all records
		launch.save or $stderr.write "VALIDATION ERROR: #{launch.errors.full_messages.join("\n")}\n"
		masters.fix(kernel_name,local_driver_name,rule_model_name)
		next
	end

	trace = Trace.new
	#verdict
	verdict = (ld/"verdict" || 'unknown').downcase
	unsafe = verdict=="unsafe"
	trace.result=verdict
	trace.result='unknown' if verdict.empty?

	if unsafe
		# Get sources
		# Now sources are matched with traces inside the XML file
		unless (source_files = ld.elements.collect("sourcefile") {|tag| tag.text}).empty?
			# We use +clone+ to keep records in sources[] array unsaved.  If we didn't use clone, records in sources[] array would be re-saved by the subsequent calls, and each source file would end up being assigned to only one trace
			source_files.each {|fname| trace.sources << sources[fname].clone }
		else
			$stderr.write "No <sourcefile> tags for ld #{ld.attributes['ref']}!  Adding all sources to this trace...\n"
			# See above about usage of +clone+
			sources.values.each {|src| trace.sources << src.clone }
		end

		# Get trace itself
		if trace_fname = ld/"trace"
			trace_abs_fname=File.join(traces_dir,trace_fname)
			puts "Trying to find trace in #{trace_fname}"
			trace.error_trace = IO.read(trace_abs_fname) if File.exists?(trace_abs_fname)
		end
	end
	# We assume that if there's no report for a tool, it should not be loaded
	do_nulls = true
	# Load stats from XML
	Trace.tools.each do |dbname,tag|
		stats = Stats.from_xml(ld.elements[tag],do_nulls)
		trace.send("#{dbname}=",stats)
	end

	# Run scripts that check for problems
	Trace.tools.each do |tool,v|
		if tool_stat = trace.send(tool)
			tool_stat.calc_problems(File.join(manhome, "problems", tool))
		end
	end

	# Build is handled in a special way (because it's an attribute of the whole task, not just this launch)
	build = Stats.from_xml(doc.elements["reports/build[@kernel=\"#{ld.attributes["kernel"]}\"]"],false)
	trace.build = build
	# We should also get verifier from RCV, if it was run
	ld.elements.inject("rcv",false) do |seen, rcv_tag|
		raise "Two <rcv> tags in ld #{ld.attributes['ref']}?" if seen
		trace.verifier = rcv_tag.attributes['verifier']
		true	#Return that we've seen this element; this will make the next iteration fail
	end
	# Assign a primary key
	launch = launch.load_on_duplicate_key
	launch.trace = trace
	launch.status = "finished"

	# Because of :autosave property, recursively saves all records
	launch.save or $stderr.write "VALIDATION ERROR: #{launch.errors.full_messages.join("\n")}\n"

	launch.trace.time_from_xml(ld)
end

# Report build errors
# A build error is a <build> command with FAILED status.
doc.elements.each('reports/build')  do |build_fail_tag|
	next unless (build_fail_tag/"status").downcase == "failed"
	launch = Launch.init_from_xml(build_fail_tag)

	# Create a pseudo-trace
	build = Stats.from_xml(build_fail_tag,false)
	trace = Trace.new
	trace.result='unknown'
	trace.build = build
	launch.trace = trace
	launch.status = 'finished'

	launch = launch.load_on_duplicate_key

	# Because of :autosave property, recursively saves all records
	launch.save or $stderr.write "VALIDATION ERROR: #{launch.errors.full_messages.join("\n")}\n"
	# TODO: upload time of a failed build!
end

# Update status of special tasks that have driver, kernel and rule set, but don't have any model
# Let's track already processed items to save db queries
puts "Setting up master launches..."
doc.elements.each("reports/ld") do |ld|
	# We select all relevant launches but reject them on the basis of if they're already "fixed" in masters table--i.e. were uploaded as failed
	launches = Launch.master_launches_for_xml(ld) { |l| masters.lookup(l.environment.version,l.driver.name,(l.rule_model.nil?? "nil" : l.rule_model.name)) }
	launches.each do |launch|
		launch.status = 'finished'
		# Because of :autosave property, recursively saves all records
		launch.save or $stderr.write "VALIDATION ERROR: #{launch.errors.full_messages.join("\n")}\n"
		masters.fix(launch.environment.version,launch.driver.name,(l.rule_model.nil?? "nil" : l.rule_model.name))
	end
end

# Remove temporary directory on success (keep it if something failed, we might want to examine it!)
FileUtils.remove_dir(tmpdir)

