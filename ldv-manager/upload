#!/usr/bin/ruby
require 'rubygems'
require 'active_record'
require 'hpricot'
require 'find'
require 'open3'

ActiveRecord::Base.establish_connection(
	:adapter  => 'mysql',
	:database => ENV['LDVDB'],
	:username => ENV['LDVUSER'],
	:password => ENV['LDVDBPASSWD'],
	:host     => (ENV['LDVDBHOST'] || 'localhost')
)
ActiveRecord::Base.logger = Logger.new(STDERR)

# Define models

class Environment < ActiveRecord::Base
end

class Driver < ActiveRecord::Base
end

class Rule_Model < ActiveRecord::Base
end

class Toolset < ActiveRecord::Base
end

class Scenario < ActiveRecord::Base
	belongs_to :driver
end

class Launch < ActiveRecord::Base
	belongs_to :driver, :autosave => true
	belongs_to :toolset, :autosave => true
	belongs_to :environment, :autosave => true
	belongs_to :rule_model, :class_name=>'Rule_Model', :autosave => true
	belongs_to :scenario, :autosave => true

	# Loads existing record if there exists one with the same primary key
	def load_on_duplicate_key
		if record = Launch.find_by_driver_id_and_toolset_id_and_environment_id_and_rule_model_id_and_scenario_id(driver,toolset,environment,rule_model,scenario)
			record
		else
			self
		end
	end

	belongs_to :task, :autosave => true
	belongs_to :trace, :autosave => true
end

class Task < ActiveRecord::Base
	validates_uniqueness_of :username
	def self.from_xml(tag)
		unless (tag/"task_id").empty?
			# Get task from database
			task_id = (tag/"task_id").inner_html.to_i
			return Task.find(task_id)
		end

		unless (tag/"username").empty? || (tag/"timestamp").empty?
			# Create task for user/given timestamp
			username = (tag/"username").inner_html
			timestamp = (tag/"timestamp").inner_html.to_datetime
			return Task.find_or_create_by_username_and_timestamp(username,timestamp)
		end

		# No means to create a task found -- okay, then there's no task
		nil
	end
end

class Trace < ActiveRecord::Base
	has_one :launch

	belongs_to :build, :class_name => 'Stats', :autosave => true
	belongs_to :maingen, :class_name => 'Stats', :autosave => true
	belongs_to :dscv, :class_name => 'Stats', :autosave => true
	belongs_to :ri, :class_name => 'Stats', :autosave => true
	belongs_to :rcv, :class_name => 'Stats', :autosave => true

	has_many :sources, :autosave => true
	has_and_belongs_to_many :problems
end

class Stats < ActiveRecord::Base
	def self.from_xml(entry)
		st = Stats.new
		st.success = (entry/"status").inner_html == 'OK'
		st.loc = (entry/"loc").inner_html.to_i || 0
		st.time = (entry/"time").inner_html.to_i || 0
		st.description = (entry/"desc").inner_html
		st
	end
end

class Source < ActiveRecord::Base
	validates_uniqueness_of :name, :scope => :trace_id
	belongs_to :trace

	# Returns array of sources found in the directory supplied
	def self.from_dir(dirname)
		file_recs = []
		Find.find(dirname) do |path|
			unless FileTest.directory?(path)
				# Strip dirname from the file name and save it as database key
				filename = path.gsub(Regexp.new("^#{Regexp.quote(dirname)}\/*"),"/")
				file_recs << Source.new({ :name => filename, :contents => File.open(path, "rb").read })
			end
		end
		file_recs
	end

	# Do not log how these HUGE files are saved
	def save(validate=true)
		ActiveRecord::Base.silence { super(validate) }
	end
end

class Problem < ActiveRecord::Base
	has_and_belongs_to_many :traces
end

# Unpack and load document
tmpdir=`mktemp -d`.chomp
paxname = ARGV[0] or raise "Specify package name, please"
paxname = File.expand_path(paxname)
Dir.chdir(tmpdir) do |dir|
	# Unpack to temporary dir
	Kernel.system("pax","-r","-f",paxname) or raise "pax didn't work."
end
# Get report name
filenames = Dir.glob(File.join(tmpdir,'*.report.xml'))
raise "Only one report in the archive given should match *.report.xml pattern!  These found: #{filenames.join(",")}" if filenames.size != 1

filename = filenames[0]
sources_dir = File.join(tmpdir,"sources/")

# Load document
doc = open(filename) { |f| Hpricot(f) }

driver_name = (doc/"reports/launch_info/driver").inner_html
driver_origin = (doc/"reports/launch_info/driver_origin").inner_html
git_tag = (doc/"reports/launch_info/tag").inner_html

# Create current task unless it's already added
task = Task.from_xml(doc/"reports/launch_info")

sources = Source

(doc/"ld").each do |ld|
	kernel_name = ld.attributes['kernel']
	kernel = Environment.find_or_create_by_version(kernel_name)

	driver = Driver.find_or_create_by_name_and_origin(driver_name,driver_origin)
	# How it identify sources.
	# TODO: For now it's always zero, since reporting about in-kernel drivers is not fully implemented..
	driver_sources_id = '0'

	rule_model_name = ld.attributes['model']
	rule_model = Rule_Model.find_or_create_by_name(rule_model_name)

	scenario = Scenario.find_or_create_by_driver_id_and_executable_and_main(driver.id,ld.attributes['ref'],ld.attributes['main'])

	unless sources_dir.empty?
		# If sources dir is not empty, then we ignore its value and fetch source code files from sources/ dir of the unpacked package
		sources = Source.from_dir(File.join(sources_dir, kernel_name, driver_sources_id, rule_model_name))
	else
		sources = []
	end

	trace = Trace.new
	#verdict
	trace.result = (ld/"verdict").inner_html.downcase
	#trace -- read the whole trace from file
	if (trace_tag = ld/"trace") && (! (trace_fname=trace_tag.inner_html).empty?) && (File.exists?(trace_fname))
		trace.error_trace = IO.read(trace_fname)
	end
	#Tools
	tools = {
		'maingen' => 'drv-env-gen',
		'dscv' => 'dscv',
		'ri' => 'rule-instrumentor',
		'rcv' => 'rcv',
	}
	# Load stats from XML
	tools.each do |dbname,tag|
		stats = Stats.from_xml(ld/tag)
		trace.send("#{dbname}=",stats)
	end

	# Run scripts that check for problems
	tools.each do |tool,v|
		scripts_dir = File.join(File.dirname(__FILE__), "problems", tool)
		Find.find(scripts_dir) do |file|
			if !FileTest.directory?(file) && FileTest.executable?(file)
				# Run the script and get its output
				Open3.popen3(file) do |cin,cout,cerr|
					# Send description to the checker
					cin.write( trace.send(tool).description )
					cin.close
					cout.each {|line| trace.problems << Problem.find_or_create_by_name(line) }
					cerr.each {|errln| $stderr.puts errln}
				end
			end
		end
	end

	# Build is handled in a special way
	build = Stats.from_xml(doc/"build[@kernel=\"#{kernel_name}\"")
	trace.build = build

	trace.sources = sources

	# Save trace to DB
	launch = Launch.new

	# Assign a primary key
	launch.driver = driver
	launch.environment = kernel
	launch.toolset = Toolset.find_or_create_by_version_and_verifier(git_tag,(ld/"rcv")[0].attributes['verifier'] || 'blast')
	launch.rule_model = rule_model
	launch.scenario = scenario

	launch = launch.load_on_duplicate_key

	launch.trace = trace
	launch.task = task

	# Because of :autosave property, recursively saves all records
	launch.save
end



