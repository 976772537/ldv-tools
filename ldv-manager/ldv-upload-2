#! /usr/bin/perl -w


use XML::Simple;
use DBI;
use English;
use FindBin;
use Env qw(LDVDBHOST LDVDB LDVUSER LDVDBPASSWD LDV_TASK_NAME LDV_UPLOAD_DEBUG LDV_DEBUG);
use Getopt::Long qw(GetOptions);
Getopt::Long::Configure qw(posix_default no_ignore_case);
use strict;
use IO::Handle;

# Add some local Perl packages.
use lib("$FindBin::RealBin/../shared/perl");

# Add some nonstandard local Perl packages.
use LDV::Utils qw(vsay print_debug_warning print_debug_normal print_debug_info
  print_debug_debug print_debug_trace print_debug_all get_debug_level
  check_system_call);

################################################################################
# Subroutine prototypes.
################################################################################

sub connect_to_db();

sub parse_command_line();

sub get_xml_file($);

sub finish_upload;

################################################################################
# Global variables.
################################################################################

# TODO: don't use global variables - use (hash for) function parameters, see etv/modules/ETV/Library.pm as example.
# The default database host and password. They're used when no host is specified
# through the environment variables.
my $db_host = $LDVDBHOST || 'localhost';
my $db_password = $LDVDBPASSWD || '';

# Command-line options.
my @uploaded_files = ();

my $is_xml = 0; # If true then xml format will be expected instead of pax.

# Data base handler.
my $dbh;

#my $problem_dir = "/home/vitaly/ldv-inst/ldv-manager/problems/";

# Name of the tmp directory for extracting pax file.
my $tmpdir = '';

################################################################################
# Main section.
################################################################################

get_debug_level("ldv-upload", $LDV_DEBUG, $LDV_UPLOAD_DEBUG);

parse_command_line();

connect_to_db();

for (@uploaded_files)
{
	my $xml_file = get_xml_file($_);

	my $xml_data = parse_xml_file(xml_file => $xml_file);

	upload(xml_data => $xml_data);
	
	# TODO: sort this after adding END section
	if ($tmpdir ne '')
	{
		chdir ("../");
		`rm -rf $tmpdir`;
		print_debug_debug("Tmp directory $tmpdir has been deleted");
	}
}
finish_upload();

################################################################################
# Subroutines.
################################################################################

sub connect_to_db()
{
	# connect to DB
	$dbh = DBI->connect("DBI:mysql:$LDVDB:$LDVDBHOST", $LDVUSER, $db_password)
		or die("Can't connect to the database: $DBI::errstr");
	print_debug_normal("Connection to the data base $LDVDB has been established");
	print_debug_normal("host $LDVDBHOST");
	print_debug_normal("user $LDVUSER");
}

# Format: <upload> <uploaded_file> [options] -- <uploaded_files>.
# In case of any error help will be printed and execution of the program will be stopped.
sub parse_command_line()
{
	# Getting first argument as uploaded file.
	push (@uploaded_files, shift(@ARGV)) or help();
	
	my $print_help = 0;
	
# TODO: implement a password prompt - see first message at http://www.perlmonks.org/?node_id=301453.
	# Parsing options.
	GetOptions('help|h' => \$print_help,
			   'xml' => \$is_xml)
	or help();
	
	# Print help.
	help() if ($print_help);
	
	# Get options after "--" as other uploaded files.
	foreach (@ARGV)
	{
		push (@uploaded_files, $_) or help();
	}
	
	print_debug_debug("Parsing command line has been completed");
	print_debug_debug("Number of uploaded files is ".@uploaded_files);
	foreach (@uploaded_files)
	{
		print_debug_debug("Uploaded file is '$_'");
	}
	print_debug_debug("Xml format expected") if $is_xml;
}

# Print help and exit.
sub help()
{
	print(STDERR << "EOM");

NAME
  $PROGRAM_NAME: the tool is intended to upload results to the database.

SYNOPSIS
  $PROGRAM_NAME uploaded_file [option...]

OPTIONS

  -h, --help
    Print this help and exit with a error.
  --xml
    Xml format will be uploaded.

ENVIRONMENT VARIABLES

  LDV_TASK_NAME
    The name of the task, which is uploaded to the data base.
    Uses when a few files should be uploaded as one task.

  LDVDBHOST, LDVDB, LDVUSER, LDVDBPASSWD
    Keeps settings (host, database, user and password) for connection
    to the database. Note that LDVDB and LDVUSER must always be
    presented!

EOM

	exit(1);
}

# Actions which should be completed in case of any errors or after finishing uploading.
sub finish_upload()
{
# TODO: this function doesn't acquire parameters anywhere.
	# Print error message.
	foreach my $text (@_)
	{
		print ($text);
	}
	
	# Delete tmp directory.
	if ($tmpdir ne '')
	{
		`rm -rf ../$tmpdir`;
		print_debug_debug("Tmp directory $tmpdir has been deleted");
	}
	
# TODO: also move this to the END section as removing $tmpdir.
	# Disconnect from data base.
	$dbh->disconnect;
	print_debug_normal("Disconnecting from data base");
}

# If option "--xml" was specified then the xml file is uploaded file.
# Otherwise uploaded file will be concidered as pax file, extracted in tmp directory, and xml file will be there.
sub get_xml_file()
{
	my $uploaded_file = shift;
	my $xml_file;
	if ($is_xml) # "--xml".
	{
		print_debug_debug("Uploaded file will be considered as xml file");
		$xml_file = $uploaded_file;
	}
	else
	{
		print_debug_debug("Uploaded file will be considered as pax file");
# TODO: check return codes of each command like "mktemp", "pax", "find" etc. Use "system" for that, see http://perldoc.perl.org/functions/system.html.
# TODO: remove $tmpdir whenever ldv-upload-2 exits. See END at http://perldoc.perl.org/perlmod.html.
		# Create tmp directory '.XXXXXXXXXX'.
		$tmpdir = `mktemp -d --tmpdir=. .XXXXXXXXXX`;
		$tmpdir =~ s/\n//g;
		print_debug_debug("Tmp directory $tmpdir has been created");
		
# TODO: don't use "chdir", see "directory" in "man pax".
		# Extract pax file into created directory.
		chdir ($tmpdir);
		`pax -O -r -f ../$uploaded_file`;
		print_debug_debug("Pax archive has been extracted into $tmpdir");

		# Get xml file from there.
		$xml_file = `find *.xml`;
# TODO: use "chomp".
		$xml_file =~ s/\n//g;
		print_debug_debug("Xml file $xml_file was found in $tmpdir");
	}
	return $xml_file;
}

# Parses xml file with LibXML and returns hash.
sub parse_xml_file 
{
	my $info = {@_};
	my $stats_fname = $info->{xml_file};
	
	my $time_before = time;
	print_debug_normal("Start parsing xml file $stats_fname");
	
	# Set LibXML perser.
	$XML::Simple::PREFERRED_PARSER = 'XML::LibXML::SAX';
	
	# Parse.
	my $xml = new XML::Simple;
	my $data = $xml->XMLin($stats_fname, SuppressEmpty => 1, ForceArray => ['ld', 'sources', 'time']); # get data structure for xml file representating

	$time_before = time - $time_before;
	print_debug_normal("Parsing xml file $stats_fname has been completed in $time_before seconds");
	
	# Delete 'cc' section from hash.
	delete $data->{cc};
	return $data;
}

sub upload
{
	my $info = {@_};
	my $xml_data = $info->{xml_data};

# TODO: replace all work with file handlers with something like suggested there http://www.perlmonks.org/?node_id=1058305.
	my $read_hdl;
	my $write_hdl;
	pipe ($read_hdl, $write_hdl) or die "Can't create pipe!";
	
	# Set aftoflash for created pipe so it could work parallel.
	my $old_fh = select($write_hdl);
	$| = 1;
	select($old_fh);
	
	if (fork() == 0) #child - create thread for launching kb-recalc.
	{
		close $write_hdl;
		close (STDOUT);
		close (STDERR);
		STDIN->fdopen($read_hdl, 'r');
		exec ("kb-recalc.pl --init-cache --new-launch");
		exit(1);
	}
	
	# Back to parent process.
	close $read_hdl;
	
	# Unique ids.
	my $environment_id;
	my $task_id;
	
	# Unique names.
	my $version; # Kernel version (from section <build>) - unique - ignored from <ld> - parameter 'envs'.
	my $driver; # Driver name - parameter 'drivers' - unique.
	my $driver_origin; # Same as before.
	my $username; # Unique.
	my $timestamp; # Unique.
	my $task_name; # LDV_TASK_NAME - unique.
	
# TODO: Move initialization made below to variables declared above. 
	# Getting unique values from xml file.
	$version = $xml_data->{build}->{kernel};
	$driver = $xml_data->{launch_info}->{driver};
	$driver_origin = $xml_data->{launch_info}->{driver_origin};
	$username = $xml_data->{launch_info}->{task}->{username};
# TODO: fix it in ldv-manager/report-fixup and then fix it here.
	my $month = "";
	if ($xml_data->{launch_info}->{task}->{timestamp}->{mon} < 10)
	{
		$month = "0"."$xml_data->{launch_info}->{task}->{timestamp}->{mon}";
	}
	else
	{
		$month = "$xml_data->{launch_info}->{task}->{timestamp}->{mon}";
	}
	$timestamp = $xml_data->{launch_info}->{task}->{timestamp}->{year}."-".$month."-".
			$xml_data->{launch_info}->{task}->{timestamp}->{mday}." ".$xml_data->{launch_info}->{task}->{timestamp}->{hour}.":".
			$xml_data->{launch_info}->{task}->{timestamp}->{min}.":".$xml_data->{launch_info}->{task}->{timestamp}->{sec};
	$task_name = $LDV_TASK_NAME || '';
	
# TODO: move this debug printing to initialization as well. 
	print_debug_debug("Unique values");
	print_debug_debug("version=$version");
	print_debug_debug("driver=$driver");
	print_debug_debug("driver_origin=$driver_origin");
	print_debug_debug("username=$username");
	print_debug_debug("timestamp=$timestamp");
	print_debug_debug("task_name=$task_name");
	
	my $tmp_res; # Result for DB queries.
	
	# Lock DB.
	print_debug_normal("Locking data base");
	sql_query(query => "LOCK TABLES environments WRITE, drivers WRITE, rule_models WRITE, toolsets WRITE, scenarios WRITE, tasks WRITE, launches WRITE, traces WRITE, sources WRITE, stats WRITE, processes WRITE, problems WRITE, problems_stats WRITE\n");
	
	# Start transaction.
	print_debug_normal("Starting commit");
	$dbh->begin_work;

	print_debug_normal("Processing unique values");
	# Processing tasks table.
	$tmp_res = sql_select(query => "SELECT id FROM tasks WHERE (tasks.name = '$task_name') LIMIT 1;");
	if ($tmp_res == 0 || $task_name eq '')
	{
		$tmp_res = sql_insert(query => "INSERT INTO tasks (username, timestamp, driver_spec, driver_spec_origin, name) VALUES ('$username', '$timestamp', '$driver', '$driver_origin', '$task_name');");
	}
	$task_id = $tmp_res; # FK for task.
	
# TODO: much better to write $var = sql_select(...) || sql_insert(...) here and below. 
	# Processing environments table.
	$tmp_res = sql_select(query => "SELECT id FROM environments WHERE (environments.version = '$version') LIMIT 1;");
	if ($tmp_res == 0)
	{
		$tmp_res = sql_insert(query => "INSERT INTO environments (version) VALUES ('$version');");
	}
	$environment_id = $tmp_res; # FK for environment.
	
	# Processing drivers table.
	$tmp_res = sql_select(query => "SELECT id FROM drivers WHERE (drivers.name = '$driver') AND (drivers.origin = '$driver_origin') LIMIT 1;");
	if ($tmp_res == 0)
	{
		$tmp_res = sql_insert(query => "INSERT INTO drivers (name, origin) VALUES ('$driver', '$driver_origin');");
	}
	
	# Ids for launches.
	my $cur_driver_id;
	my $cur_scenario_id;
	my $cur_launch_id;
	my $cur_trace_id;
	my $cur_stats_id;
	my $cur_toolset_id;
	my $cur_model_id;
	
	# Get max ids.
	$cur_trace_id = sql_select(query => "SELECT max(id) FROM traces;");
	$cur_stats_id = sql_select(query => "SELECT max(id) FROM stats;");
	
	print_debug_normal("Processing data for each launch. This may take some time..");
	
# TODO: try to upload a build FAILED. "if" below is useless since there is no else... 
	if ($xml_data->{ld}) # Check if there is ld section (or there is build FAILED).
	{
		foreach my $arg (values $xml_data->{ld}) 
		{
			# Variables for launches.
			my $cur_main = $arg->{main} || '';
			my $cur_module = $arg->{module_name} || '';
			my $cur_verdict = $arg->{verdict} || 'UNKNOWN'; # UNKNOWN if not SAFE or UNSAFE.
			my $cur_verifier = $arg->{verifier} || '';
# TODO: as far as I know old scripts upload NULL in this case.
			my $cur_model = $arg->{model} || 'Fail before RI'; # Specific name if there was no enty point.
		
			# For UNSAFEs - error trace and source files.
			my $cur_trace = $arg->{trace} || '';
			my $cur_sources = $arg->{sourcefile} || '';
		
			# Each component of luanch.
			my $cur_build = $arg->{build} || '';
			my $cur_deg = $arg->{'drv-env-gen'} || '';
			my $cur_dscv = $arg->{dscv} || '';
			my $cur_ri = $arg->{'rule-instrumentor'} || '';
			my $cur_rcv = $arg->{rcv} || '';
		
			# Incrementing these values for each launch (not auto increment).
			$cur_trace_id++;
			$cur_stats_id++;
		
			# Processing toolsets table.
			$tmp_res = sql_select(query => "SELECT id FROM toolsets WHERE (toolsets.verifier = '$cur_verifier') LIMIT 1;");
			if ($tmp_res == 0)
			{
				$tmp_res = sql_insert(query => "INSERT INTO toolsets (verifier, version) VALUES ('$cur_verifier', 'current');");
			}
			$cur_toolset_id = $tmp_res;
		
			# Processing rule_models table.
			$tmp_res = sql_select(query => "SELECT id FROM rule_models WHERE (rule_models.name = '$cur_model') LIMIT 1;");
			if ($tmp_res == 0)
			{
				$tmp_res = sql_insert(query => "INSERT INTO rule_models (name) VALUES ('$cur_model');");
			}
			$cur_model_id = $tmp_res;
		
			# Processing drivers table.
			$tmp_res = sql_select(query => "SELECT id FROM drivers WHERE (drivers.name = '$cur_module' and drivers.origin = '$driver_origin') LIMIT 1;");
			if ($tmp_res == 0)
			{
				$tmp_res = sql_insert(query => "INSERT INTO drivers (name, origin) VALUES ('$cur_module', '$driver_origin');\n");
			}
			$cur_driver_id=$tmp_res;
		
			# Processing scenarios table.
			$cur_scenario_id = sql_insert(query => "INSERT INTO scenarios (driver_id, executable, main) VALUES ($cur_driver_id, '$cur_module', '$cur_main');\n");
		
			# Processing launches table.
			$cur_launch_id = sql_insert(query => "INSERT INTO launches (driver_id, toolset_id, environment_id, rule_model_id, scenario_id, task_id, trace_id) VALUES ($cur_driver_id, '$cur_toolset_id', '$environment_id', '$cur_model_id', $cur_scenario_id, '$task_id', $cur_trace_id);\n");

# TODO: check what old script uploads if there is not an error trace (not an UNSAFE).
			# Error trace file.
			my $et = '\'\'';
			if ($cur_verdict eq "UNSAFE")
			{
# TODO: always check open return code!
				open TRACE_FILE, "<", "traces/$cur_trace";
				my @error_trace = <TRACE_FILE>;
				close TRACE_FILE;
				$et = $dbh->quote(join ("\n", @error_trace));
			}
		
			# Processing traces table.
			sql_query(query => "INSERT INTO traces (id, launch_id, result, error_trace, verifier, build_id, maingen_id, dscv_id, ri_id, rcv_id) VALUES ($cur_trace_id, '$cur_launch_id', '$cur_verdict', $et, '$cur_verifier', $cur_stats_id, $cur_stats_id+1, $cur_stats_id+2, $cur_stats_id+3, $cur_stats_id+4);\n");
		
			# Source files.
			if ($cur_sources ne '')
			{
				foreach my $source (values $cur_sources)
				{
					# Trace file.
					open SOURCE_FILE, "<", "sources/$source";
					my @source_text = <SOURCE_FILE>;
					close SOURCE_FILE;
					my $src = $dbh->quote(join ("\n", @source_text));
				
					# Processing sources table.
					sql_query(query => "INSERT INTO sources (trace_id, name, contents) VALUES ('$cur_trace_id', '$source', $src);\n");
				}
			}
			
			# Send id of unsafe launch to the child process (run kb-recalc for this id).
			if ($cur_verdict eq "UNSAFE")
			{
# TODO: why don't use "print $stream $id"?
				print $write_hdl scalar "$cur_launch_id\n";
			}
			
			# Processing stats, processes, problems, problems_stats tables for each component.
# TODO: make a common function for all components since below almost everything is the same.
			# Processing component 'biuld'.
			if ($cur_build ne '')
			{
				my $cur_status = 1;
				if ($cur_build->{status})
				{
					$cur_status = 0 if $cur_build->{status} eq "FAILED";
				}
				my $cur_time = '0';
# TODO: may be NULL is uplouded if there is not any description?
				my $cur_desc = '\'\'';
				if ($cur_build->{desc})
				{
					$cur_desc = $cur_build->{desc};
					$cur_desc = $dbh->quote($cur_desc);
				}
				sql_query(query => "INSERT INTO stats (id, trace_id, kind, success, time, description) VALUES ($cur_stats_id, '$cur_trace_id', 'build', '$cur_status', '$cur_time', $cur_desc);\n");
# TODO: pass a hash reference "{...}", not an array.
				add_processes(old_time => $cur_build->{time}, trace_id => $cur_trace_id, component => 'build-cmd-extractor');
				if ($cur_verdict eq "UNKNOWN")
				{
# TODO: read problems from files via Perl eval rather then put it to the script.
					#add_problems(file => "$problem_dir/build/build", desc => $cur_desc, stats_id => $cur_stats_id);
					add_problems_local(component => "build", desc => $cur_desc, stats_id => $cur_stats_id);
				}
			}
		
			# Processing component 'deg'.
			$cur_stats_id++;
			if ($cur_deg ne '')
			{
				my $cur_status = 0;
				$cur_status = 1 if $cur_deg->{status} eq "OK";
				my $cur_time = '0';
				my $cur_desc = '\'\'';
				if ($cur_deg->{desc})
				{
					$cur_desc = $cur_deg->{desc};
					$cur_desc = $dbh->quote($cur_desc);
				}
				my $cur_loc = $cur_deg->{loc};
				sql_query(query => "INSERT INTO stats (id, trace_id, kind, success, loc, time, description) VALUES ($cur_stats_id, '$cur_trace_id', 'maingen', '$cur_status', '$cur_loc', '$cur_time', $cur_desc);\n");
			
				add_processes(old_time => $cur_deg->{time}, trace_id => $cur_trace_id, component => 'drv-env-gen');
			}
		
			# Processing component 'dscv'.
			$cur_stats_id++;
			if ($cur_dscv ne '')
			{
				my $cur_status = 0;
				$cur_status = 1 if $cur_dscv->{status} eq "OK";
				my $cur_time = '0';
				my $cur_desc = '\'\'';
				if ($cur_dscv->{desc})
				{
					$cur_desc = $cur_dscv->{desc};
					$cur_desc = $dbh->quote($cur_desc);
				}
				sql_query(query => "INSERT INTO stats (id, trace_id, kind, success, time, description) VALUES ($cur_stats_id, '$cur_trace_id', 'dscv', '$cur_status', '$cur_time', $cur_desc);\n");
			
				add_processes(old_time => $cur_dscv->{time}, trace_id => $cur_trace_id, component => 'dscv');
				if ($cur_verdict eq "UNKNOWN")
				{
					#add_problems(file => "$problem_dir/dscv/problems", desc => $cur_desc, stats_id => $cur_stats_id);
					add_problems_local(component => "dscv", desc => $cur_desc, stats_id => $cur_stats_id);
				}
			}
		
			# Processing component 'ri'.
			$cur_stats_id++;
			if ($cur_ri ne '')
			{
				my $cur_status = 0;
				$cur_status = 1 if $cur_ri->{status} eq "OK";
				my $cur_time = '0';
				my $cur_desc = '\'\'';
				if ($cur_ri->{desc})
				{
					$cur_desc = $cur_ri->{desc};
					$cur_desc = $dbh->quote($cur_desc);
				}
				sql_query(query => "INSERT INTO stats (id, trace_id, kind, success, time, description) VALUES ($cur_stats_id, '$cur_trace_id', 'ri', '$cur_status', '$cur_time', $cur_desc);\n");
			
				# ri - processes.
				add_processes(old_time => $cur_ri->{time}, trace_id => $cur_trace_id, component => 'rule-instrumentor');
			
				# ri - problems.
				if ($cur_verdict eq "UNKNOWN")
				{
					#add_problems(file => "$problem_dir/ri/aspectator", desc => $cur_desc, stats_id => $cur_stats_id);
					add_problems_local(component => "ri", desc => $cur_desc, stats_id => $cur_stats_id);
				}
			}
		
			$cur_stats_id++;
			# Processing component 'rcv'.
			if ($cur_rcv ne '')
			{
				my $cur_status = 0;
				$cur_status = 1 if $cur_rcv->{status} eq "OK";
				my $cur_time = '0';
				my $cur_desc = '\'\'';
				if ($cur_rcv->{desc})
				{
					$cur_desc = $cur_rcv->{desc};
					$cur_desc = $dbh->quote($cur_desc);
				}
				sql_query(query => "INSERT INTO stats (id, trace_id, kind, success, time, description) VALUES ($cur_stats_id, '$cur_trace_id', 'rcv', '$cur_status', '$cur_time', $cur_desc);\n");
				
				# rcv - processes.
				add_processes(old_time => $cur_rcv->{time}, trace_id => $cur_trace_id, component => 'rcv');
			
				# rcv - problems.
				if ($cur_verdict eq "UNKNOWN")
				{
					#add_problems(file => "$problem_dir/rcv/$cur_verifier", desc => $cur_desc, stats_id => $cur_stats_id);
					#add_problems(file => "$problem_dir/rcv/generic", desc => $cur_desc, stats_id => $cur_stats_id);
					add_problems_local(component => "rcv", desc => $cur_desc, stats_id => $cur_stats_id);
				}
			}
		}
	}
	
# TODO: I guess that unlocking should follow committing. Otherwise there is a race.-
	print_debug_normal ("Unlocking data base");
	sql_query(query => "UNLOCK TABLES;\n");
	
	$dbh->commit;
	print_debug_normal ("Commit has been completed");

	print ("Results were successfully uploaded to database. They can be found at:\n");
	$db_password = 'no' if $db_password eq '';
	print ("http://$db_host:8999/stats/index/profilename/default/name/$LDVDB/user/$LDVUSER/host/$db_host/password/$db_password/\n");

	close $write_hdl;
	wait();
}

# TODO: three functions below always accepts just one argument. So why are hashes passed to them? 
sub sql_select
{
	my $info = {@_};
	my $query = $info->{query};
	chomp($query);
	print_debug_all ($query);
	
	my $db_query = $dbh->prepare($query) or die("Can't prepare a query: " . $dbh->errstr);
	
	$db_query->execute or die("Can't execute a query: " . $dbh->errstr);
	
	my @row = $db_query->fetchrow_array;
	
	return $row[0] || 0;
}

sub sql_insert
{
	my $info = {@_};
	my $query = $info->{query};
	chomp($query);
	print_debug_all ($query);
	
	my $db_query = $dbh->prepare($query) or die("Can't prepare a query: " . $dbh->errstr);
	
	$db_query->execute or die("Can't execute a query: " . $dbh->errstr);
	
	return $db_query->{mysql_insertid};
}

sub sql_query
{
	my $info = {@_};
	my $query = $info->{query};
	chomp($query);
	print_debug_all ($query);
	
	my $db_query = $dbh->do($query) or die("Can't do a query: " . $dbh->errstr);
}

# Adds record in problems and problems_stats for specific component.
sub add_problems
{
	my $info = {@_};
	my $problem_file = $info->{file};
	my $cur_desc = $info->{desc};
	my $cur_stats_id = $info->{stats_id};
	if (fork() == 0)
	{
		my @res = `echo \"$cur_desc\" |  $problem_file`;
		my $tmp_res;
		foreach my $prob (@res)
		{
			chomp($prob);
			next if ($prob =~ /^\s*$/);
			$tmp_res = sql_select(query => "SELECT id FROM problems WHERE problems.name = '$prob' LIMIT 1;");
			if ($tmp_res == 0)
			{
				$tmp_res = sql_insert(query => "INSERT INTO problems (name) VALUES ('$prob');\n");
			}
			#if (sql_select(query => "SELECT * FROM problems_stats WHERE stats_id = $cur_stats_id and problem_id = $tmp_res LIMIT 1;") == 0)
			{
				sql_query(query => "INSERT INTO problems_stats (stats_id, problem_id) VALUES ($cur_stats_id, $tmp_res);\n");
			}
		}
		exit(0);
	}
}

# Adds record in problems and problems_stats for specific component.
sub add_problems_local
{
	my $info = {@_};
	my $component = $info->{component};
	my $cur_desc = $info->{desc};
	my $cur_stats_id = $info->{stats_id};
	my @res = ();
	if ($cur_desc ne '\'\'') # In case of build failed.
	{
		if ($component eq "rcv")
		{
			@res = rcv_problems($cur_desc);
		}
		if ($component eq "ri")
		{
			@res = ri_problems($cur_desc);
		}
		if ($component eq "dscv")
		{
			@res = dscv_problems($cur_desc);
		}
		if ($component eq "build")
		{
			@res = build_problems($cur_desc);
		}
		my $tmp_res;
		foreach my $prob (@res)
		{
			chomp($prob);
			next if ($prob =~ /^\s*$/);
			$tmp_res = sql_select(query => "SELECT id FROM problems WHERE problems.name = '$prob' LIMIT 1;");
			if ($tmp_res == 0)
			{
				$tmp_res = sql_insert(query => "INSERT INTO problems (name) VALUES ('$prob');\n");
			}
			sql_query(query => "INSERT INTO problems_stats (stats_id, problem_id) VALUES ($cur_stats_id, $tmp_res);\n");
		}
	}
}

# Adds record in processes for specific component - time/memory.
sub add_processes
{
	my $info = {@_};
	my $old_time = $info->{old_time};
	my $cur_trace_id = $info->{trace_id};
	my $component = $info->{component};
	if (ref ($old_time) eq 'HASH')
	{
		my %new_time = convert_time(old_time => $old_time);
		foreach my $time_name (keys %new_time)
		{
			sql_query(query => "INSERT INTO processes (trace_id, name, pattern, time_average, time_detailed) VALUES ('$cur_trace_id', '$component', '$time_name', '$new_time{$time_name}', '$new_time{$time_name}');\n");
		}
	}
}

# Function for converting hash from xml file into hash {name_of_time => value}.
sub convert_time
{
	my $info = {@_};
	my $old_time = $info->{old_time};
	my %new_time = ();
	foreach my $arg (keys $old_time)
	{
		# For different format
		next if $arg eq 'name';
		if ($arg eq 'content')
		{
			my $time = 0;
			if ($old_time->{content} =~ /^((\d)*)(.*)$/)
			{
				$time = $1;
			}
			$new_time{'ALL'} = $time;
		}
		next if $arg eq 'content';
		
		my $time = 0;
		if (ref($old_time->{$arg}) eq 'HASH' && $old_time->{$arg}->{content} =~ /^((\d)*)(.*)$/)
		{
			$time = $1;
		}
		$new_time{$arg} = $time;
	}
	return %new_time;
}

#Functions for getting problems names by description.

sub rcv_problems
{
	$\ = "\n";
	$, = "\n";
	my @result;
	foreach (@_)
	{
		chomp;
		/\bexception\b/i and push(@result, "Exception");
		/combining structure and non-structure values/i and push(@result, "BLAST_combinig");
		/Attempt to access a non structure value as a structure/i and push(@result,  "BLAST_LLVM_nonstruct");
		/Memory Limit Exceeded/i and push(@result,  "Out_of_memory");
		/Time Limit Exceeded/i and push(@result,  "Time_limit");
		/Hangup Detected/i and push(@result,  "Hangup_detected");
		/C_System_Descr.initialize: duplicate function name/i and push(@result,  "Dupl_function", "BLAST_frontend");
		/Recursive Call Graph/i and push(@result,  "Recursion");
		/Simplify raised exception End_of_file/i and push(@result,  "Solver");
		/Unary operation on pointer not supported/i and push(@result,  "BLAST_Unsupported", "BLAST_frontend");
		/frontc reported an error/i and push(@result,  "BLAST_Compile", "BLAST_frontend");
		/AlignOfE not handled/i and push(@result,  "BLAST_Unsupported", "BLAST_frontend");
		/convertCilExp: align not handled/i and push(@result,  "BLAST_Unsupported", "BLAST_frontend");
		/SMT sovler answer is strange: \*\*\* Parse Error: .*: syntax error/i and push(@result,  "CVC3 Solver parse error");
		/Errormsg\.Error/i and push(@result,  "Parsing errors");
		/simplemem: temporary needed outside a function/i and push(@result,  "Temp outside func"); 
		/Invalid_argument\("Predicate index is less than zero"\)/ and push(@result,  "Large_int");
		    /SymbolicStore\.Value\.Invalid_access\("Attempt to use Null pointer as a base of offset address"\)/ and push(@result,  "SymStore_Null");
		    /Failure\("hd"\)/ and push(@result,  "Failure_hd");
		/FociInterface.SAT/ and push(@result,  "Blocks_SAT");
		/NoNewPredicatesException/ and push(@result,  "NoNewPredicates");
		/Fatal error: out of memory./ and push(@result,  "Ocaml_OOM");
		    /Error: Global __constr_expr_[0-9]* was already defined at/i and push(@result,  "ConstExpr");
		/Global .* was already defined/ and push(@result,  "Two_globals");
		/error when reading CSIsat output/ and push(@result,  "CSIsat");
		/Error: Cannot find input file/ and push(@result,  "No_file");
		
		/PREPROCESS/ and push(@result,  "CPP_error");
		/CIL ERROR/ and push(@result,  "CIL_parse_error");
		/No entry point or error location found/ and push(@result,   "Main/Label");
		/\ttime exhausted/ and push(@result,   "Time exhausted");
		/\twall time exhausted/ and push(@result,   "Wall time exhausted");
		/memory exhausted/ and push(@result,   "Memory exhausted");
		/killed by signal: (\d+)/ and push(@result,   "Killed by signal $1");
		/killed by signal \(resource manager\): ([1-9]\d*)/ and push(@result,   "Res-manager killed by signal $1");
		/exit code: ([1-9]\d*)/ and push(@result,   "Exit code $1");
		/exit code \(resource manager\): ([1-9]\d*)/ and push(@result,   "Res-manager exit code $1");
		/permissions in cgroup/ and push(@result,   "Permissions in cgroup");
		/need to mount/ and push(@result,   "Cgroup not mounted");
		/VERIFIER SCRIPT ERROR/ and push(@result,   "Script");
	}
	return @result;
}

sub ri_problems
{
	$\ = "\n";
	$, = "\n";
	my @result;
	foreach (@_)
	{
		chomp;
		/error: invalid storage class for function try_module_get/ and push(@result, "<a href =\"http://forge.ispras.ru/issues/380\">bug380:</a> try_module_get");
		/internal compiler error: Segmentation fault/ and push(@result, "Segmentation fault");
		/: error: / and push(@result, "Compile error");
		/: error: LDV: / and push(@result, "LDV error");
		/: warning: / and push(@result, "Warning");
		/: warning: LDV: / and push(@result, "LDV warning");
		/: fatal error: character .* wasn't put to stream/ and push(@result, "<a href=\"http://forge.ispras.ru/issues/349\">Bad_char</a>)");
		/: fatal error: / and push(@result, "Fatal_err");
		/tree node '(.*)' isn't supported/ and push(@result, "<a href=\"http://forge.ispras.ru/issues/1167\">$1</a>");
		# Old interface to Aspectator (aspectator.sh)
		/Aspectator fails on the (.*) stage/ and push(@result, "$1 stage");
		# New interface to Aspectator (cif) 
		/Aspectator failed at '(.*)' stage/ and push(@result, "$1 stage");

		/compiler-core: error: kernel.org: No such file or directory/ and push(@result, "kernel.org");
		/warning: no return statement in function returning non-void/ and push(@result, "No return warn");
		/warning: ISO C90 forbids mixed declarations and code/ and push(@result, "Mixed decls warn");
		/error: implicit declaration of function '(.*)'/ and push(@result, "Implicit decl");

		#drv-env-gen problems
		/error: storage size of '(.*)' isn't known/ and push(@result, "<a href=\"http://forge.ispras.ru/issues/1293\">Storage size</a>");
		/error: implicit declaration of function kmalloc/ and push(@result, "DEG: implicit kmalloc");
		/error: redeclaration of '(.*)' with no linkage/ and push(@result, "DEG: Redeclaration");
		/error: #endif without #if/ and push(@result, "<a href=\"http://forge.ispras.ru/issues/1293\">DEG: ifdefs</a>");
		/error: incompatible types when assigning to type '(.*)' from type '(.*)'/ and push(@result, "<a href=\"http://forge.ispras.ru/issues/553\">DEG: return type</a>");

		# misc (see bug #1360)
		/too few arguments to function 'ldv_check_alloc_flags'/ and push(@result, "<a href=\"http://forge.ispras.ru/issues/1360\">Few_args</a>");
		/'no_instrument_function' attribute applies only to functions/ and push(@result, "<a href=\"http://forge.ispras.ru/issues/1366\">Bad_attr</a>");
		/void value not ignored as it ought to be/ and push(@result, "Void_val");
	}

	return @result;
}

sub dscv_problems
{
	$\ = "\n";
	$, = "\n";
	my @result;
	foreach (@_)
	{
		chomp;
		/No entry points specified/i and push(@result, "No_entries");
	}
	return @result;
}

sub build_problems
{
	$\ = "\n";
	$, = "\n";
	my @result;
	foreach (@_)
	{
		chomp;
		/Compile error/ and  push(@result,  "Compile error");
		/Can\'t find correct Makefile or Kbuild file/ and  push(@result,  "No Makefile or Kbuild file");
		/Can't detect kernel module .* build command/ and  push(@result,  "No modules");
		/Incorrect driver archive type/ and  push(@result,  "Incorrect archive type");
		/Can't detect source type in dir \".*\"/ and  push(@result,  "Can't detect source type in dir");
		/Can't find target\./ and  push(@result,  "Can not find target");
		/Couldn't apply patch/ and  push(@result,  "Error during applying patch");
		/.* - is not a patch or driver archive/ and  push(@result,  "It is not patch or driver archive");
		/No rule to make target/ and  push(@result,  "Not configured");
		/Source type ".*" not supported/ and  push(@result,  "Incorrect source type");
	}
	return @result;
}
