#! /usr/bin/perl -w


use XML::Simple;
use DBI;
use English;
use FindBin;
use Env qw(LDVDBHOST LDVDB LDVUSER LDVDBPASSWD LDV_TASK_NAME LDV_UPLOAD_DEBUG LDV_DEBUG);
use Getopt::Long qw(GetOptions);
Getopt::Long::Configure qw(posix_default no_ignore_case);
use strict;
use IO::Handle;
use File::Slurp;

# Add some local Perl packages.
use lib("$FindBin::RealBin/../shared/perl/modules");

# Add some nonstandard local Perl packages.
use LDV::Utils qw(vsay print_debug_warning print_debug_normal print_debug_info
  print_debug_debug print_debug_trace print_debug_all get_debug_level
  check_system_call);

################################################################################
# Subroutine prototypes.
################################################################################

# Connects to data base.
# args: no.
# retn: data base handler DBI.
sub connect_to_db();

# Parses command line.
# args: no.
# retn: array of upload file names.
sub parse_command_line();

# Prints help and exits with code '1'.
# args: no.
# retn: nothing.
sub help();

# Deletes tmp directory and all it content (if it exists).
# args: no.
# retn: nothing.
sub remove_tmpdir();

# Disconnects from data base.
# args: no.
# retn: nothing.
sub disconnect_from_db();

# Get name of xml file for uploading.
# args: file name from command line.
# retn: xml file name.
sub get_xml_file($);

# Parse xml file.
# args: xml file name.
# retn: parsed hash.
sub parse_xml_file($);

# Upload hash to data base.
# args: parsed hash.
# retn: nothing.
sub upload($$);

# SQL insert query.
# args: sql query.
# retn: id of inserted row.
sub sql_insert($);

# SQL select query.
# args: sql query.
# retn: id of found row or 0.
sub sql_select($);

# SQL query.
# args: sql query.
# retn: nothing.
sub sql_query($);

sub add_problems(%);

sub add_processes(%);

sub init_problems();


################################################################################
# Global variables.
################################################################################

# TODO: don't use global variables - use (hash for) function parameters, see etv/modules/ETV/Library.pm as example.
# The default database host and password. They're used when no host is specified
# through the environment variables.
my $db_host = $LDVDBHOST || 'localhost';
my $db_password = '';

my $is_xml = 0; # If true then xml format will be expected instead of pax.

# Name of the tmp directory for extracting pax file.
my $tmpdir = '';

my %problems_functions;

################################################################################
# Main section.
################################################################################

get_debug_level("ldv-upload", $LDV_DEBUG, $LDV_UPLOAD_DEBUG);

my @uploaded_files = parse_command_line();

%problems_functions = init_problems();

my $dbh = connect_to_db();

for (@uploaded_files)
{
	my $xml_file = get_xml_file($_);

	my $xml_data = parse_xml_file($xml_file);

	upload(xml_data => $xml_data);
	
	remove_tmpdir();
}

################################################################################
# Subroutines.
################################################################################

sub connect_to_db()
{
	# connect to DB
	my $db_handler = DBI->connect("DBI:mysql:$LDVDB:$LDVDBHOST", $LDVUSER, $db_password)
		or die("Can't connect to the database: $DBI::errstr");
	print_debug_normal("Connection to the data base $LDVDB has been established");
	print_debug_normal("Host name is: $LDVDBHOST");
	print_debug_normal("User name is: $LDVUSER");
	if ($db_password eq '')
	{
		print_debug_normal("Using password: NO");
	}
	else
	{
		print_debug_normal("Using password: YES");
	}
	return $db_handler;
}

# Format: <upload> <uploaded_file> [options] -- <uploaded_files>.
# In case of any error help will be printed and execution of the program will be stopped.
# Returns arrray of all file names for upload.
sub parse_command_line()
{
	my @result_fnames = ();
	# Getting first argument as uploaded file.
	push (@result_fnames, shift(@ARGV)) or help();
	
	my $print_help = 0;
	my $is_password = 0;
	
	# Parsing options.
	GetOptions('help|h' => \$print_help,
			   'xml' => \$is_xml,
			   'p' => \$is_password)
	or help();
	
	# Print help.
	help() if ($print_help);
	
	# Password promt.
	if ($is_password)
	{
		system('stty -echo');
		print_debug_normal("Enter password for data base");
		chomp($db_password = <STDIN>);
		system('stty echo');
	}
	# Get options after "--" as other uploaded files.
	foreach (@ARGV)
	{
		push (@result_fnames, $_) or help();
	}
	
	print_debug_debug("Parsing command line has been completed");
	print_debug_debug("Number of uploaded files is ".@result_fnames);
	foreach (@result_fnames)
	{
		print_debug_debug("Uploaded file is '$_'");
	}
	print_debug_debug("Xml format expected") if $is_xml;
	return @result_fnames;
}

# Print help and exit.
sub help()
{
	print(STDERR << "EOM");

NAME
  $PROGRAM_NAME: the tool is intended to upload results to the database.

SYNOPSIS
  $PROGRAM_NAME uploaded_file [option...]

OPTIONS

  -h, --help
    Print this help and exit with a error.
  --xml
    Xml format will be uploaded.
  -p
  	Use password to access the data base.

ENVIRONMENT VARIABLES

  LDV_TASK_NAME
    The name of the task, which is uploaded to the data base.
    Uses when a few files should be uploaded as one task.

  LDVDBHOST, LDVDB, LDVUSER, LDVDBPASSWD
    Keeps settings (host, database, user and password) for connection
    to the database. Note that LDVDB and LDVUSER must always be
    presented!

EOM

	exit(1);
}

sub remove_tmpdir()
{
	chdir ("../");
	if ($tmpdir ne '')
	{
		`rm -rf $tmpdir`;
		print_debug_debug("Tmp directory $tmpdir has been deleted");
	}
	$tmpdir = '';
}

sub disconnect_from_db()
{
	if ($dbh)
	{
		$dbh->disconnect;
		print_debug_normal("Disconnecting from data base");
	}
}

# Actions which should be completed in case of any errors or after finishing uploading.
END 
{
	remove_tmpdir();
	disconnect_from_db();
}

# If option "--xml" was specified then the xml file is uploaded file.
# Otherwise uploaded file will be concidered as pax file, extracted in tmp directory, and xml file will be there.
sub get_xml_file($)
{
	my $uploaded_file = shift;
	my $xml_file;
	if ($is_xml) # "--xml".
	{
		print_debug_debug("Uploaded file will be considered as xml file");
		$xml_file = $uploaded_file;
	}
	else
	{
		print_debug_debug("Uploaded file will be considered as pax file");
		# Create tmp directory '.XXXXXXXXXX'.
		$tmpdir = `mktemp -d --tmpdir=. .XXXXXXXXXX` || die "Can't create tmp directory: $!";
		chomp ($tmpdir);
		print_debug_debug("Tmp directory $tmpdir has been created");
		
# TODO: don't use "chdir", see "directory" in "man pax".
		# Extract pax file into created directory.
		chdir ($tmpdir);
		system("pax -O -r -f ../$uploaded_file") == 0 || die "Can't extract pax file $uploaded_file: $!";
		print_debug_debug("Pax archive has been extracted into $tmpdir");

		# Get xml file from there.
		$xml_file = `find *.xml` || die "Can't locate xml file: $!";
		chomp($xml_file);
		print_debug_debug("Xml file $xml_file was found in $tmpdir");
	}
	return $xml_file;
}

# Parses xml file with LibXML and returns hash.
sub parse_xml_file($)
{
	my $stats_fname = shift;
	
	my $time_before = time;
	print_debug_normal("Start parsing xml file $stats_fname");
	
	# Set LibXML perser.
	$XML::Simple::PREFERRED_PARSER = 'XML::LibXML::SAX';
	
	# Parse.
	my $xml = new XML::Simple;
	my $data = $xml->XMLin($stats_fname, SuppressEmpty => 1, ForceArray => ['ld', 'sources', 'time']); # get data structure for xml file representating

	$time_before = time - $time_before;
	print_debug_normal("Parsing xml file $stats_fname has been completed in $time_before seconds");
	
	# Delete 'cc' section from hash.
	delete $data->{cc};
	return $data;
}

sub upload($$)
{
	my $info = {@_};
	my $xml_data = $info->{xml_data};
	
	$OUTPUT_AUTOFLUSH = 1;
	open my $kb_recalc_pipe, "| kb-recalc.pl --init-cache --new-launch"
        or  die "Can't fork to run kb-recalc: $!\n";
    
	# Unique ids.
	my $environment_id;
	my $task_id;
	
	# Unique names.
	my $version = $xml_data->{build}->{kernel}; # Kernel version (from section <build>).
	my $driver = $xml_data->{launch_info}->{driver}; # Driver name - parameter 'drivers'.
	my $driver_origin = $xml_data->{launch_info}->{driver_origin};
	my $username = $xml_data->{launch_info}->{task}->{username}; 
	my $timestamp; 
	my $task_name = $LDV_TASK_NAME || ''; # LDV_TASK_NAME.

# TODO: fix it in ldv-manager/report-fixup and then fix it here.
	my $month = "";
	if ($xml_data->{launch_info}->{task}->{timestamp}->{mon} < 10)
	{
		$month = "0"."$xml_data->{launch_info}->{task}->{timestamp}->{mon}";
	}
	else
	{
		$month = "$xml_data->{launch_info}->{task}->{timestamp}->{mon}";
	}
	$timestamp = $xml_data->{launch_info}->{task}->{timestamp}->{year}."-".$month."-".
			$xml_data->{launch_info}->{task}->{timestamp}->{mday}." ".$xml_data->{launch_info}->{task}->{timestamp}->{hour}.":".
			$xml_data->{launch_info}->{task}->{timestamp}->{min}.":".$xml_data->{launch_info}->{task}->{timestamp}->{sec};
	
# TODO: move this debug printing to initialization as well. 
	print_debug_debug("Unique values");
	print_debug_debug("version=$version");
	print_debug_debug("driver=$driver");
	print_debug_debug("driver_origin=$driver_origin");
	print_debug_debug("username=$username");
	print_debug_debug("timestamp=$timestamp");
	print_debug_debug("task_name=$task_name");
	
	my $tmp_res; # Result for DB queries.
	
	# Lock DB.
	print_debug_normal("Locking data base");
	sql_query("LOCK TABLES environments WRITE, drivers WRITE, rule_models WRITE, toolsets WRITE, scenarios WRITE, tasks WRITE, launches WRITE, traces WRITE, sources WRITE, stats WRITE, processes WRITE, problems WRITE, problems_stats WRITE\n");
	
	# Start transaction.
	print_debug_normal("Starting commit");
	$dbh->begin_work;

	print_debug_normal("Processing unique values");
	# Processing tasks table.
	$tmp_res = sql_select("SELECT id FROM tasks WHERE (tasks.name = '$task_name') LIMIT 1;");
	if ($tmp_res == 0 || $task_name eq '')
	{
		$tmp_res = sql_insert("INSERT INTO tasks (username, timestamp, driver_spec, driver_spec_origin, name) VALUES ('$username', '$timestamp', '$driver', '$driver_origin', '$task_name');");
	}
	$task_id = $tmp_res; # FK for task.
	
	# Processing environments table.
	$environment_id = sql_select("SELECT id FROM environments WHERE (environments.version = '$version') LIMIT 1;") || 
			sql_insert("INSERT INTO environments (version) VALUES ('$version');");

	# Processing drivers table.
	sql_select("SELECT id FROM drivers WHERE (drivers.name = '$driver') AND (drivers.origin = '$driver_origin') LIMIT 1;") ||
			sql_insert("INSERT INTO drivers (name, origin) VALUES ('$driver', '$driver_origin');");
	
	# Ids for launches.
	my $cur_driver_id;
	my $cur_scenario_id;
	my $cur_launch_id;
	my $cur_trace_id;
	my $cur_stats_id;
	my $cur_toolset_id;
	my $cur_model_id;
	
	# Get max ids.
	$cur_trace_id = sql_select("SELECT max(id) FROM traces;");
	$cur_stats_id = sql_select("SELECT max(id) FROM stats;");
	
	print_debug_normal("Processing data for each launch. This may take some time..");
	if ($xml_data->{ld})
	{
		foreach my $arg (values $xml_data->{ld}) 
		{
			# Variables for launches.
			my $cur_main = $arg->{main} || '';
			my $cur_module = $arg->{module_name} || '';
			my $cur_verdict = $arg->{verdict} || 'UNKNOWN'; # UNKNOWN if not SAFE or UNSAFE.
			my $cur_verifier = $arg->{verifier} || '';
# TODO: as far as I know old scripts upload NULL in this case.
			my $cur_model = $arg->{model} || 'Fail before RI'; # Specific name if there was no enty point.
		
			# For UNSAFEs - error trace and source files.
			my $cur_trace = $arg->{trace} || '';
			my $cur_sources = $arg->{sourcefile} || '';
		
			# Each component of luanch.
			my $cur_build = $arg->{build} || '';
			my $cur_deg = $arg->{'drv-env-gen'} || '';
			my $cur_dscv = $arg->{dscv} || '';
			my $cur_ri = $arg->{'rule-instrumentor'} || '';
			my $cur_rcv = $arg->{rcv} || '';
		
			# Incrementing these values for each launch (not auto increment).
			$cur_trace_id++;
			$cur_stats_id++;
		
			# Processing toolsets table.
			$cur_toolset_id = sql_select("SELECT id FROM toolsets WHERE (toolsets.verifier = '$cur_verifier') LIMIT 1;") || 
					sql_insert("INSERT INTO toolsets (verifier, version) VALUES ('$cur_verifier', 'current');");
		
			# Processing rule_models table.
			$cur_model_id = sql_select("SELECT id FROM rule_models WHERE (rule_models.name = '$cur_model') LIMIT 1;") || 
					sql_insert("INSERT INTO rule_models (name) VALUES ('$cur_model');");
		
			# Processing drivers table.
			$cur_driver_id = sql_select("SELECT id FROM drivers WHERE (drivers.name = '$cur_module' and drivers.origin =
				'$driver_origin') LIMIT 1;") || sql_insert("INSERT INTO drivers (name, origin) VALUES 
				('$cur_module', '$driver_origin');\n");
		
			# Processing scenarios table.
			$cur_scenario_id = sql_insert("INSERT INTO scenarios (driver_id, executable, main) VALUES ($cur_driver_id, '$cur_module', '$cur_main');\n");
		
			# Processing launches table.
			$cur_launch_id = sql_insert("INSERT INTO launches (driver_id, toolset_id, environment_id, rule_model_id, scenario_id, task_id, trace_id) VALUES ($cur_driver_id, '$cur_toolset_id', '$environment_id', '$cur_model_id', $cur_scenario_id, '$task_id', $cur_trace_id);\n");

# TODO: check what old script uploads if there is not an error trace (not an UNSAFE).
			# Error trace file.
			my $et = '\'\'';
			if ($cur_verdict eq "UNSAFE")
			{
				open TRACE_FILE, "<", "traces/$cur_trace" or die "Can't open file traces/$cur_trace: $!";
				my @error_trace = <TRACE_FILE>;
				close TRACE_FILE;
				$et = $dbh->quote(join ("\n", @error_trace));
			}
		
			# Processing traces table.
			sql_query("INSERT INTO traces (id, launch_id, result, error_trace, verifier, build_id, maingen_id, dscv_id, ri_id, rcv_id) VALUES ($cur_trace_id, '$cur_launch_id', '$cur_verdict', $et, '$cur_verifier', $cur_stats_id, $cur_stats_id+1, $cur_stats_id+2, $cur_stats_id+3, $cur_stats_id+4);\n");
		
			# Source files.
			if ($cur_sources ne '')
			{
				foreach my $source (values $cur_sources)
				{
					# Trace file.
					open SOURCE_FILE, "<", "sources/$source" or die "Can't open file sources/$source: $!";;
					my @source_text = <SOURCE_FILE>;
					close SOURCE_FILE;
					my $src = $dbh->quote(join ("\n", @source_text));
				
					# Processing sources table.
					sql_query("INSERT INTO sources (trace_id, name, contents) VALUES ('$cur_trace_id', '$source', $src);\n");
				}
			}
			
			# Send id of unsafe launch to the child process (run kb-recalc for this id).
			if ($cur_verdict eq "UNSAFE")
			{
				print $kb_recalc_pipe "$cur_launch_id";
			}
			
			# Processing stats, processes, problems, problems_stats tables for each component.
# TODO: make a common function for all components since below almost everything is the same.
			# Processing component 'biuld'.
			if ($cur_build ne '')
			{
				my $cur_status = 1;
				if ($cur_build->{status})
				{
					$cur_status = 0 if $cur_build->{status} eq "FAILED";
				}
				my $cur_time = '0';
# TODO: may be NULL is uplouded if there is not any description?
				my $cur_desc = '\'\'';
				if ($cur_build->{desc})
				{
					$cur_desc = $cur_build->{desc};
					$cur_desc = $dbh->quote($cur_desc);
				}
				sql_query("INSERT INTO stats (id, trace_id, kind, success, time, description) VALUES ($cur_stats_id, '$cur_trace_id', 'build', '$cur_status', '$cur_time', $cur_desc);\n");
# TODO: pass a hash reference "{...}", not an array.
				add_processes(old_time => $cur_build->{time}, trace_id => $cur_trace_id, component => 'build-cmd-extractor');
				if ($cur_verdict eq "UNKNOWN")
				{
					add_problems(component => "build", desc => $cur_desc, stats_id => $cur_stats_id);
				}
			}
		
			# Processing component 'deg'.
			$cur_stats_id++;
			if ($cur_deg ne '')
			{
				my $cur_status = 0;
				$cur_status = 1 if $cur_deg->{status} eq "OK";
				my $cur_time = '0';
				my $cur_desc = '\'\'';
				if ($cur_deg->{desc})
				{
					$cur_desc = $cur_deg->{desc};
					$cur_desc = $dbh->quote($cur_desc);
				}
				my $cur_loc = $cur_deg->{loc};
				sql_query("INSERT INTO stats (id, trace_id, kind, success, loc, time, description) VALUES ($cur_stats_id, '$cur_trace_id', 'maingen', '$cur_status', '$cur_loc', '$cur_time', $cur_desc);\n");
			
				add_processes(old_time => $cur_deg->{time}, trace_id => $cur_trace_id, component => 'drv-env-gen');
			}
		
			# Processing component 'dscv'.
			$cur_stats_id++;
			if ($cur_dscv ne '')
			{
				my $cur_status = 0;
				$cur_status = 1 if $cur_dscv->{status} eq "OK";
				my $cur_time = '0';
				my $cur_desc = '\'\'';
				if ($cur_dscv->{desc})
				{
					$cur_desc = $cur_dscv->{desc};
					$cur_desc = $dbh->quote($cur_desc);
				}
				sql_query("INSERT INTO stats (id, trace_id, kind, success, time, description) VALUES ($cur_stats_id, '$cur_trace_id', 'dscv', '$cur_status', '$cur_time', $cur_desc);\n");
			
				add_processes(old_time => $cur_dscv->{time}, trace_id => $cur_trace_id, component => 'dscv');
				if ($cur_verdict eq "UNKNOWN")
				{
					add_problems(component => "dscv", desc => $cur_desc, stats_id => $cur_stats_id);
				}
			}
		
			# Processing component 'ri'.
			$cur_stats_id++;
			if ($cur_ri ne '')
			{
				my $cur_status = 0;
				$cur_status = 1 if $cur_ri->{status} eq "OK";
				my $cur_time = '0';
				my $cur_desc = '\'\'';
				if ($cur_ri->{desc})
				{
					$cur_desc = $cur_ri->{desc};
					$cur_desc = $dbh->quote($cur_desc);
				}
				sql_query("INSERT INTO stats (id, trace_id, kind, success, time, description) VALUES ($cur_stats_id, '$cur_trace_id', 'ri', '$cur_status', '$cur_time', $cur_desc);\n");
			
				# ri - processes.
				add_processes(old_time => $cur_ri->{time}, trace_id => $cur_trace_id, component => 'rule-instrumentor');
			
				# ri - problems.
				if ($cur_verdict eq "UNKNOWN")
				{
					add_problems(component => "ri", desc => $cur_desc, stats_id => $cur_stats_id);
				}
			}
		
			$cur_stats_id++;
			# Processing component 'rcv'.
			if ($cur_rcv ne '')
			{
				my $cur_status = 0;
				$cur_status = 1 if $cur_rcv->{status} eq "OK";
				my $cur_time = '0';
				my $cur_desc = '\'\'';
				if ($cur_rcv->{desc})
				{
					$cur_desc = $cur_rcv->{desc};
					$cur_desc = $dbh->quote($cur_desc);
				}
				sql_query("INSERT INTO stats (id, trace_id, kind, success, time, description) VALUES ($cur_stats_id, '$cur_trace_id', 'rcv', '$cur_status', '$cur_time', $cur_desc);\n");
				
				# rcv - processes.
				add_processes(old_time => $cur_rcv->{time}, trace_id => $cur_trace_id, component => 'rcv');
			
				# rcv - problems.
				if ($cur_verdict eq "UNKNOWN")
				{
					add_problems(component => "rcv", desc => $cur_desc, stats_id => $cur_stats_id);
					add_problems(component => "$cur_verifier", desc => $cur_desc, stats_id => $cur_stats_id);
				}
			}
		}
	}
	$dbh->commit;
	print_debug_normal ("Commit has been completed");
	
	print_debug_normal ("Unlocking data base");
	sql_query("UNLOCK TABLES;\n");

	print_debug_normal ("Results were successfully uploaded to database. They can be found at");
	if ($db_password eq '')
	{
		print_debug_normal ("http://$db_host:8999/stats/index/profilename/default/name/$LDVDB/user/$LDVUSER/host/$db_host/password/no/");
	}
	else
	{
		print_debug_normal ("http://$db_host:8999/stats/index/profilename/default/name/$LDVDB/user/$LDVUSER/host/$db_host/password/<password>/");
		print_debug_normal ("Change <password> to your actual password");
	}
    close $kb_recalc_pipe;
}

sub sql_select($)
{
	my $query = shift;
	chomp($query);
	print_debug_all ($query);
	
	my $db_query = $dbh->prepare($query) or die("Can't prepare a query: " . $dbh->errstr);
	
	$db_query->execute or die("Can't execute a query: " . $dbh->errstr);
	
	my @row = $db_query->fetchrow_array;
	
	return $row[0] || 0;
}

sub sql_insert($)
{
	my $query = shift;
	chomp($query);
	print_debug_all ($query);
	
	my $db_query = $dbh->prepare($query) or die("Can't prepare a query: " . $dbh->errstr);
	
	$db_query->execute or die("Can't execute a query: " . $dbh->errstr);
	
	return $db_query->{mysql_insertid};
}

sub sql_query($)
{
	my $query = shift;
	chomp($query);
	print_debug_all ($query);
	
	my $db_query = $dbh->do($query) or die("Can't do a query: " . $dbh->errstr);
}

# Adds record in problems and problems_stats for specific component.
sub add_problems(%)
{
	my %info = @_;
	my $component = $info{component}; # {rcv, rule-instrumentor, dscv, drv-env-gen, build-cmd-extractor, blast, cbmc, cpachecker, ufo}
	my $cur_desc = $info{desc};
	my $cur_stats_id = $info{stats_id};
	my @result = ();
	if ($cur_desc ne '\'\'') # In case of build failed.
	{
		if ($component eq "rcv")
		{
			eval $problems_functions{'rcv'};
			warn $@ if $@;
		}
		if ($component eq "ri")
		{
			eval $problems_functions{'ri'};
			die $@ if $@;
		}
		if ($component eq "dscv")
		{
			eval $problems_functions{'dscv'};
			warn $@ if $@;
		}
		if ($component eq "build")
		{
			eval $problems_functions{'build'};
			warn $@ if $@;
		}
		if ($component eq "blast")
		{
			eval $problems_functions{'blast'};
			warn $@ if $@;
		}
		if ($component eq "cpachecker")
		{
			eval $problems_functions{'cpachecker'};
			warn $@ if $@;
		}
		if ($component eq "cbmc")
		{
			eval $problems_functions{'cbmc'};
			warn $@ if $@;
		}
		if ($component eq "ufo")
		{
			eval $problems_functions{'ufo'};
			warn $@ if $@;
		}
		
		my $tmp_res;
		foreach my $prob (@result)
		{
			chomp($prob);
			next if ($prob =~ /^\s*$/);
			$tmp_res = sql_select("SELECT id FROM problems WHERE problems.name = '$prob' LIMIT 1;") || 
					sql_insert("INSERT INTO problems (name) VALUES ('$prob');\n");
			sql_query("INSERT INTO problems_stats (stats_id, problem_id) VALUES ($cur_stats_id, $tmp_res);\n");
		}
	}
}

# Adds record in processes for specific component - time/memory.
sub add_processes(%)
{
	my $info = {@_};
	my $old_time = $info->{old_time};
	my $cur_trace_id = $info->{trace_id};
	my $component = $info->{component};
	if (ref ($old_time) eq 'HASH')
	{
		my %new_time = convert_time(old_time => $old_time);
		foreach my $time_name (keys %new_time)
		{
			sql_query("INSERT INTO processes (trace_id, name, pattern, time_average, time_detailed) VALUES ('$cur_trace_id', '$component', '$time_name', '$new_time{$time_name}', '$new_time{$time_name}');\n");
		}
	}
}

# Function for converting hash from xml file into hash {name_of_time => value}.
sub convert_time
{
	my $info = {@_};
	my $old_time = $info->{old_time};
	my %new_time = ();
	foreach my $arg (keys $old_time)
	{
		# For different format
		next if $arg eq 'name';
		if ($arg eq 'content')
		{
			my $time = 0;
			if ($old_time->{content} =~ /^((\d)*)(.*)$/)
			{
				$time = $1;
			}
			$new_time{'ALL'} = $time;
		}
		next if $arg eq 'content';
		
		my $time = 0;
		if (ref($old_time->{$arg}) eq 'HASH' && $old_time->{$arg}->{content} =~ /^((\d)*)(.*)$/)
		{
			$time = $1;
		}
		$new_time{$arg} = $time;
	}
	return %new_time;
}

# Auto generate problem functions, which return array of all problems for specified component and its description.

# Get text for problem functions
sub init_problems()
{
	my $problem_dir = "$FindBin::RealBin/../ldv-manager/problems/";
	my %result_problems;
	my $text;
	
	# Component 'build'.
	$text = read_file("$problem_dir/build/build");
	$text = change_problems_text($text);
	$result_problems{'build'} = $text;
	
	# Component 'dscv'.
	$text = read_file("$problem_dir/dscv/problems");
	$text = change_problems_text($text);
	$result_problems{'dscv'} = $text;
	
	# Component 'rcv'.
	$text = read_file("$problem_dir/rcv/generic");
	$text = change_problems_text($text);
	$result_problems{'rcv'} = $text;
	
	# Component 'ri'.
	$text = read_file("$problem_dir/ri/aspectator");
	$text = change_problems_text($text);
	$result_problems{'ri'} = $text;
	
	# Verifiers.
	$text = read_file("$problem_dir/rcv/blast");
	$text = change_problems_text($text);
	$result_problems{'blast'} = $text;
	
	$text = read_file("$problem_dir/rcv/cbmc");
	$text = change_problems_text($text);
	$result_problems{'cbmc'} = $text;
	
	$text = read_file("$problem_dir/rcv/cpachecker");
	$text = change_problems_text($text);
	$result_problems{'cpachecker'} = $text;
	
	$text = read_file("$problem_dir/rcv/ufo");
	$text = change_problems_text($text);
	$result_problems{'ufo'} = $text;
	
	return %result_problems;
}

sub change_problems_text($)
{
	my $text = shift;
	$text =~ s/\$\\ = "\\n";\n//g;
	$text =~ s/\$, = "\\n";\n//g;
	$text =~ s/ and print "/ and push(\@result,  "/g;
	$text =~ s/";\n/");\n/g;
	$text =~ s/while \(<>\){/foreach\(\$cur_desc\){/g;
	return $text;
}


